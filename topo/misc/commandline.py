"""
To start Topographica, run './topographica' and not this file.  This
file is used to support that file.

./topographica is generated by the Makefile so we keep as much code
outside so the Makefile remains readable, and changes are easier to
implement.

$Id$
"""

__version__='$Revision$'

import sys, __main__, math

from getopt import getopt,GetoptError
import os
from topo.misc.inlinec import import_weave


BANNER         = """
Welcome to Topographica!

Type help() for interactive help with python, help(topo) for general
information about Topographica, help(commandname) for info on a
specific command, or topo.about() for info on this release, including
licensing information.
"""

global_constants = {'PI':math.pi, 'pi':math.pi, 'Pi':math.pi}

def start(interactive=True):
    """
    Function that will display a banner, import topo into main,
    and change the prompt display.  Since this is part of the topo
    package, the topo.__init__ will already be evaluated when this
    file is imported.
    """
    sys.ps1        = 'Topographica> '
    
    for (k,v) in global_constants.items():
        exec '%s = %s' % (k,v) in __main__.__dict__
        
    if interactive:
        print BANNER
        try:
            import readline
        except ImportError:
            print "Module readline not available.\nHistory and completion support disabled."
        else:
        #set up command completion
            import rlcompleter
            readline.parse_and_bind("tab: complete")



### JABHACKALERT!
### 
### This file will need to be rewritten nearly entirely, probably by
### me (jbednar), to be simpler and have the necessary features.  It's
### clear that there's no reason to keep it even partially compatible
### with python's own command-line format, because that format is not
### very useful.  In particular, it needs to be rewritten to allow
### Topographica/Python commands to be passed to the interpreter, even
### when a file is also being executed.  The current implementation
### mirrors the Python standard: a file can be read, or a
### command-string parsed, but not both.  We can probably continue to
### pass such arguments, if we require '--' before them.

# All valid Python 2.4 args, plus 'g' for topo.gui.start()
VALID_OPTS     = 'ic:dEhOQ:StuvVW:xm:g'  


def generate_cmd_prefix(interactive=True,start_gui=False):
    """
    Since a function call is needed for startup, the parameter on if
    the banner should be displayed must be embedded within the command
    string.
    """
#    if start_gui: interactive = True
    # To deal with a need to double-quote under Windows
    if os.name == 'nt': cmd = '"'
    else: cmd = ''

    # (As of 12/2005) With Python 2.4 compiled and run on Windows XP,
    # trying to import Weave after starting the topo command-line will
    # generate a serious system error.  However, importing weave first
    # does not cause problems.  
    try:
        if import_weave:
            import weave    
            cmd += 'import weave; '
    except:
        pass
    
    cmd += 'import topo.misc.commandline; topo.misc.commandline.start(' \
           + str(interactive) + ');'
    if start_gui:
        cmd += ' topo.gui_cmdline_flag = True; import topo.tkgui; topo.tkgui.start();'
    else:
        cmd += ' topo.gui_cmdline_flag = False;'

    if os.name == 'nt': cmd += '"'

    return cmd


def generate_params(argv):
    """
    Read in argv (minus argv[0]!), and rearrange for re-execution.
    Pass along all existing flags as well as possible.  If no -c, peel
    off an argument as the file to evaluate.  If no args, and no -c,
    enter interactive mode by adding a possibly redundant '-i'.
    """
    c_flag = False
    in_opts, in_args = getopt(argv,VALID_OPTS)  

    #print 'in_opts:', in_opts, ' in_args:', in_args

    opts = list()                      # Preserve order in a list.
    flags = dict(in_opts)              # Quickly check opts for '-i'
    for (key, val) in in_opts:
        if key == '-c':                # Add prefix string to start of a '-c' 
            c_flag = True
            val = generate_cmd_prefix(flags.has_key('-i'),
                                      flags.has_key('-g')) + val
        # Python can't handle a '-g', cut it, but add in a -i, so that
        # the GUI will stay.
        if key != '-g':                
            opts.append((key,val))
        else:
            opts.append(('-i',''))

    if not c_flag:                     # Create the '-c' on arg 1 or go interactive.
        if len(in_args) >= 1:
            key = '-c'
	    # Under Windows, assumes the last character from
	    # generate_cmd_prefix is a double-quote that can be cut
	    # off, and then extra commands added.
            if os.name == 'nt':
                val = generate_cmd_prefix(flags.has_key('-i'),
                                          flags.has_key('-g'))[:-1] + 'execfile(\'' + in_args[0] + '\');"'
            else:
                val = generate_cmd_prefix(flags.has_key('-i'),
                                          flags.has_key('-g')) + 'execfile(\'' + in_args[0] + '\');'
            opts.append((key,val))
            in_args = in_args[1:]
        else:
            opts.append(('-i',''))     # Add an '-i' since it's needed with -c.
            opts.append(('-c',generate_cmd_prefix(start_gui=flags.has_key('-g'))))

    args = []
    for each in opts:
        args.append(each[0])
        if each[1] != '': args.append(each[1])
    args = args + in_args
    return args



