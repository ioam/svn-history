"""
A LISSOM-based orientation map, designed to match the equivalent
C++ simulation.

This file is much more complex than necessary, because it is set up to
match the C++ version of the LISSOM simulator as closely as possible.
Most of the variables below are just temporary ones designed to match
those in the other simulator. In addition, some of the techniques for
setting up the network are out of date. Please do not use this file as
an example of how to use Topographica.


To have automatic comparisons made between the Topographica results and
c++ ones, set comparisons=True before running:
./topographica -c "comparisons=True" topo/tests/reference/lissom_or_reference.ty



Notes
=====

- C++ lissom data for comparisons has not been checked into CVS. You can
generate data yourself using the c++ lissom command later in the file.

- This simulation will not pickle, but that is only because it defines
functions in __main__ (and uses lambda functions). Many variables are
also defined in __main__; some these would have to be made available
again for the simulation to work.

- If you get a StopIteration error related to dynamic number, be sure
that the log file or_map_topo.log contains at least as many iterations
as you are trying to perform in this simulation.


Matches the orientation map simulation from figure 6.4 (Reduced) of
Miikkulainen, Bednar, Choe, and Sirosh (2005), Computational Maps in
the Visual Cortex, Springer, except:

 - The default_density is smaller for practicality (142 in the book)
 - The lateral inhibitory radius is 0.5 matrix units greater than in the 
   book, becauseTopographica enforces good circular-shaped CF outlines.
 - Input patterns are evaluated on the entire retina, instead of only up
   to bounds_multiplier=2.5 times the gaussian sigma in the book
 - Input pattern parameters are cropped to a precision of 1 decimal
   place so that they can be exchanged losslessly between simulators
 - Weight patterns are not smoothed around the edges, unlike
   smooth_circular_outlines=True and smooth_circular_radius_trim=-0.25
   used in the book
 - Initial weight patterns were all Constant rather than random afferent
   and Gaussian sigma preset_sigma_exc=11.076 preset_sigma_inh=71.76
   lateral weights used in the book.
 - Inhibitory weight pruning is disabled (not pruning all weights below
   1e-5 as in the book)
 - Only one input pattern is used per iteration, instead of two patterns
   with input_separation_min=14.3 LGN units in the book

All but the first two of these need to be fixed eventually.

NOT YET TESTED AT DIFFERENT DENSITIES.

$Id$
"""
__version__='$Revision$'


#import pdb 
import fixedpoint
import numpy.oldnumeric as Numeric

from math import pi, sqrt

from topo.base.boundingregion import BoundingBox
from topo.sheets.lissom import LISSOM
from topo.sheets.generatorsheet import GeneratorSheet
from topo.projections.basic import CFProjection
from topo.outputfns.basic import PiecewiseLinear
from topo.responsefns.optimized import CFPRF_DotProduct_opt
from topo.learningfns.optimized import CFPLF_Hebbian_opt
from topo.outputfns.optimized import CFPOF_DivisiveNormalizeL1_opt
import topo.patterns.basic

from topo.tests.reference.lissom_log_parser import get_input_params,check_weights,check_activities

# All the C++ data-getting functions will use this as the filename base
topo.tests.reference.lissom_log_parser.filename_base="topo/tests/reference/010910_or_map_512MB."


### Variables to match 010910_or_map_512MB.param and or_defs
#
BaseN=24.0
BaseRN=24.0
area_scale=1.0
#num_eyes=1
rf_radius=BaseRN/4.0+0.5
inh_rad=BaseN/4.0-1.0+0.5 # this factor of 0.5 is added to make shapes similar in C++ and topographica version
exc_rad=max(2.5,BaseN/10.0)

gammaexc=0.9
gammainh=0.9


delta_i=0.1
beta_i=delta_i+0.55


randomness = 0.0


rf_radius_scale=1.0
xsigma=7.0
ysigma=1.5
scale_input=1.0


retina_edge_buffer=rf_radius-0.5+(randomness*BaseRN*area_scale/2)
RN=BaseRN*area_scale+2*retina_edge_buffer


acs=6.5*6.5/rf_radius/rf_radius
ecs=19.5*19.5/exc_rad/exc_rad
ics=47.5*47.5/inh_rad/inh_rad
alpha_input=0.007*acs
alpha_exc=0.002*ecs
alpha_inh=0.00025*ics

tsettle=9


# Number of decimal places for simulator time
fixedpoint.DEFAULT_PRECISION=3

from fixedpoint import FixedPoint
topo.sim.set_time_type(FixedPoint,4)

### Setup the Topographica simulation
#

input_bounds = BoundingBox(radius=RN/(BaseRN*area_scale)/2.0)
gaussian_width = xsigma/BaseRN/sqrt(2.0)
gaussian_height = ysigma/BaseRN/sqrt(2.0)


# get input pattern position parameters from the log file output of
# the equivalent c++ simulation
n_inputs,input_params = get_input_params()


input_pattern = topo.patterns.basic.Gaussian(
    scale=scale_input,
    bounds=input_bounds,
    size = 2*gaussian_height,
    aspect_ratio= gaussian_width/gaussian_height,
    # c++ positions and angle need to be converted to match Topographica
    x=lambda : input_params[0]['cx'].next()/BaseRN - 0.5*RN/BaseRN,
    y=lambda : input_params[0]['cy'].next()/BaseRN - 0.5*RN/BaseRN,
    orientation=lambda : round(2*pi*input_params[0]['theta'].next()/360.0,1))


CFProjection.cf_shape = topo.patterns.basic.Disk(smoothing=0.0)
CFProjection.weights_generator = topo.patterns.basic.Constant()
CFProjection.response_fn=CFPRF_DotProduct_opt()
CFProjection.learning_fn=CFPLF_Hebbian_opt()
CFProjection.weights_output_fn=CFPOF_DivisiveNormalizeL1_opt()


topo.sim['Eye0'] = GeneratorSheet(input_generator=input_pattern,
                                    nominal_bounds=input_bounds,
                                    nominal_density=BaseRN*area_scale,
                                    period=1,
                                    phase=0.05)

topo.sim['Primary'] = LISSOM(output_fn = PiecewiseLinear(lower_bound=delta_i,upper_bound=beta_i),
                        nominal_density = BaseN,
                        tsettle=tsettle)

topo.sim.connect('Eye0','Primary', delay = fixedpoint.FixedPoint("0.05"),
          connection_type=CFProjection,strength = 1.0, name='Afferent0',
          nominal_bounds_template=BoundingBox(radius=rf_radius/BaseRN))


topo.sim.connect('Primary','Primary', delay = fixedpoint.FixedPoint("0.05"),
          connection_type=CFProjection,strength=gammaexc,
          name='LateralExcitatory',
          nominal_bounds_template=BoundingBox(radius=exc_rad/BaseN, min_radius=1.5/BaseN))


topo.sim.connect('Primary','Primary', delay = fixedpoint.FixedPoint("0.05"),
          connection_type=CFProjection,strength=-gammainh,
          name='LateralInhibitory',
          nominal_bounds_template=BoundingBox(radius=inh_rad/BaseN) )


# Cb: should just be x.n_units()
def n_units(x):
    """
    Same technique as in cf.py for counting the number of units.
    """
    center_unit=(int(BaseN/2),int(BaseN/2))
    return len(Numeric.nonzero(Numeric.ravel(x.cfs[center_unit].mask)))


# shortcuts to save on typing...
Af = topo.sim['Primary'].projections()["Afferent0"]
LE = topo.sim['Primary'].projections()["LateralExcitatory"]
LI = topo.sim['Primary'].projections()["LateralInhibitory"]


# Topographica learning rate is independent of density
Af.learning_rate=alpha_input*n_units(Af)
LE.learning_rate=alpha_exc*n_units(LE)
LI.learning_rate=alpha_inh*n_units(LI)


### Excitatory bounds changes
#
# The learning rate is adjusted too because the number of units changes and ecs changes (even if the learning
# rate is going to be adjusted anyway at this time)
topo.sim.schedule_command(199,'exc_rad=exc_rad*0.6; LE.change_bounds(BoundingBox(radius=exc_rad/BaseN)); LE.learning_rate=alpha_exc*n_units(LE)')
topo.sim.schedule_command(499,'exc_rad=exc_rad*0.7; LE.change_bounds(BoundingBox(radius=exc_rad/BaseN));LE.learning_rate=alpha_exc*n_units(LE)')
topo.sim.schedule_command(999,'exc_rad=exc_rad*0.8; LE.change_bounds(BoundingBox(radius=exc_rad/BaseN));LE.learning_rate=alpha_exc*n_units(LE)')
topo.sim.schedule_command(1999,'exc_rad=exc_rad*0.8; LE.change_bounds(BoundingBox(radius=exc_rad/BaseN));LE.learning_rate=alpha_exc*n_units(LE)')
topo.sim.schedule_command(2999,'exc_rad=exc_rad*0.8; LE.change_bounds(BoundingBox(radius=exc_rad/BaseN));LE.learning_rate=alpha_exc*n_units(LE)')
topo.sim.schedule_command(3999,'exc_rad=exc_rad*0.6; LE.change_bounds(BoundingBox(radius=exc_rad/BaseN));LE.learning_rate=alpha_exc*n_units(LE)')
topo.sim.schedule_command(4999,'exc_rad=exc_rad*0.6; LE.change_bounds(BoundingBox(radius=exc_rad/BaseN));LE.learning_rate=alpha_exc*n_units(LE)')
topo.sim.schedule_command(6499,'exc_rad=exc_rad*0.6; LE.change_bounds(BoundingBox(radius=exc_rad/BaseN));LE.learning_rate=alpha_exc*n_units(LE)')
topo.sim.schedule_command(7999,'exc_rad=exc_rad*0.6; LE.change_bounds(BoundingBox(radius=exc_rad/BaseN));LE.learning_rate=alpha_exc*n_units(LE)')
topo.sim.schedule_command(19999,'exc_rad=exc_rad*0.6; LE.change_bounds(BoundingBox(radius=exc_rad/BaseN));LE.learning_rate=alpha_exc*n_units(LE)')


### Excitatory learning rate changes
#
topo.sim.schedule_command(499,'alpha_exc=0.001*ecs; LE.learning_rate=alpha_exc*n_units(LE)')


### Afferent learning rate changes
#
topo.sim.schedule_command(499,  'alpha_input=0.0050*acs; Af.learning_rate=alpha_input*n_units(Af)')
topo.sim.schedule_command(1999, 'alpha_input=0.0040*acs; Af.learning_rate=alpha_input*n_units(Af)')
topo.sim.schedule_command(3999, 'alpha_input=0.0030*acs; Af.learning_rate=alpha_input*n_units(Af)')
topo.sim.schedule_command(19999,'alpha_input=0.0015*acs; Af.learning_rate=alpha_input*n_units(Af)')

### delta/beta changes
#
topo.sim.schedule_command(  199, 'topo.sim["Primary"].output_fn.lower_bound=delta_i+0.01; topo.sim["Primary"].output_fn.upper_bound=beta_i+0.01')
topo.sim.schedule_command(  499, 'topo.sim["Primary"].output_fn.lower_bound=delta_i+0.02; topo.sim["Primary"].output_fn.upper_bound=beta_i+0.02')
topo.sim.schedule_command(  999, 'topo.sim["Primary"].output_fn.lower_bound=delta_i+0.05; topo.sim["Primary"].output_fn.upper_bound=beta_i+0.03')
topo.sim.schedule_command( 1999, 'topo.sim["Primary"].output_fn.lower_bound=delta_i+0.08; topo.sim["Primary"].output_fn.upper_bound=beta_i+0.05')
topo.sim.schedule_command( 2999, 'topo.sim["Primary"].output_fn.lower_bound=delta_i+0.10; topo.sim["Primary"].output_fn.upper_bound=beta_i+0.08')
topo.sim.schedule_command( 3999,                                                    'topo.sim["Primary"].output_fn.upper_bound=beta_i+0.11')
topo.sim.schedule_command( 4999, 'topo.sim["Primary"].output_fn.lower_bound=delta_i+0.11; topo.sim["Primary"].output_fn.upper_bound=beta_i+0.14')
topo.sim.schedule_command( 6499, 'topo.sim["Primary"].output_fn.lower_bound=delta_i+0.12; topo.sim["Primary"].output_fn.upper_bound=beta_i+0.17')
topo.sim.schedule_command( 7999, 'topo.sim["Primary"].output_fn.lower_bound=delta_i+0.13; topo.sim["Primary"].output_fn.upper_bound=beta_i+0.20')
topo.sim.schedule_command(19999, 'topo.sim["Primary"].output_fn.lower_bound=delta_i+0.14; topo.sim["Primary"].output_fn.upper_bound=beta_i+0.23')

#tsettle changes
topo.sim.schedule_command( 1999, 'topo.sim["Primary"].tsettle=10')
topo.sim.schedule_command( 4999, 'topo.sim["Primary"].tsettle=11')
topo.sim.schedule_command( 6499, 'topo.sim["Primary"].tsettle=12')
topo.sim.schedule_command( 7999, 'topo.sim["Primary"].tsettle=13')


### NOTE: c++ lissom does not output unsituated weights, so a function
### in lissom_log_parser guesses how to unsituate the weights. If your
### weights contains rows or columns of zeros, this guessing will fail.


def check_all_weights():
    print "Checking all weights..."
    # we might consider skipping every other one, or something like that!
    for i in range(BaseN):
        for j in range(BaseN):
            check_weights('Primary','Afferent0',(i,j))
            check_weights('Primary','LateralExcitatory',(i,j))
            check_weights('Primary','LateralInhibitory',(i,j))

def check_all_activities():
    check_activities('Eye0')
    check_activities('Primary')
    

if locals().get('comparisons',False):

    ### Check initial weights
    check_all_weights()

    ### Check initial patterns are ok on Eye0 and Primary
    for i in range(5):
        topo.sim.run(1)
        check_all_activities()    
    
    topo.sim.run(5)
    check_all_activities()

    topo.sim.run(10)
    check_all_activities()

    topo.sim.run(80)
    check_all_activities();check_all_weights()

    topo.sim.run(100)
    check_all_activities() #200
    
    topo.sim.run(400)
    check_all_activities() #600
    
    topo.sim.run(300)
    check_all_activities() #900
    
    topo.sim.run(100) # to 1000
    check_all_activities();check_all_weights()

    for i in range(8): # to 9000
        topo.sim.run(1000)
        check_all_activities()


    topo.sim.run(3000) # 12000
    check_all_activities();check_all_weights()

    topo.sim.run(3000)
    check_all_activities()
    
    topo.sim.run(5000)
    check_all_activities();check_all_weights()


# Command to generate lissom data for comparisons
#
#./lissom5 display=0 010910_or_map_512MB.param -c "call set_thresholds.command" -c "ppm_weight_scale_type=PPM_WtScale_Fixed" -c "Region::ppm_weight_fixed_multiplier=1" -c 'PlotGroup::Weights::filename_format="$$$${filebase}.$$$${06iteration}.wts.$$$${current_region}.$$$${current_plot}.$$$${03current_ui}_$$$${03current_uj}"' -c "cmd::plot_unit::weight_situate=False" -c 'call save_all_units.command' -c "step" -c 'plot filename_format=$$$${default_filename_format} save_matrices=True' -c "step" -c 'plot filename_format=$$$${default_filename_format} save_matrices=True'   -c "step" -c 'plot filename_format=$$$${default_filename_format} save_matrices=True' -c "step" -c 'plot filename_format=$$$${default_filename_format} save_matrices=True' -c "step" -c 'plot filename_format=$$$${default_filename_format} save_matrices=True' -c "training t+5" -c 'plot filename_format=$$$${default_filename_format} save_matrices=True' -c "training t+10" -c 'plot filename_format=$$$${default_filename_format} save_matrices=True' -c 'call save_all_units.command' -c "training t+80" -c 'plot filename_format=$$$${default_filename_format} save_matrices=True' -c 'call save_all_units.command' -c "training t+100" -c 'plot filename_format=$$$${default_filename_format} save_matrices=True' -c "training t+400" -c 'plot filename_format=$$$${default_filename_format} save_matrices=True' -c "training t+300" -c 'plot filename_format=$$$${default_filename_format} save_matrices=True' -c "training t+100" -c 'plot filename_format=$$$${default_filename_format} save_matrices=True' -c 'call save_all_units.command' -c "training t+1000" -c 'plot filename_format=$$$${default_filename_format} save_matrices=True' -c "training t+1000" -c 'plot filename_format=$$$${default_filename_format} save_matrices=True' -c "training t+1000" -c 'plot filename_format=$$$${default_filename_format} save_matrices=True' -c "training t+1000" -c 'plot filename_format=$$$${default_filename_format} save_matrices=True' -c "training t+1000" -c 'plot filename_format=$$$${default_filename_format} save_matrices=True' -c "training t+1000" -c 'plot filename_format=$$$${default_filename_format} save_matrices=True' -c "training t+1000" -c 'plot filename_format=$$$${default_filename_format} save_matrices=True' -c "training t+1000" -c 'plot filename_format=$$$${default_filename_format} save_matrices=True'  -c "training t+3000" -c 'plot filename_format=$$$${default_filename_format} save_matrices=True' -c 'call save_all_units.command' -c "training t+3000" -c 'plot filename_format=$$$${default_filename_format} save_matrices=True' -c "training t+5000" -c 'plot filename_format=$$$${default_filename_format} save_matrices=True' -c 'call save_all_units.command'

