"""
A LISSOM-based orientation map, designed to match the equivalent
C++ simulation.

This file is much more complex than necessary, because it is set up to
match the C++ version of the LISSOM simulator as closely as possible.
Most of the variables below are just temporary ones designed to match
those in the other simulator. In addition, some of the techniques for
setting up the network are out of date. Please do not use this file as
an example of how to use Topographica.

Data not yet checked in, etc. Can generate yourself with lissom command near end of file.
./topographica -g -c "comparisons=True;plots=True" topo/tests/reference/lissom_or_reference.ty

$Id$
"""
__version__='$Revision$'


# CB:
# The plan is that when this simulation matches the c++ one (or_map_topo.param),
# more features can be added, and it can be generalized.


# Currently, by 550 iterations a few of the weights values have begun to differ
# by 5 d.p. There are no bounds changes.


#import pdb 
import random
import fixedpoint
import Numeric  # CB: (need to update for numpy)

from math import pi, sqrt

from topo.base.parameterclasses import DynamicNumber
from topo.base.boundingregion import BoundingBox
from topo.sheets.lissom import LISSOM
from topo.sheets.generatorsheet import GeneratorSheet
from topo.projections.basic import CFProjection
from topo.outputfns.basic import PiecewiseLinear
from topo.responsefns.optimized import CFPRF_DotProduct_opt
from topo.learningfns.optimized import CFPLF_Hebbian_opt
from topo.outputfns.optimized import CFPOF_DivisiveNormalizeL1_opt
import topo.patterns.basic


import topo.tests.reference.lissom_log_parser
from topo.tests.reference.lissom_log_parser import get_input_params, get_matrix, compare_elements, compare_weights,compare_activities


###########################################
# Variables from or_map_topo.param

BaseN=24.0
BaseRN=24.0
area_scale=1.0
#num_eyes=1
rf_radius=BaseRN/4.0+0.5 
inh_rad=BaseN/4.0-1.0+0.5
exc_rad=2.5              
#min_exc_rad=max(1.0,BaseN/44+0.5)

#default_afferent_size_scale=BaseN/BaseRN
gammaexc=0.9
gammainh=0.9

delta_i=0.083
beta_i=delta_i+0.55

randomness = 0.0
#smooth_circular_radius_trim = -0.25

rf_radius_scale=5.0/rf_radius
#retina_area_scale = (BaseRN*area_scale/24.0*rf_radius_scale)*(BaseRN*area_scale/24.0*rf_radius_scale)
#inputs_pereye=max(retina_area_scale,1)
xsigma=6.0
ysigma=1.5
scale_input=1.0

retina_edge_buffer=round((rf_radius+(randomness*BaseRN*area_scale/2.0)),0)
RN=round(BaseRN*area_scale+2*retina_edge_buffer,0)

acs=6.5*6.5/rf_radius/rf_radius
ecs=19.5*19.5/exc_rad/exc_rad
ics=47.5*47.5/inh_rad/inh_rad
alpha_input=0.007*acs
alpha_exc=0.002*ecs
alpha_inh=0.00025*ics

tsettle=8


# Number of decimal places for simulator time
fixedpoint.DEFAULT_PRECISION=3
random.seed(1234)


# take the input pattern position parameters from the log file output
# of the equivalent c++ simulation
n_inputs,input_x,input_y,input_orientation = get_input_params(
    log_file="topo/tests/reference/or_map_topo.log")

# c++ lissom's first iteration is just a test, so we lose it
n_inputs-=1;input_x.next();input_y.next();input_orientation.next() 
print "Number of patterns available for learning iterations:",n_inputs

input_bounds = BoundingBox(radius=RN/(BaseRN*area_scale)/2.0)
gaussian_width = xsigma/BaseRN/sqrt(2.0)
gaussian_height = ysigma/BaseRN/sqrt(2.0)

# c++ positions and angle need to be converted to match Topographica
input_pattern = topo.patterns.basic.Gaussian(
    scale=scale_input,
    bounds=input_bounds,
    size = 2*gaussian_height,
    aspect_ratio= gaussian_width/gaussian_height,
    x=DynamicNumber(lambda : input_x.next()/BaseRN - 0.5*RN/BaseRN),
    y=DynamicNumber(lambda : input_y.next()/BaseRN - 0.5*RN/BaseRN),
    orientation=DynamicNumber(lambda : round(2*pi*input_orientation.next()/360.0,1)))


CFProjection.weights_shape = topo.patterns.basic.Disk(smoothing=0.0)
CFProjection.weights_generator = topo.patterns.basic.Constant()
CFProjection.response_fn=CFPRF_DotProduct_opt()
CFProjection.learning_fn=CFPLF_Hebbian_opt()
CFProjection.weights_output_fn=CFPOF_DivisiveNormalizeL1_opt()


topo.sim['Retina'] = GeneratorSheet(input_generator=input_pattern,
                                    nominal_bounds=input_bounds,
                                    nominal_density=BaseRN*area_scale,
                                    period=1,
                                    phase=0.05)

topo.sim['V1'] = LISSOM(output_fn = PiecewiseLinear(lower_bound=delta_i,upper_bound=beta_i),
                        nominal_density = BaseN,
                        tsettle=tsettle)

topo.sim.connect('Retina','V1', delay = fixedpoint.FixedPoint("0.05"),
          connection_type=CFProjection,strength = 1.0, name='Afferent0',
          nominal_bounds_template=BoundingBox(radius=rf_radius/BaseRN))

topo.sim.connect('V1','V1', delay = fixedpoint.FixedPoint("0.05"),
          connection_type=CFProjection,strength=gammaexc,
          name='LateralExcitatory',
          nominal_bounds_template=BoundingBox(radius=exc_rad/BaseN))

topo.sim.connect('V1','V1', delay = fixedpoint.FixedPoint("0.05"),
          connection_type=CFProjection,strength=-gammainh,
          name='LateralInhibitory',
          nominal_bounds_template=BoundingBox(radius=inh_rad/BaseN) )


center_unit=(int(BaseN/2),int(BaseN/2))

def n_units(x):
    """
    Topographica learning rate is density-independent so to compare
    with C++ lissom it's necessary to know the number of units.
    (Same method as in cf.py.)
    """
    return len(Numeric.nonzero(Numeric.ravel(x.cf(*center_unit).mask)))


# shortcuts to save on typing...
# don't try to pickle this simulation
Af = topo.sim['V1'].projections()["Afferent0"]
LE = topo.sim['V1'].projections()["LateralExcitatory"]
LI = topo.sim['V1'].projections()["LateralInhibitory"]


Af.learning_rate=alpha_input*n_units(Af)
LE.learning_rate=alpha_exc*n_units(LE)
LI.learning_rate=alpha_inh*n_units(LI)


### Excitatory bounds changes
#
# The learning rate is adjusted too because the number of units changes (even if the learning
# rate is going to be adjusted anyway at this time)
# 
# CURRENTLY NO BOUNDS CHANGES

## topo.sim.schedule_command(200,'exc_rad*=0.6; LE.change_bounds(BoundingBox(radius=exc_rad/BaseN)); n_units(LE)=n_units(LE); LE.learning_rate=alpha_exc*n_units(LE)')

## topo.sim.schedule_command(500,'exc_rad=exc_rad*0.7+0.35; LE.change_bounds(BoundingBox(radius=exc_rad/BaseN)); n_units(LE)=n_units(LE); LE.learning_rate=alpha_exc*n_units(LE)')

## topo.sim.schedule_command(1000,'exc_rad=exc_rad*0.8-0.3; LE.change_bounds(BoundingBox(radius=exc_rad/BaseN)); n_units(LE)=n_units(LE); LE.learning_rate=alpha_exc*n_units(LE)')

## topo.sim.schedule_command(2000,'exc_rad=2.5; LE.change_bounds(BoundingBox(radius=exc_rad/BaseN)); n_units(LE)=n_units(LE); LE.learning_rate=alpha_exc*n_units(LE)')


### Excitatory learning rate changes
#
topo.sim.schedule_command(200,'alpha_exc=0.002*ecs; LE.learning_rate=alpha_exc*n_units(LE)')
topo.sim.schedule_command(500,'alpha_exc=0.001*ecs; LE.learning_rate=alpha_exc*n_units(LE)')

### Afferent learning rate changes
#
topo.sim.schedule_command(500,  'alpha_input=0.0050*acs; Af.learning_rate=alpha_input*n_units(Af)')
topo.sim.schedule_command(2000, 'alpha_input=0.0040*acs; Af.learning_rate=alpha_input*n_units(Af)')
topo.sim.schedule_command(4000, 'alpha_input=0.0030*acs; Af.learning_rate=alpha_input*n_units(Af)')
topo.sim.schedule_command(20000,'alpha_input=0.0015*acs; Af.learning_rate=alpha_input*n_units(Af)')

### delta/beta changes
#
topo.sim.schedule_command(  200, 'topo.sim["V1"].output_fn.lower_bound=delta_i+0.01; topo.sim["V1"].output_fn.upper_bound=beta_i+0.01')
topo.sim.schedule_command(  500, 'topo.sim["V1"].output_fn.lower_bound=delta_i+0.02; topo.sim["V1"].output_fn.upper_bound=beta_i+0.02')
topo.sim.schedule_command( 1000, 'topo.sim["V1"].output_fn.lower_bound=delta_i+0.05; topo.sim["V1"].output_fn.upper_bound=beta_i+0.03')
topo.sim.schedule_command( 2000, 'topo.sim["V1"].output_fn.lower_bound=delta_i+0.08; topo.sim["V1"].output_fn.upper_bound=beta_i+0.05')
topo.sim.schedule_command( 3000, 'topo.sim["V1"].output_fn.lower_bound=delta_i+0.10; topo.sim["V1"].output_fn.upper_bound=beta_i+0.08')
topo.sim.schedule_command( 4000,                                                    'topo.sim["V1"].output_fn.upper_bound=beta_i+0.11')
topo.sim.schedule_command( 5000, 'topo.sim["V1"].output_fn.lower_bound=delta_i+0.11; topo.sim["V1"].output_fn.upper_bound=beta_i+0.14')
topo.sim.schedule_command( 6500, 'topo.sim["V1"].output_fn.lower_bound=delta_i+0.12; topo.sim["V1"].output_fn.upper_bound=beta_i+0.17')
topo.sim.schedule_command( 8000, 'topo.sim["V1"].output_fn.lower_bound=delta_i+0.13; topo.sim["V1"].output_fn.upper_bound=beta_i+0.20')
topo.sim.schedule_command(20000, 'topo.sim["V1"].output_fn.lower_bound=delta_i+0.14; topo.sim["V1"].output_fn.upper_bound=beta_i+0.23')



# Command to generate lissom data for comparisons
#
#./lissom5 commandpath="/home/chris/scratch/DICE_old/lissom_old/command/" display=0 or_map_topo.param -c "call set_thresholds.command" -c "ppm_weight_scale_type=PPM_WtScale_Fixed" -c "Region::ppm_weight_fixed_multiplier=1" -c 'PlotGroup::Weights::filename_format="$$$${filebase}.$$$${06iteration}.wts.$$$${current_region}.$$$${current_plot}.$$$${03current_ui}_$$$${03current_uj}"' -c "cmd::plot_unit::weight_situate=False" -c 'plot_unit save_matrices=True 0 0' -c 'plot_unit save_matrices=True 12 12' -c "step" -c 'plot filename_format=$$$${default_filename_format} save_matrices=True' -c "training t+49" -c 'plot filename_format=$$$${default_filename_format} save_matrices=True' -c 'plot_unit save_matrices=True 0 0' -c 'plot_unit save_matrices=True 12 12' -c "training t+150" -c 'plot filename_format=$$$${default_filename_format} save_matrices=True' -c 'plot_unit save_matrices=True 0 0' -c 'plot_unit save_matrices=True 12 12' -c "training t+350" -c 'plot filename_format=$$$${default_filename_format} save_matrices=True' -c 'plot_unit save_matrices=True 0 0' -c 'plot_unit save_matrices=True 12 12' -c 'training t+1450' -c 'plot_unit save_matrices=True 0 0' -c 'plot_unit save_matrices=True 12 12'



matching = {}

if locals().get('comparisons',False):

    # no. of decimal places for matching activity and weight values
    topo.tests.reference.lissom_log_parser.act_dp = 5
    topo.tests.reference.lissom_log_parser.wt_dp = 5
    
    # whether or not those functions should plot if there's a difference
    topo.tests.reference.lissom_log_parser.plots = locals().get('plots',False)


    ## C++ lissom doesn't situate weights in matrix files, so slices etc have to be given

    ### Initial weights comparisons
    matching.update(compare_weights(
        'topo/tests/reference/or_map_topo.000000.wts.Primary.Afferent0.000_000.matrix', 
        slice(1,14),slice(1,14),(RN,RN),
        (0,0),'V1','Afferent0'))

    matching.update(compare_weights(
        'topo/tests/reference/or_map_topo.000000.wts.Primary.Afferent0.012_012.matrix', 
        slice(13,26),slice(13,26),(RN,RN),
        (12,12),'V1','Afferent0'))

    matching.update(compare_weights(
        'topo/tests/reference/or_map_topo.000000.wts.Primary.LateralExcitatory.000_000.matrix',
        slice(0,3),slice(0,3),(BaseN,BaseN),
        (0,0),'V1','LateralExcitatory'))

    matching.update(compare_weights(
        'topo/tests/reference/or_map_topo.000000.wts.Primary.LateralExcitatory.012_012.matrix',
        slice(10,15),slice(10,15),(BaseN,BaseN),
        (12,12),'V1','LateralExcitatory'))

    matching.update(compare_weights(
        'topo/tests/reference/or_map_topo.000000.wts.Primary.LateralInhibitory.000_000.matrix',
        slice(0,6),slice(0,6),(BaseN,BaseN),
        (0,0),'V1','LateralInhibitory'))

    matching.update(compare_weights(
        'topo/tests/reference/or_map_topo.000000.wts.Primary.LateralInhibitory.012_012.matrix',
        slice(7,18),slice(7,18),(BaseN,BaseN),
        (12,12),'V1','LateralInhibitory'))


    topo.sim.run(50)


    matching.update(compare_weights(
        'topo/tests/reference/or_map_topo.000050.wts.Primary.Afferent0.000_000.matrix', 
        slice(1,14),slice(1,14),(RN,RN),
        (0,0),'V1','Afferent0'))

    matching.update(compare_weights(
        'topo/tests/reference/or_map_topo.000050.wts.Primary.Afferent0.012_012.matrix', 
        slice(13,26),slice(13,26),(RN,RN),
        (12,12),'V1','Afferent0'))

    matching.update(compare_weights(
        'topo/tests/reference/or_map_topo.000050.wts.Primary.LateralExcitatory.000_000.matrix',
        slice(0,3),slice(0,3),(BaseN,BaseN),
        (0,0),'V1','LateralExcitatory'))

    matching.update(compare_weights(
        'topo/tests/reference/or_map_topo.000050.wts.Primary.LateralExcitatory.012_012.matrix',
        slice(10,15),slice(10,15),(BaseN,BaseN),
        (12,12),'V1','LateralExcitatory'))

    matching.update(compare_weights(
        'topo/tests/reference/or_map_topo.000050.wts.Primary.LateralInhibitory.000_000.matrix',
        slice(0,6),slice(0,6),(BaseN,BaseN),
        (0,0),'V1','LateralInhibitory'))

    matching.update(compare_weights(
        'topo/tests/reference/or_map_topo.000050.wts.Primary.LateralInhibitory.012_012.matrix',
        slice(7,18),slice(7,18),(BaseN,BaseN),
        (12,12),'V1','LateralInhibitory'))


    topo.sim.run(500)


    matching.update(compare_weights(
        'topo/tests/reference/or_map_topo.000550.wts.Primary.Afferent0.000_000.matrix', 
        slice(1,14),slice(1,14),(RN,RN),
        (0,0),'V1','Afferent0'))

    matching.update(compare_weights(
        'topo/tests/reference/or_map_topo.000550.wts.Primary.Afferent0.012_012.matrix', 
        slice(13,26),slice(13,26),(RN,RN),
        (12,12),'V1','Afferent0'))

    matching.update(compare_weights(
        'topo/tests/reference/or_map_topo.000550.wts.Primary.LateralExcitatory.000_000.matrix',
        slice(0,3),slice(0,3),(BaseN,BaseN),
        (0,0),'V1','LateralExcitatory'))

    matching.update(compare_weights(
        'topo/tests/reference/or_map_topo.000550.wts.Primary.LateralExcitatory.012_012.matrix',
        slice(10,15),slice(10,15),(BaseN,BaseN),
        (12,12),'V1','LateralExcitatory'))

    matching.update(compare_weights(
        'topo/tests/reference/or_map_topo.000550.wts.Primary.LateralInhibitory.000_000.matrix',
        slice(0,6),slice(0,6),(BaseN,BaseN),
        (0,0),'V1','LateralInhibitory'))

    matching.update(compare_weights(
        'topo/tests/reference/or_map_topo.000550.wts.Primary.LateralInhibitory.012_012.matrix',
        slice(7,18),slice(7,18),(BaseN,BaseN),
        (12,12),'V1','LateralInhibitory'))


##     topo.sim.run(1450)
    
##     matching.update(compare_weights(
##         'topo/tests/reference/or_map_topo.002000.wts.Primary.Afferent0.000_000.matrix', 
##         slice(1,14),slice(1,14),(RN,RN),
##         (0,0),'V1','Afferent0'))

##     matching.update(compare_weights(
##         'topo/tests/reference/or_map_topo.002000.wts.Primary.Afferent0.012_012.matrix', 
##         slice(13,26),slice(13,26),(RN,RN),
##         (12,12),'V1','Afferent0'))

##     matching.update(compare_weights(
##         'topo/tests/reference/or_map_topo.002000.wts.Primary.LateralExcitatory.000_000.matrix',
##         slice(0,3),slice(0,3),(BaseN,BaseN),
##         (0,0),'V1','LateralExcitatory'))

##     matching.update(compare_weights(
##         'topo/tests/reference/or_map_topo.002000.wts.Primary.LateralExcitatory.012_012.matrix',
##         slice(10,15),slice(10,15),(BaseN,BaseN),
##         (12,12),'V1','LateralExcitatory'))

##     matching.update(compare_weights(
##         'topo/tests/reference/or_map_topo.002000.wts.Primary.LateralInhibitory.000_000.matrix',
##         slice(0,6),slice(0,6),(BaseN,BaseN),
##         (0,0),'V1','LateralInhibitory'))

##     matching.update(compare_weights(
##         'topo/tests/reference/or_map_topo.002000.wts.Primary.LateralInhibitory.012_012.matrix',
##         slice(7,18),slice(7,18),(BaseN,BaseN),
##         (12,12),'V1','LateralInhibitory'))





    ### PRINT OUT RESULTS
    #
    print "\n"; print "\n"
    print "** RESULTS **"
    print "\n"
    print "Checking weights to "+str(topo.tests.reference.lissom_log_parser.wt_dp)+" d.p. and activity values to "+str(topo.tests.reference.lissom_log_parser.act_dp)+ " d.p." 
    print "\n"
    for what,result in matching.items():
        if result:
            print what + " ... pass"
        else:
            print what + " ... FAIL"

