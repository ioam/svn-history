"""
A LISSOM-based orientation map, designed to match the equivalent
C++ simulation.

This file is much more complex than necessary, because it is set up to
match the C++ version of the LISSOM simulator as closely as possible.
Most of the variables below are just temporary ones designed to match
those in the other simulator. In addition, some of the techniques for
setting up the network are out of date. Please do not use this file as
an example of how to use Topographica.


./topographica -g -c "comparisons=True" topo/tests/reference/lissom_or_reference.ty

$Id$
"""
__version__='$Revision$'


# CEBHACKALERT: scheduled events not yet verified



#import pdb # debugger
import random
import fixedpoint
# CEBHACKALERT: this file will need minor updates to change to numpy
import Numeric

from math import pi, sqrt

from topo.base.parameterclasses import DynamicNumber
from topo.base.boundingregion import BoundingBox
from topo.sheets.lissom import LISSOM
from topo.sheets.generatorsheet import GeneratorSheet
from topo.projections.basic import CFProjection
from topo.outputfns.basic import PiecewiseLinear
from topo.responsefns.optimized import CFPRF_DotProduct_opt
from topo.learningfns.optimized import CFPLF_Hebbian_opt
from topo.outputfns.optimized import CFPOF_DivisiveNormalizeL1_opt
import topo.patterns.basic

from topo.tests.reference.lissom_log_parser import get_input_params



###########################################
# Variables to match the C++ version of LISSOM

### (1)
BaseN=72.0
BaseRN=24.0
area_scale=1.0
#num_eyes=1
rf_radius=BaseRN/4.0+0.5
inh_rad=max(2.5,BaseN/4.0-1.0)+0.5
exc_rad=max(2.5,BaseN/10.0)+0.3
min_exc_rad=max(1.0,BaseN/44+0.5)

#default_afferent_size_scale=BaseN/BaseRN
gammaexc=0.9
gammainh=0.9
delta=0.1
beta=0.65


### (2)
randomness = 0.0
#smooth_circular_radius_trim = -0.25

rf_radius_scale=5.0/rf_radius
#retina_area_scale = (BaseRN*area_scale/24.0*rf_radius_scale)*(BaseRN*area_scale/24.0*rf_radius_scale)
#inputs_pereye=max(retina_area_scale,1)
xsigma=6.0
ysigma=1.5
scale_input=1.0

retina_edge_buffer=round((rf_radius+(randomness*BaseRN*area_scale/2.0)),0)
RN=round(BaseRN*area_scale+2*retina_edge_buffer,0)

### (3)
acs=6.5*6.5/rf_radius/rf_radius
ecs=19.5*19.5/exc_rad/exc_rad
ics=47.5*47.5/inh_rad/inh_rad
alpha_input=0.007*acs
alpha_exc=0.002*ecs
alpha_inh=0.00025*ics


tsettle=8


# Number of decimal places for simulator time
fixedpoint.DEFAULT_PRECISION=3
random.seed(1234)

# input generation params
GeneratorSheet.nominal_density = BaseRN*area_scale
GeneratorSheet.period = 1
GeneratorSheet.phase = 0.05

# take the input pattern position parameters from the log file output
# of the equivalent c++ simulation
n_inputs,input_x,input_y,input_orientation = get_input_params(
    log_file="topo/tests/reference/or_map_topo.log")

# c++ lissom's first iteration is just a test...
n_inputs-=1;input_x.next();input_y.next();input_orientation.next() 

print "Number of patterns available for learning iterations:",n_inputs

input_bounds = BoundingBox(radius=RN/(BaseRN*area_scale)/2.0)
gaussian_width = xsigma/BaseRN/sqrt(2.0)
gaussian_height = ysigma/BaseRN/sqrt(2.0)

# c++ positions and angle need to be converted to match Topographica
input_pattern = topo.patterns.basic.Gaussian(
    scale=scale_input,
    bounds=input_bounds,
    size = 2*gaussian_height,
    aspect_ratio= gaussian_width/gaussian_height,
    x=DynamicNumber(lambda : input_x.next()/BaseRN - 0.5*RN/BaseRN),
    y=DynamicNumber(lambda : input_y.next()/BaseRN - 0.5*RN/BaseRN),
    orientation=DynamicNumber(lambda : round(2*pi*input_orientation.next()/360.0,1)))


# LISSOM parameters
LISSOM.output_fn = PiecewiseLinear(lower_bound=delta,upper_bound=beta)
LISSOM.nominal_density = BaseN
#LISSOM.tsettle=tsettle

# Connection parameters
afferent_weight_bounds = BoundingBox(radius=rf_radius/BaseRN)
excitatory_weight_bounds = BoundingBox(radius=exc_rad/BaseN,min_radius=min_exc_rad/BaseN)
inhibitory_weight_bounds = BoundingBox(radius=inh_rad/BaseN)

CFProjection.weights_shape = topo.patterns.basic.Disk(smoothing=0.0)
CFProjection.weights_generator = topo.patterns.basic.Constant()
CFProjection.response_fn=CFPRF_DotProduct_opt()
CFProjection.learning_fn=CFPLF_Hebbian_opt()
CFProjection.weights_output_fn=CFPOF_DivisiveNormalizeL1_opt()



topo.sim['Retina'] = GeneratorSheet(input_generator=input_pattern,
                                    nominal_bounds=input_bounds)
topo.sim['V1'] = LISSOM()

topo.sim.connect('Retina','V1', delay = fixedpoint.FixedPoint("0.05"),
          connection_type=CFProjection,strength = 1.0, name='Afferent0',
          nominal_bounds_template = afferent_weight_bounds)

topo.sim.connect('V1','V1', delay = fixedpoint.FixedPoint("0.05"),
          connection_type=CFProjection,strength=gammaexc,
          name='LateralExcitatory',
          nominal_bounds_template = excitatory_weight_bounds)

topo.sim.connect('V1','V1', delay = fixedpoint.FixedPoint("0.05"),
          connection_type=CFProjection,strength=-gammainh,
          name='LateralInhibitory',
          nominal_bounds_template = inhibitory_weight_bounds)

# don't try to pickle this simulation
V1 = topo.sim['V1']
Af = V1.projections()["Afferent0"]
LE = V1.projections()["LateralExcitatory"]
LI = V1.projections()["LateralInhibitory"]


# Topographica learning rate is density-independent so to compare
# with C++ lissom it's necessary to know the number of units.
# (seems like a complex method but it's the same as that in cf.py)
center=(int(BaseN/2),int(BaseN/2))
from Numeric import ravel,nonzero
def n_units(x):
    return len(nonzero(ravel(x.cf(*center).mask)))


n_aff_units=n_units(Af)
n_exc_units=n_units(LE)
n_inh_units=n_units(LI)


Af.learning_rate=alpha_input*n_aff_units
LE.learning_rate=alpha_exc*n_exc_units
LI.learning_rate=alpha_inh*n_inh_units



### Excitatory bounds changes
#
# The learning rate is adjusted too because the number of units changes (even if the learning
# rate is going to be adjusted anyway at this time)
# 
# CEBHACKALERT (for somewhere else!): why do I have to type min_rad every time?
topo.sim.schedule_command(2, 'exc_rad*=0.6; LE.change_bounds(BoundingBox(radius=exc_rad/BaseN,min_radius=min_exc_rad/BaseN)); n_exc_units=n_units(LE); LE.learning_rate=alpha_exc*n_exc_units')

topo.sim.schedule_command(5, 'exc_rad*=0.7; LE.change_bounds(BoundingBox(radius=exc_rad/BaseN,min_radius=min_exc_rad/BaseN)); n_exc_units=n_units(LE); LE.learning_rate=alpha_exc*n_exc_units')

topo.sim.schedule_command(10,'exc_rad*=0.8; LE.change_bounds(BoundingBox(radius=exc_rad/BaseN,min_radius=min_exc_rad/BaseN)); n_exc_units=n_units(LE); LE.learning_rate=alpha_exc*n_exc_units')

topo.sim.schedule_command(20,'exc_rad=2.0; LE.change_bounds(BoundingBox(radius=exc_rad/BaseN,min_radius=min_exc_rad/BaseN)); n_exc_units=n_units(LE); LE.learning_rate=alpha_exc*n_exc_units')


### Excitatory learning rate changes
#

topo.sim.schedule_command(  2,'alpha_exc=0.002*ecs; LE.learning_rate=alpha_exc*n_exc_units')
topo.sim.schedule_command(  5,'alpha_exc=0.001*ecs; LE.learning_rate=alpha_exc*n_exc_units')

### Afferent learning rate changes
#
topo.sim.schedule_command(  5,'alpha_input=0.0050*acs; Af.learning_rate=alpha_input*n_aff_units')
topo.sim.schedule_command( 20,'alpha_input=0.0040*acs; Af.learning_rate=alpha_input*n_aff_units')
topo.sim.schedule_command( 40,'alpha_input=0.0030*acs; Af.learning_rate=alpha_input*n_aff_units')
topo.sim.schedule_command(20000,'alpha_input=0.0015*acs; Af.learning_rate=alpha_input*n_aff_units')

### delta/beta changes
#
topo.sim.schedule_command(  200, 'topo.sim["V1"].output_fn.lower_bound=0.11; topo.sim["V1"].output_fn.upper_bound=0.66')
topo.sim.schedule_command(  500, 'topo.sim["V1"].output_fn.lower_bound=0.12; topo.sim["V1"].output_fn.upper_bound=0.67')
topo.sim.schedule_command( 1000, 'topo.sim["V1"].output_fn.lower_bound=0.15; topo.sim["V1"].output_fn.upper_bound=0.68')
topo.sim.schedule_command( 2000, 'topo.sim["V1"].output_fn.lower_bound=0.18; topo.sim["V1"].output_fn.upper_bound=0.70')
topo.sim.schedule_command( 3000, 'topo.sim["V1"].output_fn.lower_bound=0.20; topo.sim["V1"].output_fn.upper_bound=0.73')
topo.sim.schedule_command( 4000, 'topo.sim["V1"].output_fn.lower_bound=0.20; topo.sim["V1"].output_fn.upper_bound=0.76')
topo.sim.schedule_command( 5000, 'topo.sim["V1"].output_fn.lower_bound=0.21; topo.sim["V1"].output_fn.upper_bound=0.79')
topo.sim.schedule_command( 6500, 'topo.sim["V1"].output_fn.lower_bound=0.22; topo.sim["V1"].output_fn.upper_bound=0.82')
topo.sim.schedule_command( 8000, 'topo.sim["V1"].output_fn.lower_bound=0.23; topo.sim["V1"].output_fn.upper_bound=0.85')
topo.sim.schedule_command(20000, 'topo.sim["V1"].output_fn.lower_bound=0.24; topo.sim["V1"].output_fn.upper_bound=0.88')








# Performance profiling
#
# Example 1
#import hotshot,hotshot.stats
#prof = hotshot.Profile("abc")
#prof.runctx('s.run(10000)',globals(),locals())
#prof.close()
#
#p = hotshot.stats.load("abc")
#p.strip_dirs().sort_stats('cumulative','time').print_stats()
#
# Example 2
#import profile,pstats
#profile.runctx('s.run(10000)',globals(),locals(),"abc")
#p = pstats.Stats('abc')
#p.strip_dirs().sort_stats('cumulative').print_stats()



### COMPARISONS
# ./lissom5 commandpath="/home/chris/scratch/DICE_old/lissom_old/command/" display=0 or_map_topo.param -c "call set_thresholds.command" -c "ppm_weight_scale_type=PPM_WtScale_Fixed" -c "Region::ppm_weight_fixed_multiplier=1" -c 'PlotGroup::Weights::filename_format="$$$${filebase}.$$$${06iteration}.wts.$$$${current_region}.$$$${current_plot}.$$$${03current_ui}_$$$${03current_uj}"' -c "cmd::plot_unit::weight_situate=False" -c 'plot_unit save_matrices=True 0 0' -c 'plot_unit save_matrices=True 23 23' -c "step" -c 'plot filename_format=$$$${default_filename_format} save_matrices=True' -c "training t+49" -c 'plot filename_format=$$$${default_filename_format} save_matrices=True'

#
import topo.tests.reference.lissom_log_parser
from topo.tests.reference.lissom_log_parser import get_input_params, get_matrix, compare_elements, compare_weights,compare_activities

# no. of decimal places for matching activity and weight values
topo.tests.reference.lissom_log_parser.act_dp = 4
topo.tests.reference.lissom_log_parser.wt_dp = 4

topo.tests.reference.lissom_log_parser.plots = locals().get('plots',False)



matching = {}

if locals().get('comparisons',False):



    topo.sim.run(1)

    ### FIRST ITERATION ACTIVITY COMPARISONS
    #
    matching.update(compare_activities("topo/tests/reference/or_map_topo.000001p000.Eye0_Activity.matrix",(RN,RN),"Retina"))

    matching.update(compare_activities("topo/tests/reference/or_map_topo.000001p000.Primary_Activity.matrix",(BaseN,BaseN),"V1"))




    #topo.sim.run(49)


    # 50th ITERATION WEIGHTS COMPARISONS
    
    

    # 50th ITERATION ACTIVITY COMPARISONS
    
    
    



    print "\n"; print "\n"
    print "** RESULTS **"
    print "\n"
    print "Checking weights to "+str(topo.tests.reference.lissom_log_parser.wt_dp)+" d.p. and activity values to "+str(topo.tests.reference.lissom_log_parser.act_dp)+ " d.p." 
    print "\n"
    for what,result in matching.items():
        if result:
            print what + " ... pass"
        else:
            print what + " ... FAIL"

