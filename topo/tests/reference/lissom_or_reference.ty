"""
A LISSOM-based orientation map, designed to match the equivalent
C++ simulation.

This file is much more complex than necessary, because it is set up to
match the C++ version of the LISSOM simulator as closely as possible.
Most of the variables below are just temporary ones designed to match
those in the other simulator. In addition, some of the techniques for
setting up the network are out of date. Please do not use this file as
an example of how to use Topographica.


To have automatic comparisons made between the Topographica results and
c++ ones, set comparisons=True before running:
./topographica -c "comparisons=True" topo/tests/reference/lissom_or_reference.ty



Notes
=====

- C++ lissom data for comparisons has not been checked into CVS. You can
generate data yourself using the c++ lissom command later in the file.

- This simulation will not pickle, but that is only because it defines
functions in __main__ (and uses lambda functions). Many variables are
also defined in __main__; some these would have to be made available
again for the simulation to work.

- If you get a StopIteration error related to dynamic number, be sure
that the log file or_map_topo.log contains at least as many iterations
as you are trying to perform in this simulation.



$Id$
"""
__version__='$Revision$'


# CB:
# The plan is that when this simulation matches the c++ one (or_map_topo.param),
# more features can be added, and it can be generalized.



#import pdb 
import fixedpoint
import Numeric  # CB: (need to update for numpy)

from math import pi, sqrt

from topo.base.parameterclasses import DynamicNumber
from topo.base.boundingregion import BoundingBox
from topo.sheets.lissom import LISSOM
from topo.sheets.generatorsheet import GeneratorSheet
from topo.projections.basic import CFProjection
from topo.outputfns.basic import PiecewiseLinear
from topo.responsefns.optimized import CFPRF_DotProduct_opt
from topo.learningfns.optimized import CFPLF_Hebbian_opt
from topo.outputfns.optimized import CFPOF_DivisiveNormalizeL1_opt
import topo.patterns.basic

from topo.tests.reference.lissom_log_parser import get_input_params,check_weights,check_activities

#
filename_base="topo/tests/reference/or_map_topo."


### Variables to match or_map_topo.param
#
BaseN=24.0
BaseRN=24.0
area_scale=1.0
#num_eyes=1
rf_radius=BaseRN/4.0+0.5 
inh_rad=BaseN/4.0-1.0+0.5
exc_rad=2.5 #BaseN/10.0              
#min_exc_rad=max(1.0,BaseN/44+0.5)

#default_afferent_size_scale=BaseN/BaseRN
gammaexc=0.9
gammainh=0.9

delta_i=0.083
beta_i=delta_i+0.55

randomness = 0.0
#smooth_circular_radius_trim = -0.25

rf_radius_scale=5.0/rf_radius
#retina_area_scale = (BaseRN*area_scale/24.0*rf_radius_scale)*(BaseRN*area_scale/24.0*rf_radius_scale)
#inputs_pereye=max(retina_area_scale,1)
xsigma=6.0
ysigma=1.5
scale_input=1.0

retina_edge_buffer=round((rf_radius+(randomness*BaseRN*area_scale/2.0)),0)
RN=round(BaseRN*area_scale+2*retina_edge_buffer,0)

acs=6.5*6.5/rf_radius/rf_radius
ecs=19.5*19.5/exc_rad/exc_rad
ics=47.5*47.5/inh_rad/inh_rad
alpha_input=0.007*acs
alpha_exc=0.002*ecs
alpha_inh=0.00025*ics

tsettle=8


# Number of decimal places for simulator time
fixedpoint.DEFAULT_PRECISION=3



### Setup the Topographica simulation
#

input_bounds = BoundingBox(radius=RN/(BaseRN*area_scale)/2.0)
gaussian_width = xsigma/BaseRN/sqrt(2.0)
gaussian_height = ysigma/BaseRN/sqrt(2.0)


# get input pattern position parameters from the log file output of
# the equivalent c++ simulation
n_inputs,input_x,input_y,input_orientation = get_input_params(filename_base+'log')

# c++ lissom's first iteration is just a test, so we lose it
n_inputs-=1;input_x.next();input_y.next();input_orientation.next() 
print "Number of patterns available for learning iterations:",n_inputs

input_pattern = topo.patterns.basic.Gaussian(
    scale=scale_input,
    bounds=input_bounds,
    size = 2*gaussian_height,
    aspect_ratio= gaussian_width/gaussian_height,
    # c++ positions and angle need to be converted to match Topographica
    x=DynamicNumber(lambda : input_x.next()/BaseRN - 0.5*RN/BaseRN),
    y=DynamicNumber(lambda : input_y.next()/BaseRN - 0.5*RN/BaseRN),
    orientation=DynamicNumber(lambda : round(2*pi*input_orientation.next()/360.0,1)))


CFProjection.weights_shape = topo.patterns.basic.Disk(smoothing=0.0)
CFProjection.weights_generator = topo.patterns.basic.Constant()
CFProjection.response_fn=CFPRF_DotProduct_opt()
CFProjection.learning_fn=CFPLF_Hebbian_opt()
CFProjection.weights_output_fn=CFPOF_DivisiveNormalizeL1_opt()


topo.sim['Eye0'] = GeneratorSheet(input_generator=input_pattern,
                                    nominal_bounds=input_bounds,
                                    nominal_density=BaseRN*area_scale,
                                    period=1,
                                    phase=0.05)

topo.sim['Primary'] = LISSOM(output_fn = PiecewiseLinear(lower_bound=delta_i,upper_bound=beta_i),
                        nominal_density = BaseN,
                        tsettle=tsettle)

topo.sim.connect('Eye0','Primary', delay = fixedpoint.FixedPoint("0.05"),
          connection_type=CFProjection,strength = 1.0, name='Afferent0',
          nominal_bounds_template=BoundingBox(radius=rf_radius/BaseRN))

topo.sim.connect('Primary','Primary', delay = fixedpoint.FixedPoint("0.05"),
          connection_type=CFProjection,strength=gammaexc,
          name='LateralExcitatory',
          nominal_bounds_template=BoundingBox(radius=exc_rad/BaseN))

topo.sim.connect('Primary','Primary', delay = fixedpoint.FixedPoint("0.05"),
          connection_type=CFProjection,strength=-gammainh,
          name='LateralInhibitory',
          nominal_bounds_template=BoundingBox(radius=inh_rad/BaseN) )




def n_units(x):
    """
    Same technique as in cf.py for counting the number of units.
    """
    center_unit=(int(BaseN/2),int(BaseN/2))
    return len(Numeric.nonzero(Numeric.ravel(x.cf(*center_unit).mask)))


# shortcuts to save on typing...
Af = topo.sim['Primary'].projections()["Afferent0"]
LE = topo.sim['Primary'].projections()["LateralExcitatory"]
LI = topo.sim['Primary'].projections()["LateralInhibitory"]


# Topographica learning rate is independent of density
Af.learning_rate=alpha_input*n_units(Af)
LE.learning_rate=alpha_exc*n_units(LE)
LI.learning_rate=alpha_inh*n_units(LI)


### Excitatory bounds changes
#
# The learning rate is adjusted too because the number of units changes (even if the learning
# rate is going to be adjusted anyway at this time)
# exc_rad*=0.6
#topo.sim.schedule_command(199,'exc_rad=2.5; LE.change_bounds(BoundingBox(radius=exc_rad/BaseN)); LE.learning_rate=alpha_exc*n_units(LE)')

#topo.sim.schedule_command(499,'exc_rad=exc_rad*0.7+0.35; LE.change_bounds(BoundingBox(radius=exc_rad/BaseN)); LE.learning_rate=alpha_exc*n_units(LE)')

#topo.sim.schedule_command(999,'exc_rad=exc_rad*0.8-0.3; LE.change_bounds(BoundingBox(radius=exc_rad/BaseN)); LE.learning_rate=alpha_exc*n_units(LE)')

#topo.sim.schedule_command(1999,'exc_rad=2.5; LE.change_bounds(BoundingBox(radius=exc_rad/BaseN)); LE.learning_rate=alpha_exc*n_units(LE)')


### Excitatory learning rate changes
#
topo.sim.schedule_command(499,'alpha_exc=0.001*ecs; LE.learning_rate=alpha_exc*n_units(LE)')

### Afferent learning rate changes
#
topo.sim.schedule_command(499,  'alpha_input=0.0050*acs; Af.learning_rate=alpha_input*n_units(Af)')
topo.sim.schedule_command(1999, 'alpha_input=0.0040*acs; Af.learning_rate=alpha_input*n_units(Af)')
topo.sim.schedule_command(3999, 'alpha_input=0.0030*acs; Af.learning_rate=alpha_input*n_units(Af)')
topo.sim.schedule_command(19999,'alpha_input=0.0015*acs; Af.learning_rate=alpha_input*n_units(Af)')

### delta/beta changes
#
topo.sim.schedule_command(  199, 'topo.sim["Primary"].output_fn.lower_bound=delta_i+0.01; topo.sim["Primary"].output_fn.upper_bound=beta_i+0.01')
topo.sim.schedule_command(  499, 'topo.sim["Primary"].output_fn.lower_bound=delta_i+0.02; topo.sim["Primary"].output_fn.upper_bound=beta_i+0.02')
topo.sim.schedule_command(  999, 'topo.sim["Primary"].output_fn.lower_bound=delta_i+0.05; topo.sim["Primary"].output_fn.upper_bound=beta_i+0.03')
topo.sim.schedule_command( 1999, 'topo.sim["Primary"].output_fn.lower_bound=delta_i+0.08; topo.sim["Primary"].output_fn.upper_bound=beta_i+0.05')
topo.sim.schedule_command( 2999, 'topo.sim["Primary"].output_fn.lower_bound=delta_i+0.10; topo.sim["Primary"].output_fn.upper_bound=beta_i+0.08')
topo.sim.schedule_command( 3999,                                                    'topo.sim["Primary"].output_fn.upper_bound=beta_i+0.11')
topo.sim.schedule_command( 4999, 'topo.sim["Primary"].output_fn.lower_bound=delta_i+0.11; topo.sim["Primary"].output_fn.upper_bound=beta_i+0.14')
topo.sim.schedule_command( 6499, 'topo.sim["Primary"].output_fn.lower_bound=delta_i+0.12; topo.sim["Primary"].output_fn.upper_bound=beta_i+0.17')
topo.sim.schedule_command( 7999, 'topo.sim["Primary"].output_fn.lower_bound=delta_i+0.13; topo.sim["Primary"].output_fn.upper_bound=beta_i+0.20')
topo.sim.schedule_command(19999, 'topo.sim["Primary"].output_fn.lower_bound=delta_i+0.14; topo.sim["Primary"].output_fn.upper_bound=beta_i+0.23')




# CEBHACKALERT: I'm still writing this file as I work on the comparisons



if locals().get('comparisons',False):

    # 
    topo.tests.reference.lissom_log_parser.filename_base=filename_base

    ## C++ lissom doesn't situate weights in matrix files, so slices etc have to be given
    ## Calculate here?


    ### Check initial weights
    #
    check_weights('Primary','Afferent0',(0,0),slice(1,14),slice(1,14),RN)
    check_weights('Primary','Afferent0',(12,12),slice(13,26),slice(13,26),RN)

    check_weights('Primary','LateralExcitatory',(0,0),slice(0,3),slice(0,3),BaseN)
    check_weights('Primary','LateralExcitatory',(12,12),slice(10,15),slice(10,15),BaseN)

    check_weights('Primary','LateralInhibitory',(0,0),slice(0,6),slice(0,6),BaseN)
    check_weights('Primary','LateralInhibitory',(12,12),slice(7,18),slice(7,18),BaseRN)



    ### Check initial patterns are ok on Eye0 and Primary
    #
    topo.sim.run(1)
    check_activities('Eye0',RN)
    check_activities('Primary',BaseN)

    topo.sim.run(1)
    check_activities('Eye0',RN)
    check_activities('Primary',BaseN)
    
    topo.sim.run(1)
    check_activities('Eye0',RN)
    check_activities('Primary',BaseN)
    
    topo.sim.run(1)
    check_activities('Eye0',RN)
    check_activities('Primary',BaseN)
    
    topo.sim.run(1)
    check_activities('Eye0',RN)
    check_activities('Primary',BaseN)
    
    topo.sim.run(5)
    check_activities('Eye0',RN)
    check_activities('Primary',BaseN)
    
    topo.sim.run(10)
    check_activities('Eye0',RN)
    check_activities('Primary',BaseN)



    topo.sim.run(80)

    check_weights('Primary','Afferent0',(0,0),slice(1,14),slice(1,14),RN)
    check_weights('Primary','Afferent0',(12,12),slice(13,26),slice(13,26),RN)

    check_weights('Primary','LateralExcitatory',(0,0),slice(0,3),slice(0,3),BaseN)
    check_weights('Primary','LateralExcitatory',(12,12),slice(10,15),slice(10,15),BaseN)

    check_weights('Primary','LateralInhibitory',(0,0),slice(0,6),slice(0,6),BaseN)
    check_weights('Primary','LateralInhibitory',(12,12),slice(7,18),slice(7,18),BaseRN)

    check_activities('Eye0',RN)
    check_activities('Primary',BaseN)


    topo.sim.run(900)

    check_weights('Primary','Afferent0',(0,0),slice(1,14),slice(1,14),RN)
    check_weights('Primary','Afferent0',(12,12),slice(13,26),slice(13,26),RN)

    check_weights('Primary','LateralExcitatory',(0,0),slice(0,3),slice(0,3),BaseN)
    check_weights('Primary','LateralExcitatory',(12,12),slice(10,15),slice(10,15),BaseN)

    check_weights('Primary','LateralInhibitory',(0,0),slice(0,6),slice(0,6),BaseN)
    check_weights('Primary','LateralInhibitory',(12,12),slice(7,18),slice(7,18),BaseRN)

    check_activities('Eye0',RN)
    check_activities('Primary',BaseN)


    topo.sim.run(1000)

    check_weights('Primary','Afferent0',(0,0),slice(1,14),slice(1,14),RN)
    check_weights('Primary','Afferent0',(12,12),slice(13,26),slice(13,26),RN)

    check_weights('Primary','LateralExcitatory',(0,0),slice(0,3),slice(0,3),BaseN)
    check_weights('Primary','LateralExcitatory',(12,12),slice(10,15),slice(10,15),BaseN)

    check_weights('Primary','LateralInhibitory',(0,0),slice(0,6),slice(0,6),BaseN)
    check_weights('Primary','LateralInhibitory',(12,12),slice(7,18),slice(7,18),BaseRN)

    check_activities('Eye0',RN)
    check_activities('Primary',BaseN)


    topo.sim.run(1000)

    check_weights('Primary','Afferent0',(0,0),slice(1,14),slice(1,14),RN)
    check_weights('Primary','Afferent0',(12,12),slice(13,26),slice(13,26),RN)

    check_weights('Primary','LateralExcitatory',(0,0),slice(0,3),slice(0,3),BaseN)
    check_weights('Primary','LateralExcitatory',(12,12),slice(10,15),slice(10,15),BaseN)

    check_weights('Primary','LateralInhibitory',(0,0),slice(0,6),slice(0,6),BaseN)
    check_weights('Primary','LateralInhibitory',(12,12),slice(7,18),slice(7,18),BaseRN)

    check_activities('Eye0',RN)
    check_activities('Primary',BaseN)


    topo.sim.run(1000)

    check_weights('Primary','Afferent0',(0,0),slice(1,14),slice(1,14),RN)
    check_weights('Primary','Afferent0',(12,12),slice(13,26),slice(13,26),RN)

    check_weights('Primary','LateralExcitatory',(0,0),slice(0,3),slice(0,3),BaseN)
    check_weights('Primary','LateralExcitatory',(12,12),slice(10,15),slice(10,15),BaseN)

    check_weights('Primary','LateralInhibitory',(0,0),slice(0,6),slice(0,6),BaseN)
    check_weights('Primary','LateralInhibitory',(12,12),slice(7,18),slice(7,18),BaseRN)

    check_activities('Eye0',RN)
    check_activities('Primary',BaseN)


    topo.sim.run(1000)

    check_weights('Primary','Afferent0',(0,0),slice(1,14),slice(1,14),RN)
    check_weights('Primary','Afferent0',(12,12),slice(13,26),slice(13,26),RN)

    check_weights('Primary','LateralExcitatory',(0,0),slice(0,3),slice(0,3),BaseN)
    check_weights('Primary','LateralExcitatory',(12,12),slice(10,15),slice(10,15),BaseN)

    check_weights('Primary','LateralInhibitory',(0,0),slice(0,6),slice(0,6),BaseN)
    check_weights('Primary','LateralInhibitory',(12,12),slice(7,18),slice(7,18),BaseRN)

    check_activities('Eye0',RN)
    check_activities('Primary',BaseN)


    topo.sim.run(1000)

    check_weights('Primary','Afferent0',(0,0),slice(1,14),slice(1,14),RN)
    check_weights('Primary','Afferent0',(12,12),slice(13,26),slice(13,26),RN)

    check_weights('Primary','LateralExcitatory',(0,0),slice(0,3),slice(0,3),BaseN)
    check_weights('Primary','LateralExcitatory',(12,12),slice(10,15),slice(10,15),BaseN)

    check_weights('Primary','LateralInhibitory',(0,0),slice(0,6),slice(0,6),BaseN)
    check_weights('Primary','LateralInhibitory',(12,12),slice(7,18),slice(7,18),BaseRN)

    check_activities('Eye0',RN)
    check_activities('Primary',BaseN)


    topo.sim.run(1000)

    check_weights('Primary','Afferent0',(0,0),slice(1,14),slice(1,14),RN)
    check_weights('Primary','Afferent0',(12,12),slice(13,26),slice(13,26),RN)

    check_weights('Primary','LateralExcitatory',(0,0),slice(0,3),slice(0,3),BaseN)
    check_weights('Primary','LateralExcitatory',(12,12),slice(10,15),slice(10,15),BaseN)

    check_weights('Primary','LateralInhibitory',(0,0),slice(0,6),slice(0,6),BaseN)
    check_weights('Primary','LateralInhibitory',(12,12),slice(7,18),slice(7,18),BaseRN)

    check_activities('Eye0',RN)
    check_activities('Primary',BaseN)


    topo.sim.run(1000)

    check_weights('Primary','Afferent0',(0,0),slice(1,14),slice(1,14),RN)
    check_weights('Primary','Afferent0',(12,12),slice(13,26),slice(13,26),RN)

    check_weights('Primary','LateralExcitatory',(0,0),slice(0,3),slice(0,3),BaseN)
    check_weights('Primary','LateralExcitatory',(12,12),slice(10,15),slice(10,15),BaseN)

    check_weights('Primary','LateralInhibitory',(0,0),slice(0,6),slice(0,6),BaseN)
    check_weights('Primary','LateralInhibitory',(12,12),slice(7,18),slice(7,18),BaseRN)

    check_activities('Eye0',RN)
    check_activities('Primary',BaseN)


    topo.sim.run(1000)

    check_weights('Primary','Afferent0',(0,0),slice(1,14),slice(1,14),RN)
    check_weights('Primary','Afferent0',(12,12),slice(13,26),slice(13,26),RN)

    check_weights('Primary','LateralExcitatory',(0,0),slice(0,3),slice(0,3),BaseN)
    check_weights('Primary','LateralExcitatory',(12,12),slice(10,15),slice(10,15),BaseN)

    check_weights('Primary','LateralInhibitory',(0,0),slice(0,6),slice(0,6),BaseN)
    check_weights('Primary','LateralInhibitory',(12,12),slice(7,18),slice(7,18),BaseRN)

    check_activities('Eye0',RN)
    check_activities('Primary',BaseN)


    topo.sim.run(3000)

    check_weights('Primary','Afferent0',(0,0),slice(1,14),slice(1,14),RN)
    check_weights('Primary','Afferent0',(12,12),slice(13,26),slice(13,26),RN)

    check_weights('Primary','LateralExcitatory',(0,0),slice(0,3),slice(0,3),BaseN)
    check_weights('Primary','LateralExcitatory',(12,12),slice(10,15),slice(10,15),BaseN)

    check_weights('Primary','LateralInhibitory',(0,0),slice(0,6),slice(0,6),BaseN)
    check_weights('Primary','LateralInhibitory',(12,12),slice(7,18),slice(7,18),BaseRN)

    check_activities('Eye0',RN)
    check_activities('Primary',BaseN)


    topo.sim.run(3000)

    check_weights('Primary','Afferent0',(0,0),slice(1,14),slice(1,14),RN)
    check_weights('Primary','Afferent0',(12,12),slice(13,26),slice(13,26),RN)

    check_weights('Primary','LateralExcitatory',(0,0),slice(0,3),slice(0,3),BaseN)
    check_weights('Primary','LateralExcitatory',(12,12),slice(10,15),slice(10,15),BaseN)

    check_weights('Primary','LateralInhibitory',(0,0),slice(0,6),slice(0,6),BaseN)
    check_weights('Primary','LateralInhibitory',(12,12),slice(7,18),slice(7,18),BaseRN)

    check_activities('Eye0',RN)
    check_activities('Primary',BaseN)


    topo.sim.run(5000)

    check_weights('Primary','Afferent0',(0,0),slice(1,14),slice(1,14),RN)
    check_weights('Primary','Afferent0',(12,12),slice(13,26),slice(13,26),RN)

    check_weights('Primary','LateralExcitatory',(0,0),slice(0,3),slice(0,3),BaseN)
    check_weights('Primary','LateralExcitatory',(12,12),slice(10,15),slice(10,15),BaseN)

    check_weights('Primary','LateralInhibitory',(0,0),slice(0,6),slice(0,6),BaseN)
    check_weights('Primary','LateralInhibitory',(12,12),slice(7,18),slice(7,18),BaseRN)

    check_activities('Eye0',RN)
    check_activities('Primary',BaseN)




# Command to generate lissom data for comparisons
#
#./lissom5 commandpath="/home/v1cball/public/lissom/command" display=0 or_map_topo.param -c "call set_thresholds.command" -c "ppm_weight_scale_type=PPM_WtScale_Fixed" -c "Region::ppm_weight_fixed_multiplier=1" -c 'PlotGroup::Weights::filename_format="$$$${filebase}.$$$${06iteration}.wts.$$$${current_region}.$$$${current_plot}.$$$${03current_ui}_$$$${03current_uj}"' -c "cmd::plot_unit::weight_situate=False" -c 'plot_unit save_matrices=True 0 0' -c 'plot_unit save_matrices=True 12 12' -c "step" -c 'plot filename_format=$$$${default_filename_format} save_matrices=True' -c "step" -c 'plot filename_format=$$$${default_filename_format} save_matrices=True'   -c "step" -c 'plot filename_format=$$$${default_filename_format} save_matrices=True' -c "step" -c 'plot filename_format=$$$${default_filename_format} save_matrices=True' -c "step" -c 'plot filename_format=$$$${default_filename_format} save_matrices=True' -c "training t+5" -c 'plot filename_format=$$$${default_filename_format} save_matrices=True' -c "training t+10" -c 'plot filename_format=$$$${default_filename_format} save_matrices=True' -c 'plot_unit save_matrices=True 0 0' -c 'plot_unit save_matrices=True 12 12' -c "training t+80" -c 'plot filename_format=$$$${default_filename_format} save_matrices=True' -c 'plot_unit save_matrices=True 0 0' -c 'plot_unit save_matrices=True 12 12' -c "training t+900" -c 'plot filename_format=$$$${default_filename_format} save_matrices=True' -c 'plot_unit save_matrices=True 0 0' -c 'plot_unit save_matrices=True 12 12' -c "training t+1000" -c 'plot filename_format=$$$${default_filename_format} save_matrices=True' -c 'plot_unit save_matrices=True 0 0' -c 'plot_unit save_matrices=True 12 12' -c "training t+1000" -c 'plot filename_format=$$$${default_filename_format} save_matrices=True' -c 'plot_unit save_matrices=True 0 0' -c 'plot_unit save_matrices=True 12 12' -c "training t+1000" -c 'plot filename_format=$$$${default_filename_format} save_matrices=True' -c 'plot_unit save_matrices=True 0 0' -c 'plot_unit save_matrices=True 12 12' -c "training t+1000" -c 'plot filename_format=$$$${default_filename_format} save_matrices=True' -c 'plot_unit save_matrices=True 0 0' -c 'plot_unit save_matrices=True 12 12' -c "training t+1000" -c 'plot filename_format=$$$${default_filename_format} save_matrices=True' -c 'plot_unit save_matrices=True 0 0' -c 'plot_unit save_matrices=True 12 12' -c "training t+1000" -c 'plot filename_format=$$$${default_filename_format} save_matrices=True' -c 'plot_unit save_matrices=True 0 0' -c 'plot_unit save_matrices=True 12 12' -c "training t+1000" -c 'plot filename_format=$$$${default_filename_format} save_matrices=True' -c 'plot_unit save_matrices=True 0 0' -c 'plot_unit save_matrices=True 12 12' -c "training t+1000" -c 'plot filename_format=$$$${default_filename_format} save_matrices=True' -c 'plot_unit save_matrices=True 0 0' -c 'plot_unit save_matrices=True 12 12' -c "training t+3000" -c 'plot filename_format=$$$${default_filename_format} save_matrices=True' -c 'plot_unit save_matrices=True 0 0' -c 'plot_unit save_matrices=True 12 12' -c "training t+3000" -c 'plot filename_format=$$$${default_filename_format} save_matrices=True' -c 'plot_unit save_matrices=True 0 0' -c 'plot_unit save_matrices=True 12 12' -c "training t+5000" -c 'plot filename_format=$$$${default_filename_format} save_matrices=True' -c 'plot_unit save_matrices=True 0 0' -c 'plot_unit save_matrices=True 12 12'

