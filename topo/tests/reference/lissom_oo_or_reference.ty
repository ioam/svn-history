"""
LISSOM simulation designed to match C++ LISSOM's oo_or_map_topo
simulation.

To view the comparisons, you can either use the existing data or generate
data yourself.

- Existing data
gunzip oo_or_map_topo.log.gz and the oo_or_map_topo.*.matrix.gz files
in this directory.

- Generate data
gunzip lissom5.gz and run lissom again according to the instructions
(see COMPARISONS below).


(When using gunzip, if you leave the original gz files in place cvs
will not download those original gz files again.)


Search for '**' in the output to see which results are being printed.
(If nothing is printed under a heading, it means all elements of the
array matched exactly.)


$Id$
"""
__version__='$Revision$'


# This simulation is still being worked on:
#
# - all parameters do not yet match
#
# - learning rates need to be adjusted for all the times the bounds
# change (re-counting the numbers of units).



## from topo.base.parameterizedobject import ParameterizedObject
## ParameterizedObject.print_level=300

import fixedpoint
#import pdb # debugger

from math import pi, sqrt
from fixedpoint import FixedPoint

from topo.sheets.lissom import LISSOM
from topo.sheets.generatorsheet import GeneratorSheet
from topo.projections.basic import CFProjection,SharedWeightCFProjection
from topo.responsefns.optimized import CFPRF_DotProduct_opt
import topo.patterns.basic
from topo.base.sheet import BoundingBox
from topo.base.parameterclasses import DynamicNumber
from topo.base.cf import CFSheet
from topo.base.boundingregion import BoundingBox
from topo.base.parameterclasses import Wrapper
from topo.learningfns.optimized import CFPLF_Hebbian_opt
from topo.outputfns.optimized import CFPOF_DivisiveNormalizeL1_opt
from topo.outputfns.basic import DivisiveNormalizeL1,PiecewiseLinear
from topo.responsefns.optimized import CFPRF_SharedWeightDotProduct_opt

from topo.tests.reference.lissom_log_parser import get_input_params

###########################################
# Variables to match the C++ version of LISSOM

n_aff_units = 137
n_exc_units = 97
n_inh_units = 421

### (1)
BaseN=48.0
BaseRN=24.0
BaseLN=24.0
area_scale=1.0
#num_eyes=1
rf_radius=BaseRN/4.0+0.5


inh_rad=max(2.5,BaseN/4.0-1.0)
exc_rad=max(2.5,BaseN/10.0)
min_exc_rad=max(1.0,BaseN/44+0.5)
#default_afferent_size_scale=BaseN/BaseRN
gammaexc=0.9
gammainh=0.9
delta=0.083
beta=0.633


### (2)
randomness = 0.0
#smooth_circular_radius_trim = -0.25

rf_radius_scale=5.0/rf_radius
#retina_area_scale = (BaseRN*area_scale/24.0*rf_radius_scale)*(BaseRN*area_scale/24.0*rf_radius_scale)
#inputs_pereye=max(retina_area_scale,1)
xsigma=6.0
ysigma=1.5
scale_input=1.0


# radius of LGN DoG center Gaussian
sigma_c = 0.5 

# radius of LGN DoG surround Gaussian
sigma_s = 4*sigma_c 

# radius of LGN afferent connections
r_L = 4.7*sigma_s

# buffers so sheet above has full rfs...
lgn_edge_buffer = round(rf_radius,0)
retina_edge_buffer=round(rf_radius+r_L,0)

# ...and actual numbers of neurons with the buffers
RN=round(BaseRN*area_scale+2*retina_edge_buffer,0)
LN=round(BaseLN*area_scale+2*lgn_edge_buffer,0)


### (3)
acs=6.5*6.5/rf_radius/rf_radius
ecs=19.5*19.5/exc_rad/exc_rad
ics=47.5*47.5/inh_rad/inh_rad
alpha_input=0.007*acs
alpha_exc=0.002*ecs
alpha_inh=0.00025*ics

tsettle=8

assert LN == 38
assert lgn_edge_buffer == 7
assert xsigma == 6
assert ysigma == 1.5
#assert inputs_pereye == 1
#assert round(retina_area_scale,6) == 0.591716
assert rf_radius == 6.5
assert delta == 0.083
assert beta == 0.633
#assert default_afferent_size_scale == 3
assert rf_radius == 6.5
assert inh_rad == 11
assert exc_rad == 4.8
assert area_scale == 1
assert BaseRN == 24
assert BaseN == 48
#assert num_eyes==1
assert gammaexc==0.9
assert gammainh==0.9
assert randomness == 0.0
assert round(rf_radius_scale,6)==0.769231
assert scale_input==1.0
assert acs==1
assert round(ecs,4)==16.5039
assert round(ics,4)==18.6467
assert round(alpha_input,3)==0.007
assert round(alpha_exc,7)==0.0330078
assert round(alpha_inh,8)==0.00466167
assert tsettle == 8
assert round(min_exc_rad,5) == 1.59091


###########################################
# Set parameters

# Number of decimal places for simulator time
fixedpoint.DEFAULT_PRECISION=3

# input generation params
GeneratorSheet.nominal_density = BaseRN*area_scale
GeneratorSheet.period = 1
GeneratorSheet.phase=0.05

# take the input pattern position parameters from the log file output of the equivalent c++ simulation
n_inputs,input_x,input_y,input_orientation = get_input_params(log_file="topo/tests/reference/oo_or_map_topo.log")
n_inputs-=1;input_x.next();input_y.next();input_orientation.next() # c++ lissom's first iteration is just a test

print "Number of patterns available for learning iterations:",n_inputs

gaussian_width = xsigma/BaseRN/sqrt(2.0)
gaussian_height = ysigma/BaseRN/sqrt(2.0)

input_pattern = topo.patterns.basic.Gaussian(scale=scale_input,
                                             size = 2*gaussian_height,
                                             aspect_ratio= gaussian_width/gaussian_height,
                                             x=DynamicNumber(lambda : input_x.next()/BaseLN - 0.5*LN/BaseLN),
                                             y=DynamicNumber(lambda : input_y.next()/BaseLN - 0.5*LN/BaseLN),
                                             orientation=DynamicNumber(lambda : round(2*pi*input_orientation.next()/360.0,1)))


retina_bounds = BoundingBox(radius= RN/(2.0*BaseRN*area_scale))
lgn_bounds = BoundingBox(radius=LN/(2.0*BaseLN*area_scale))
                                               
#LISSOM.tsettle=tsettle

# division done here once for convenience
min_exc_radius = min_exc_rad/BaseN

# Connection parameters
lgn_weight_bounds = BoundingBox(radius=r_L/BaseLN)
afferent_weight_bounds   = BoundingBox(radius=rf_radius/BaseRN)               # 137 units
excitatory_weight_bounds = BoundingBox(radius=exc_rad/BaseN, min_radius=min_exc_radius)  # 97 units
inhibitory_weight_bounds = BoundingBox(radius=inh_rad/BaseN)                  # 421 units

# Circular ConnectionFields
CFProjection.weights_shape = topo.patterns.basic.Disk(smoothing=0.0)
CFProjection.weights_generator = topo.patterns.basic.Constant()
CFProjection.response_fn=CFPRF_DotProduct_opt()
CFProjection.learning_fn=CFPLF_Hebbian_opt()
CFProjection.weights_output_fn=CFPOF_DivisiveNormalizeL1_opt()
SharedWeightCFProjection.response_fn=CFPRF_SharedWeightDotProduct_opt()



topo.sim['Retina'] = GeneratorSheet(nominal_bounds=retina_bounds,
                                    input_generator=input_pattern)

topo.sim['LGNOn'] = CFSheet(nominal_bounds=lgn_bounds,nominal_density=24.0,
                      output_fn=PiecewiseLinear(lower_bound=0.0,upper_bound=1.0))

topo.sim['LGNOff'] = CFSheet(nominal_bounds=lgn_bounds,nominal_density=24.0,
                      output_fn=PiecewiseLinear(lower_bound=0.0,upper_bound=1.0))

topo.sim['V1'] = LISSOM(nominal_density=48.0,
            output_fn=PiecewiseLinear(lower_bound=delta,upper_bound=beta))


# C++ LISSOM divides by pi in RadialFunction::Gaussian but not for
# Gaussian in retinalobjs (and elsewhere)
from math import pi,sqrt

centerg = topo.patterns.basic.Gaussian(
    size=2*sigma_c*sqrt(pi)/BaseRN,aspect_ratio=1,output_fn=DivisiveNormalizeL1(norm_value=2.33))

surroundg = topo.patterns.basic.Gaussian(
    size=2*sigma_s*sqrt(pi)/BaseRN,aspect_ratio=1,output_fn=DivisiveNormalizeL1(norm_value=2.33))


on_weights = topo.patterns.basic.Composite(
    generators=[centerg,surroundg],operator=Wrapper("Numeric.subtract"))

off_weights = topo.patterns.basic.Composite(
    generators=[surroundg,centerg],operator=Wrapper("Numeric.subtract"))
    
topo.sim.connect('Retina','LGNOn',delay=FixedPoint("0.05"),
          connection_type=SharedWeightCFProjection,strength=1.0,
          nominal_bounds_template=lgn_weight_bounds,
          weights_generator=on_weights)

topo.sim.connect('Retina','LGNOff',delay = FixedPoint("0.05"),
          connection_type=SharedWeightCFProjection,strength=1.0,
          nominal_bounds_template=lgn_weight_bounds,
          weights_generator=off_weights)


topo.sim.connect('LGNOn','V1',delay=FixedPoint("0.05"),
                 dest_port=('Activity','JointNormalize', 'Afferent'),
          connection_type=CFProjection,strength=1.0,name='LGNOnAfferent',
          nominal_bounds_template=afferent_weight_bounds,learning_rate=alpha_input*n_aff_units)

topo.sim.connect('LGNOff','V1',delay=FixedPoint("0.05"),
                 dest_port=('Activity','JointNormalize', 'Afferent'),
          connection_type=CFProjection,strength=1.0,name='LGNOffAfferent',
          nominal_bounds_template=afferent_weight_bounds,learning_rate=alpha_input*n_aff_units)


topo.sim.connect('V1','V1',delay=FixedPoint("0.05"),
          connection_type=CFProjection,strength=0.9,name='LateralExcitatory',
          nominal_bounds_template=excitatory_weight_bounds,learning_rate=alpha_exc*n_exc_units) 
            
topo.sim.connect('V1','V1',delay=FixedPoint("0.05"),
          connection_type=CFProjection,strength=-0.9,name='LateralInhibitory',
          nominal_bounds_template=inhibitory_weight_bounds,learning_rate=alpha_inh*n_inh_units)         

# CEBHACKALERT: this is out of date and the times should be corrected.
#
# Times are 1 less than the or_map_topo.param c++ lissom simulation
# because that one uses "hook before_input" to schedule events. So, an
# event at t=200 is executed before t=200's input pattern is
# presented. In Topographica, an event scheduled at t=0 is executed
# after time=0's input pattern is presented. So one at t=199 is
# executed before t=200's input pattern is presented, and is therefore
# equivalent to or_map_topo's event scheduled at t=200.



# note: you can't pickle this simulation unless you make variables
# like exc_rad available again.


### EXCITATORY BOUNDS CHANGES
#
topo.sim.schedule_command(199, 'topo.sim["V1"].projections()["LateralExcitatory"].change_bounds(BoundingBox(radius=0.6*exc_rad/BaseN,min_radius=min_exc_radius)); n_exc_units=37')

topo.sim.schedule_command(499, 'topo.sim["V1"].projections()["LateralExcitatory"].change_bounds(BoundingBox(radius=0.42*exc_rad/BaseN,min_radius=min_exc_radius));n_exc_units=21')


### LEARNING RATE CHANGES
#
# number of units changes with the bounds change
topo.sim.schedule_command(  199, 'topo.sim["V1"].projections()["LateralExcitatory"].learning_rate=alpha_exc*n_exc_units')

# scheduled change AND number of units changes with bounds change
topo.sim.schedule_command(  499, 'topo.sim["V1"].projections()["LateralExcitatory"].learning_rate=0.001*ecs*21*n_exc_units')

# c++ scheduled changes only
topo.sim.schedule_command(  499, 'topo.sim["V1"].projections()["LGNOnAfferent"].learning_rate=0.005*acs*n_aff_units')
topo.sim.schedule_command( 1999, 'topo.sim["V1"].projections()["LGNOnAfferent"].learning_rate=0.004*acs*n_aff_units')
topo.sim.schedule_command( 3999, 'topo.sim["V1"].projections()["LGNOnAfferent"].learning_rate=0.003*acs*n_aff_units')
topo.sim.schedule_command(19999, 'topo.sim["V1"].projections()["LGNOnAfferent"].learning_rate=0.0015*acs*n_aff_units')

topo.sim.schedule_command(  499, 'topo.sim["V1"].projections()["LGNOffAfferent"].learning_rate=0.005*acs*n_aff_units')
topo.sim.schedule_command( 1999, 'topo.sim["V1"].projections()["LGNOffAfferent"].learning_rate=0.004*acs*n_aff_units')
topo.sim.schedule_command( 3999, 'topo.sim["V1"].projections()["LGNOffAfferent"].learning_rate=0.003*acs*n_aff_units')
topo.sim.schedule_command(19999, 'topo.sim["V1"].projections()["LGNOffAfferent"].learning_rate=0.0015*acs*n_aff_units')


### V1 output function bounds changes
#
topo.sim.schedule_command(  199, 'topo.sim["V1"].output_fn.lower_bound=0.093; topo.sim["V1"].output_fn.upper_bound=0.643')
topo.sim.schedule_command(  499, 'topo.sim["V1"].output_fn.lower_bound=0.103; topo.sim["V1"].output_fn.upper_bound=0.653')
topo.sim.schedule_command(  999, 'topo.sim["V1"].output_fn.lower_bound=0.133; topo.sim["V1"].output_fn.upper_bound=0.663')
topo.sim.schedule_command( 1999, 'topo.sim["V1"].output_fn.lower_bound=0.163; topo.sim["V1"].output_fn.upper_bound=0.683')
topo.sim.schedule_command( 2999, 'topo.sim["V1"].output_fn.lower_bound=0.183; topo.sim["V1"].output_fn.upper_bound=0.713')
topo.sim.schedule_command( 3999, 'topo.sim["V1"].output_fn.lower_bound=0.183; topo.sim["V1"].output_fn.upper_bound=0.743')
topo.sim.schedule_command( 4999, 'topo.sim["V1"].output_fn.lower_bound=0.193; topo.sim["V1"].output_fn.upper_bound=0.773')
topo.sim.schedule_command( 6499, 'topo.sim["V1"].output_fn.lower_bound=0.203; topo.sim["V1"].output_fn.upper_bound=0.803')
topo.sim.schedule_command( 7999, 'topo.sim["V1"].output_fn.lower_bound=0.213; topo.sim["V1"].output_fn.upper_bound=0.833')
topo.sim.schedule_command(19999, 'topo.sim["V1"].output_fn.lower_bound=0.223; topo.sim["V1"].output_fn.upper_bound=0.863')


### PERFORMANCE PROFILING
#
# Example 1
#import hotshot,hotshot.stats
#prof = hotshot.Profile("abc")
#prof.runctx('s.run(10000)',globals(),locals())
#prof.close()
#
#p = hotshot.stats.load("abc")
#p.strip_dirs().sort_stats('cumulative','time').print_stats()
#
# Example 2
#import profile,pstats
#profile.runctx('s.run(10000)',globals(),locals(),"abc")
#p = pstats.Stats('abc')
#p.strip_dirs().sort_stats('cumulative').print_stats()




### COMPARISONS
#
# command used to generate c++ lissom data:
# ./lissom5 commandpath="../../../../lissom_old/command/" display=0 oo_or_map_topo.param -c "call set_thresholds.command" -c "ppm_weight_scale_type=PPM_WtScale_Fixed" -c "Region::ppm_weight_fixed_multiplier=1" -c 'PlotGroup::Weights::filename_format="$$$${filebase}.$$$${06iteration}.wts.$$$${current_region}.$$$${current_plot}.$$$${03current_ui}_$$$${03current_uj}"' -c "cmd::plot_unit::weight_situate=False" -c "plot_unit region=Ganglia00 save_matrices=True 0 0" -c 'plot_unit save_matrices=True 0 0' -c 'plot_unit save_matrices=True 23 23' -c "step" -c 'plot filename_format=$$$${default_filename_format} save_matrices=True'


topo.sim.run(1)

from topo.tests.reference.lissom_log_parser import get_input_params, get_matrix, compare_elements

# no. of decimal places for matching activity and weight values
act_dp = 5
wt_dp = 5

print "** Compare C++ LISSOM and Topograhica activity values in the Retina/Eye00:"
c_eye00_act = get_matrix("topo/tests/reference/oo_or_map_topo.000001p000.Eye0_Activity.matrix",(RN,RN))
compare_elements(topo.sim['Retina'].activity,c_eye00_act,act_dp,"Retina")

print "** Compare C++ LISSOM and Topograhica activity values in LGN ON:"
c_ganglia00_act = get_matrix("topo/tests/reference/oo_or_map_topo.000001p000.Ganglia00_Activity.matrix",(LN,LN))
compare_elements(topo.sim['LGNOn'].activity,c_ganglia00_act,act_dp,"LGNOn")

#matrixplot(topo.sim['LGNOn'].activity,title="Topo LGNOn activity"); matrixplot(c_ganglia00_act,title="c++ Ganglia00 activity")

print "** Compare C++ LISSOM and Topograhica activity values in LGN OFF:"
c_ganglia01_act = get_matrix("topo/tests/reference/oo_or_map_topo.000001p000.Ganglia01_Activity.matrix",(LN,LN))
compare_elements(topo.sim['LGNOff'].activity,c_ganglia00_act,act_dp,"LGNOff")


print "** Compare C++ LISSOM and Topograhica weights:"

# CEBHACKALERT: the shared weight is similar, but does not match exactly.
# Using one gaussian (rather than DoG), it doesn't match exactly either.
# Using a solid disk, though (e.g. see retina_lgn_match.ty), the match is very close.

print "...** Retina-LGN..."
i,j=0,0
topo_LGNOn_weights = topo.sim['LGNOn'].in_connections[0].cf(i,j).weights
c_Ganglia00_afferent = get_matrix('topo/tests/reference/oo_or_map_topo.000000.wts.Ganglia00.Afferent0.000_000.matrix',(RN,RN)) 
c_Ganglia00_afferent = c_Ganglia00_afferent[0:19,0:19] # c++ lissom doesn't situate weights

compare_elements(topo_LGNOn_weights,c_Ganglia00_afferent,wt_dp,"LGNOn weights")

matrixplot(topo_LGNOn_weights,title="(A) Topo LGNOn afferents"); matrixplot(c_Ganglia00_afferent,title="(A) c++ Ganglia00 Afferents")

#matrixplot(topo_LGNOn_weights-c_Ganglia00_afferent,"difference between topo lgnon afferents and c++ ganglia00 afferents")


print "...** LGNOn-V1 unit 0 0..."
i,j=0,0
topo_LGNOnToV1_0_0 = topo.sim['V1'].in_connections[0].cf(i,j).weights
c_Primary_Afferent00_0_0 = get_matrix('topo/tests/reference/oo_or_map_topo.000000.wts.Primary.Afferent00.000_000.matrix',(LN,LN)) 
c_Primary_Afferent00_0_0 = c_Primary_Afferent00_0_0[1:14,1:14] # c++ lissom doesn't situate weights

compare_elements(topo_LGNOnToV1_0_0,c_Primary_Afferent00_0_0,wt_dp,"LGNOn weights")

matrixplot(topo_LGNOnToV1_0_0,title="(B) Topo LGNOnToV1 0 0"); matrixplot(c_Primary_Afferent00_0_0,title="(B) c++ Primary Afferent00 0 0")

print "...** LGNOn-V1 unit 23 23..."
i,j=23,23
topo_LGNOnToV1_23_23 = topo.sim['V1'].in_connections[0].cf(i,j).weights
c_Primary_Afferent00_23_23 = get_matrix('topo/tests/reference/oo_or_map_topo.000000.wts.Primary.Afferent00.023_023.matrix',(LN,LN)) 
c_Primary_Afferent00_23_23 = c_Primary_Afferent00_23_23[12:25,12:25] # c++ lissom doesn't situate weights

compare_elements(topo_LGNOnToV1_23_23,c_Primary_Afferent00_23_23,wt_dp,"LGNOn weights")

matrixplot(topo_LGNOnToV1_23_23,title="(C) Topo LGNOnToV1 23 23"); matrixplot(c_Primary_Afferent00_23_23,title="(C) c++ Primary Afferent00 23 23")



#oo_or_map_topo.000000.wts.Primary.Afferent01.000_000.matrix


print "...** V1-V1 excitatory unit 0 0... "
i,j=0,0
topo_LatExc_weights = topo.sim['V1'].in_connections[2].cf(i,j).weights
c_Primary_LatExc = get_matrix('topo/tests/reference/oo_or_map_topo.000000.wts.Primary.LateralExcitatory.000_000.matrix',(BaseN,BaseN)) 
c_Primary_LatExc = c_Primary_LatExc[0:5,0:5] # c++ lissom doesn't situate weights

compare_elements(topo_LatExc_weights,c_Primary_LatExc,wt_dp,"LateralExcitatory")

matrixplot(topo_LatExc_weights,title="(D) Topo V1 LatExc 0,0"); matrixplot(c_Primary_LatExc,title="(D) c++ Primary LatExc 0,0")


print "...** V1-V1 inhibitory unit 0 0..."
i,j=0,0
topo_LatInh_weights = topo.sim['V1'].in_connections[3].cf(i,j).weights
c_Primary_LatInh = get_matrix('topo/tests/reference/oo_or_map_topo.000000.wts.Primary.LateralInhibitory.000_000.matrix',(BaseN,BaseN)) 
c_Primary_LatInh = c_Primary_LatInh[0:12,0:12] # c++ lissom doesn't situate weights

compare_elements(topo_LatInh_weights,c_Primary_LatInh,wt_dp,"LateralInhibitory")

matrixplot(topo_LatInh_weights,title="(F) Topo V1 LatInh 0,0"); matrixplot(c_Primary_LatInh,title="(F) c++ Primary LatInh 0,0")


