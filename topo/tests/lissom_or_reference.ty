"""
A LISSOM-based orientation map, designed to match the equivalent
C++ simulation.

This file is much more complex than necessary, because it is set up to
match the C++ version of the LISSOM simulator as closely as possible.
Most of the variables below are just temporary ones designed to match
those in the other simulator. In addition, some of the techniques for
setting up the network are out of date. Please do not use this file as
an example of how to use Topographica.



$Id$
"""
__version__='$Revision$'


# (needs updating to use schedule_command)

# To do:
# - check all relevant scheduled events are
# here.


# Current matching status:
# - With square receptive fields, matches c++ lissom
# after 100 iterations to the same precision that the
# retinal input activities match between the two (about
# 6 decimal places for activity values). Haven't checked
# after more because learning rates not updated yet (used
# correct learning rates for the 100-iterations test).
# - With circular receptive fields, sum over activity
# after 201 learning iteration matches to 5-6 dp. Haven't
# checked any further yet, but unless the scheduled actions
# contain a mistake, it should finish up matching to this
# accuracy after 20000 iterations (waiting to see...).



#import pdb # debugger
import random
import fixedpoint


from math import pi, sqrt

from topo.base.parameterclasses import DynamicNumber
from topo.base.boundingregion import BoundingBox
from topo.sheets.lissom import LISSOM
from topo.sheets.generatorsheet import GeneratorSheet
from topo.projections.basic import CFProjection
from topo.outputfns.basic import PiecewiseLinear
from topo.responsefns.optimized import CFPDotProduct_opt1
from topo.learningfns.optimized import CFPHebbian_opt1
from topo.outputfns.optimized import CFPDivisiveSumNormalize_opt1
import topo.patterns.basic

from topo.tests.lissom_log_parser import get_input_params,get_matrix


# Topographica learning rate is density-independent so to compare
# with C++ lissom it's necessary to know the number of units.
# Be aware that you'll need to change these later in the script
# if the bounds are alterered. (Could be automated)
n_aff_units=137
n_exc_units=177
n_inh_units=973



###########################################
# Variables to match the C++ version of LISSOM

### (1)
BaseN=72.0
BaseRN=24.0
area_scale=1.0
#num_eyes=1
rf_radius=BaseRN/4.0+0.5
inh_rad=max(2.5,BaseN/4.0-1.0)+0.5
exc_rad=max(2.5,BaseN/10.0)+0.3
min_exc_rad=max(1.0,BaseN/44+0.5)

#default_afferent_size_scale=BaseN/BaseRN
gammaexc=0.9
gammainh=0.9
delta=0.1
beta=0.65


### (2)
randomness = 0.0
#smooth_circular_radius_trim = -0.25

rf_radius_scale=5.0/rf_radius
#retina_area_scale = (BaseRN*area_scale/24.0*rf_radius_scale)*(BaseRN*area_scale/24.0*rf_radius_scale)
#inputs_pereye=max(retina_area_scale,1)
xsigma=6.0
ysigma=1.5
scale_input=1.0

retina_edge_buffer=round((rf_radius+(randomness*BaseRN*area_scale/2.0)),0)
RN=round(BaseRN*area_scale+2*retina_edge_buffer,0)


### (3)
acs=6.5*6.5/rf_radius/rf_radius
ecs=19.5*19.5/exc_rad/exc_rad
ics=47.5*47.5/inh_rad/inh_rad
alpha_input=0.007*n_aff_units*acs
alpha_exc=0.002*ecs*n_exc_units
alpha_inh=0.00025*ics*n_inh_units

tsettle=8


assert RN == 38
assert retina_edge_buffer == 7
assert xsigma == 6
assert ysigma == 1.5
#assert inputs_pereye == 1
#assert round(retina_area_scale,6) == 0.591716
assert rf_radius == 6.5
assert delta == 0.1
assert beta == 0.65
#assert default_afferent_size_scale == 3
assert rf_radius == 6.5
assert inh_rad == 17.5
assert exc_rad == 7.5
assert round(min_exc_rad,5) == 2.13636
assert area_scale == 1
assert BaseRN == 24.
assert BaseN == 72.
#assert num_eyes==1
assert gammaexc==0.9
assert gammainh==0.9
assert randomness == 0.0
assert round(rf_radius_scale,6)==0.769231
assert scale_input==1.0
assert acs==1
assert round(ecs,5)==6.76000
assert round(ics,5)==7.36735
assert round(alpha_input/n_aff_units,3)==0.007
assert round(alpha_exc/n_exc_units,7)==0.0135200
assert round(alpha_inh/n_inh_units,8)==0.00184184
assert tsettle == 8

# Number of decimal places for simulator time
fixedpoint.DEFAULT_PRECISION=3
random.seed(1234)

# input generation params
GeneratorSheet.density = BaseRN*area_scale
GeneratorSheet.period = 1

# take the input pattern position parameters from the log file output
# of the equivalent c++ simulation
n_inputs,input_x,input_y,input_orientation = get_input_params(
    log_file="topo/tests/or_map_topo.log")

# c++ lissom's first iteration is just a test...
n_inputs-=1;input_x.next();input_y.next();input_orientation.next() 

print "Number of patterns available for learning iterations:",n_inputs

# c++ positions and angle need to be converted to match Topographica
topo.patterns.basic.Gaussian.x = DynamicNumber(
    lambda : input_x.next()/BaseRN - 0.5*RN/BaseRN)
topo.patterns.basic.Gaussian.y = DynamicNumber(
    lambda : input_y.next()/BaseRN - 0.5*RN/BaseRN)
topo.patterns.basic.Gaussian.orientation = DynamicNumber(
    lambda : round(2*pi*input_orientation.next()/360.0,1))

topo.patterns.basic.Gaussian.scale = scale_input

gaussian_width = xsigma/BaseRN/sqrt(2.0)
gaussian_height = ysigma/BaseRN/sqrt(2.0)
input_bounds = BoundingBox(radius=RN/(BaseRN*area_scale)/2.0)

topo.patterns.basic.Gaussian.size = 2*gaussian_height
topo.patterns.basic.Gaussian.aspect_ratio = gaussian_width/gaussian_height
topo.patterns.basic.Gaussian.bounds = input_bounds
                                               

# LISSOM parameters
LISSOM.output_fn = PiecewiseLinear(lower_bound=delta,upper_bound=beta)
LISSOM.density = BaseN
#LISSOM.tsettle=tsettle

# Connection parameters
afferent_weight_bounds = BoundingBox(radius=rf_radius/BaseRN)
excitatory_weight_bounds = BoundingBox(radius=exc_rad/BaseN,min_radius=min_exc_rad/BaseN)
inhibitory_weight_bounds = BoundingBox(radius=inh_rad/BaseN)

CFProjection.weights_shape = topo.patterns.basic.Disk(smoothing=0.0)
CFProjection.weights_generator = topo.patterns.basic.Constant()
CFProjection.response_fn=CFPDotProduct_opt1()
CFProjection.learning_fn=CFPHebbian_opt1()
CFProjection.weights_output_fn=CFPDivisiveSumNormalize_opt1()


topo.sim['Retina'] = GeneratorSheet(input_generator=topo.patterns.basic.Gaussian(),
                                    bounds = input_bounds)
topo.sim['V1'] = LISSOM()

topo.sim.connect('Retina','V1', delay = fixedpoint.FixedPoint("0.05"),
          connection_type=CFProjection,strength = 1.0, name='Afferent0',
          user_weights_bounds = afferent_weight_bounds, learning_rate=alpha_input)

topo.sim.connect('V1','V1', delay = fixedpoint.FixedPoint("0.05"), dest_port="exc",
          connection_type=CFProjection,strength=gammaexc,
          name='LateralExcitatory',
          user_weights_bounds = excitatory_weight_bounds, learning_rate=alpha_exc)

topo.sim.connect('V1','V1', delay = fixedpoint.FixedPoint("0.05"), dest_port="inh",
          connection_type=CFProjection,strength=-gammainh,
          name='LateralInhibitory',
          user_weights_bounds = inhibitory_weight_bounds, learning_rate=alpha_inh)
        
# CEBHACKALERT: this isn't the right way to do it, but it
# should be ok for our matching purposes...
# Times are 1 less than the or_map_topo.param c++ lissom simulation
# because that one uses "hook before_input" to schedule events. So, an
# event at t=200 is executed before t=200's input pattern is
# presented. In Topographica, an event scheduled at t=0 is executed
# after time=0's input pattern is presented. So one at t=199 is
# executed before t=200's input pattern is presented, and is therefore
# equivalent to or_map_topo's event scheduled at t=200.

topo.sim.schedule_command(199, 'topo.sim["V1"].projections()["LateralExcitatory"].change_bounds(BoundingBox(radius=exc_rad*0.6/BaseN,min_radius=min_exc_rad/BaseN)); n_exc_units=69')

topo.sim.schedule_command(499, 'topo.sim["V1"].projections()["LateralExcitatory"].change_bounds(BoundingBox(radius=exc_rad*0.42/BaseN,min_radius=min_exc_rad/BaseN)); n_exc_units=29')

topo.sim.schedule_command(999,'topo.sim["V1"].projections()["LateralExcitatory"].change_bounds(BoundingBox(radius=exc_rad*0.336/BaseN,min_radius=min_exc_rad/BaseN)); n_exc_units=21')

#topo.sim.schedule_command(1999,'topo.sim["V1"].projections()["LateralExcitatory"].change_bounds(BoundingBox(radius=2.0/BaseN,min_radius=min_exc_rad/BaseN)); n_exc_units=9')

## CEBHACKALERT: investigate - last bounds change doesn't happen in Topographica
## Topographica> topo.sim['V1'].in_connections[1].weights_bounds.lbrt()
## (-0.02777777777777779, -0.04166666666666663, 0.04166666666666663, 0.02777777777777779)
## Topographica> BoundingBox(radius=2.0/BaseN).lbrt()
## (-0.027777777777777776, -0.027777777777777776, 0.027777777777777776, 0.027777777777777776)

topo.sim.schedule_command(  199,'topo.sim["V1"].projections()["LateralExcitatory"].learning_rate=0.002*ecs*n_exc_units')
topo.sim.schedule_command(  499,'topo.sim["V1"].projections()["LateralExcitatory"].learning_rate=0.001*ecs*n_exc_units')

topo.sim.schedule_command(  499,'topo.sim["V1"].projections()["Afferent0"].learning_rate=0.005*acs*n_aff_units')
topo.sim.schedule_command( 1999,'topo.sim["V1"].projections()["Afferent0"].learning_rate=0.004*acs*n_aff_units')
topo.sim.schedule_command( 3999,'topo.sim["V1"].projections()["Afferent0"].learning_rate=0.003*acs*n_aff_units')
topo.sim.schedule_command(19999,'topo.sim["V1"].projections()["Afferent0"].learning_rate=0.0015*acs*n_aff_units')


topo.sim.schedule_command(  199, 'topo.sim["V1"].output_fn.lower_bound=0.11; topo.sim["V1"].output_fn.upper_bound=0.66')
topo.sim.schedule_command(  499, 'topo.sim["V1"].output_fn.lower_bound=0.12; topo.sim["V1"].output_fn.upper_bound=0.67')
topo.sim.schedule_command(  999, 'topo.sim["V1"].output_fn.lower_bound=0.15; topo.sim["V1"].output_fn.upper_bound=0.68')
topo.sim.schedule_command( 1999, 'topo.sim["V1"].output_fn.lower_bound=0.18; topo.sim["V1"].output_fn.upper_bound=0.70')
topo.sim.schedule_command( 2999, 'topo.sim["V1"].output_fn.lower_bound=0.20; topo.sim["V1"].output_fn.upper_bound=0.73')
topo.sim.schedule_command( 3999, 'topo.sim["V1"].output_fn.lower_bound=0.20; topo.sim["V1"].output_fn.upper_bound=0.76')
topo.sim.schedule_command( 4999, 'topo.sim["V1"].output_fn.lower_bound=0.21; topo.sim["V1"].output_fn.upper_bound=0.79')
topo.sim.schedule_command( 6499, 'topo.sim["V1"].output_fn.lower_bound=0.22; topo.sim["V1"].output_fn.upper_bound=0.82')
topo.sim.schedule_command( 7999, 'topo.sim["V1"].output_fn.lower_bound=0.23; topo.sim["V1"].output_fn.upper_bound=0.85')
topo.sim.schedule_command(19999, 'topo.sim["V1"].output_fn.lower_bound=0.24; topo.sim["V1"].output_fn.upper_bound=0.88')





# CEBHACKALERT: actual tests commented out.

def compare_elements(topo_matrix,lissom_matrix,dp,topo_matrix_name):
    """
    Go through the two matrices element-by-element and check for match to the specified
    number of decimal places (dp).
    """
    r,c = topo_matrix.shape
    for i in range(r):
        for j in range(c):
            t_value = round(topo_matrix[i,j],dp)
            l_value = round(lissom_matrix[i][j],dp)
            # CEBHACKALERT: will become some kind of assert
            if t_value != l_value:
                print "\n" + topo_matrix_name + " element ("+str(i)+","+str(j)+") didn't match to " + str(dp) + " decimal places.\nTopographica value="+str(t_value)+", C++ LISSOM value="+str(l_value)

    
## # CEBHACKALERT: will check values at different iterations (including after change_bounds() etc).
## # Also will be putting data files in a reference/ subdirectory
## s.run(1)

## # compare C++ LISSOM and Topogrpahica activity values in the Retina and V1
## c_retina_act = get_matrix("topo/tests/or_map_topo.000001p000.Eye0_Activity.matrix",(RN,RN))
## c_v1_act = get_matrix("topo/tests/or_map_topo.000001p000.Primary_Activity.matrix",(BaseN,BaseN))
## compare_elements(Retina.activity,c_retina_act,6,Retina.name)
## compare_elements(V1.activity,c_v1_act,5,V1.name)


## # compare weights 
## unit_i,unit_j = 24,70

## topo_aff_weights = V1.in_connections[0].cfs[unit_i][unit_j].weights
## topo_latexc_weights = V1.in_connections[1].cfs[unit_i][unit_j].weights
## topo_latinh_weights = V1.in_connections[2].cfs[unit_i][unit_j].weights

## # CEBHACKALERT: turning off situate in c++ lissom appears to make the weight plot unsituated but
## # leaves the matrix output situated! So I take the right slice. I will automate this in the
## # get_matrix() function (unless the C could be changed easily?). Then almost all these lines will go.
## import Numeric
## c_aff_weights = get_matrix("topo/tests/or_map_topo.000001.wts.Primary.Afferent0.0"+str(unit_i)+"_0"+str(unit_j)+".matrix",(RN,RN)) 
## c_aff_weights = Numeric.array(c_aff_weights)
## c_aff_weights = c_aff_weights[7:18,22:32]
## assert c_aff_weights.shape==topo_aff_weights.shape
## c_aff_weights = c_aff_weights.tolist()

## c_latexc_weights = get_matrix("topo/tests/or_map_topo.000001.wts.Primary.LateralExcitatory.0"+str(unit_i)+"_0"+str(unit_j)+".matrix",(BaseN,BaseN)) 
## c_latexc_weights = Numeric.array(c_latexc_weights)
## c_latexc_weights = c_latexc_weights[17:31,63:71]
## assert c_latexc_weights.shape==topo_latexc_weights.shape
## c_latexc_weights = c_latexc_weights.tolist()
## # end CEBHACKALERT

## compare_elements(topo_aff_weights,c_aff_weights,7,"V1 afferent weights")
## compare_elements(topo_latexc_weights,c_latexc_weights,7,"V1 lateral excitatory weights")




# Performance profiling
#
# Example 1
#import hotshot,hotshot.stats
#prof = hotshot.Profile("abc")
#prof.runctx('s.run(10000)',globals(),locals())
#prof.close()
#
#p = hotshot.stats.load("abc")
#p.strip_dirs().sort_stats('cumulative','time').print_stats()
#
# Example 2
#import profile,pstats
#profile.runctx('s.run(10000)',globals(),locals(),"abc")
#p = pstats.Stats('abc')
#p.strip_dirs().sort_stats('cumulative').print_stats()
