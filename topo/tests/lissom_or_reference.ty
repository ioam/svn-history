"""
Example of a LISSOM-based orientation map.

This file is much more complex than necessary, because it is set up to
match the C++ version of the LISSOM simulator as closely as possible.
Most of the variables below are just temporary variables designed to
match those in the other simulator.  Eventually, this file will be
simplified to have only the variables needed for Topographica.

$Id$
"""
__version__='$Revision$'


# CEBHACKALERT: not yet tested to see if it matches C++ LISSOM.

import random
import fixedpoint
#import pdb # debugger

from math import pi, sqrt
from itertools import chain
from fixedpoint import FixedPoint

from topo.sheets.lissom import LISSOM
from topo.sheets.generatorsheet import GeneratorSheet
from topo.projections.basic import CFProjection
from topo.responsefns.optimized import CFDotProduct
import topo.patterns.basic
from topo.base.sheet import BoundingBox
from topo.base.parameter import DynamicNumber
from topo.learningfns.optimized import DivisiveHebbian
from topo.patterns import PatternGeneratorParameter
import topo.tests.lissom_log_parser

###########################################
# Temporary variables designed to match the C++ version of LISSOM

BaseN=72.0
BaseRN=24.0
area_scale=1.0
num_eyes=1
rf_radius=BaseRN/5.0+0.5
inh_rad=max(2.0,(BaseN/4.0-1.5)+0.5)
exc_rad=max(2.0,(BaseN/10.0-0.5)+0.5)
default_afferent_size_scale=BaseN/BaseRN
gammaexc=0.9
gammainh=0.9
#min_exc_rad=max(1,BaseN/44+0.5)

rf_radius_scale=5.0/rf_radius
#retina_area_scale=(BaseRN*area_scale/24.0*rf_radius_scale)*(BaseRN*area_scale/24.0*rf_radius_scale)
#inputs_pereye=max(retina_area_scale,1)
#uncorrelation=0.0 
xsigma=6.0
ysigma=1.5

scale_input=1.0

retina_edge_buffer=rf_radius-1 # JABALERT: Need to check this calculation.
RN=float(int(BaseRN*area_scale+2*retina_edge_buffer))
RN=32.0 #CEBHACKALERT: the calculation above gives this but just in case...
acs=6.5*6.5/rf_radius/rf_radius
ecs=19.5*19.5/exc_rad/exc_rad
ics=47.5*47.5/inh_rad/inh_rad

alpha_input=0.007*acs
alpha_exc=0.002*ecs
alpha_inh=0.00025*ics


###########################################
# Set parameters

# Number of decimal places for simulator time
fixedpoint.DEFAULT_PRECISION=3
random.seed(1234)

# input generation params
GeneratorSheet.density = BaseRN*area_scale
GeneratorSheet.period = 1

# take the input pattern position parameters from the log file output of the equivalent c++ simulation
n_inputs,input_x,input_y,input_orientation = topo.tests.lissom_log_parser.get_input_params(log_file="topo/tests/or_map_topo.log")
n_inputs-=1;input_x.next();input_y.next();input_orientation.next() # c++ lissom's first iteration is just a test

print "Number of patterns available for learning iterations:",n_inputs
topo.patterns.basic.Gaussian.x = DynamicNumber(lambda : input_x.next()/24.0 - 16.0/24.0)
topo.patterns.basic.Gaussian.y = DynamicNumber(lambda : input_y.next()/24.0 - 16.0/24.0)
topo.patterns.basic.Gaussian.orientation = DynamicNumber(lambda : round(2*pi*input_orientation.next()/360.0,1))

topo.patterns.basic.Gaussian.scale = scale_input

gaussian_width = xsigma/BaseRN/sqrt(2.0)
gaussian_height = ysigma/BaseRN/sqrt(2.0)
topo.patterns.basic.Gaussian.size = 2*gaussian_height
topo.patterns.basic.Gaussian.aspect_ratio = gaussian_width/gaussian_height
input_bounds = BoundingBox(points=((-RN/(BaseRN*area_scale)/2.0,-RN/(BaseRN*area_scale)/2.0),
                                   ( RN/(BaseRN*area_scale)/2.0, RN/(BaseRN*area_scale)/2.0)))
topo.patterns.basic.Gaussian.bounds = input_bounds
                                               

# LISSOM parameters
LISSOM.density = BaseN

# Connection parameters
afferent_weight_bounds   = BoundingBox(points=((-rf_radius/BaseRN,-rf_radius/BaseRN),(rf_radius/BaseRN,rf_radius/BaseRN)))
excitatory_weight_bounds = BoundingBox(points=((-exc_rad/BaseN,-exc_rad/BaseN),(exc_rad/BaseN,exc_rad/BaseN)))
inhibitory_weight_bounds = BoundingBox(points=((-inh_rad/BaseN,-inh_rad/BaseN),(inh_rad/BaseN,inh_rad/BaseN)))

# Circular ConnectionFields
CFProjection.weights_shape = topo.patterns.basic.Disk(smoothing=0.0)

# Specify weight initialization
CFProjection.weights_generator = topo.patterns.basic.Constant()

# Specify the response function
# inlinec.optimized should make this unnecessary.
CFProjection.response_fn=CFDotProduct()

# Specify learning function
CFProjection.learning_fn=DivisiveHebbian()

###########################################
# build simulation

s = topo.base.simulator.Simulator()

GeneratorSheet.bounds = input_bounds
Retina = GeneratorSheet(input_generator=topo.patterns.basic.Gaussian(),
                        name='Retina')
V1 = LISSOM(name='V1')

s.connect(Retina,V1, delay = FixedPoint("0.05"),
          connection_type=CFProjection,
          connection_params = dict(strength = 1.0, name='Afferent0',
                                   weights_bounds = afferent_weight_bounds, learning_rate=alpha_input))


s.connect(V1,V1, delay = FixedPoint("0.05"), dest_port="exc",
          connection_type=CFProjection,
          connection_params = dict(strength = gammaexc, name='LateralExcitatory',
                                   weights_bounds = excitatory_weight_bounds, learning_rate=alpha_exc))

s.connect(V1,V1, delay = FixedPoint("0.05"), dest_port="inh",
          connection_type=CFProjection,
          connection_params = dict(strength = -gammainh, name='LateralInhibitory',
                                   weights_bounds = inhibitory_weight_bounds, learning_rate=alpha_inh))
        

# CEBHACKALERT: clarify why times have been decremented by 1

s.schedule_action(199, V1.projections()['LateralExcitatory'].change_bounds, BoundingBox(points=((-exc_rad*0.6/BaseN,-exc_rad*0.6/BaseN),(exc_rad*0.6/BaseN,exc_rad*0.6/BaseN))))

s.schedule_action(499, V1.projections()['LateralExcitatory'].change_bounds, BoundingBox(points=((-exc_rad*0.42/BaseN,-exc_rad*0.42/BaseN),(exc_rad*0.42/BaseN,exc_rad*0.42/BaseN))))

s.schedule_action(999,V1.projections()['LateralExcitatory'].change_bounds, BoundingBox(points=((-exc_rad*0.336/BaseN,-exc_rad*0.336/BaseN),(exc_rad*0.336/BaseN,exc_rad*0.336/BaseN))))

s.schedule_action(1999,V1.projections()['LateralExcitatory'].change_bounds, BoundingBox(points=((-2.0/BaseN,-2.0/BaseN),(2.0/BaseN,2.0/BaseN))))


# Schedule action requires a function, so we create a temporary one
def set_learning_rate(projection_name, rate):
    """Set the learning rate on the named projection of V1."""
    V1.projections()[projection_name].learning_rate=rate


s.schedule_action(  499, set_learning_rate, "LateralExcitatory", 0.001*ecs)
s.schedule_action(  499, set_learning_rate, "Afferent0", 0.005*acs)
s.schedule_action( 1999, set_learning_rate, "Afferent0", 0.004*acs)
s.schedule_action( 3999, set_learning_rate, "Afferent0", 0.003*acs)
s.schedule_action(19999, set_learning_rate, "Afferent0", 0.0015*acs)


def set_deltabeta(x,y):
    """Set the threshold function limits on V1."""
    V1.output_fn.lower_bound=x
    V1.output_fn.upper_bound=y

s.schedule_action(  199, set_deltabeta, 0.11, 0.66)
s.schedule_action(  499, set_deltabeta, 0.12, 0.67)
s.schedule_action(  999, set_deltabeta, 0.15, 0.68)
s.schedule_action( 1999, set_deltabeta, 0.18, 0.70)
s.schedule_action( 2999, set_deltabeta, 0.20, 0.73)
s.schedule_action( 3999, set_deltabeta, 0.20, 0.76)
s.schedule_action( 4999, set_deltabeta, 0.21, 0.79)
s.schedule_action( 6499, set_deltabeta, 0.22, 0.82)
s.schedule_action( 7999, set_deltabeta, 0.23, 0.85)
s.schedule_action(19999, set_deltabeta, 0.24, 0.88)


# CEBHACKALERT: actual tests commented out.

def compare_elements(topo_matrix,lissom_matrix,dp,topo_matrix_name):
    """
    Go through the two matrices element-by-element and check for match to the specified
    number of decimal places (dp).
    """
    r,c = topo_matrix.shape
    for i in range(r):
        for j in range(c):
            t_value = round(topo_matrix[i,j],dp)
            l_value = round(lissom_matrix[i][j],dp)
            # CEBHACKALERT: will become some kind of assert
            if t_value != l_value:
                print "\n" + topo_matrix_name + " element ("+str(i)+","+str(j)+") didn't match to " + str(dp) + " decimal places.\nTopographica value="+str(t_value)+", C++ LISSOM value="+str(l_value)

    
## # CEBHACKALERT: will check values at different iterations (including after change_bounds() etc).
## # Also will be putting data files in a reference/ subdirectory
## s.run(1)

## # compare C++ LISSOM and Topogrpahica activity values in the Retina and V1
## c_retina_act = topo.tests.lissom_log_parser.get_matrix("topo/tests/or_map_topo.000001p000.Eye0_Activity.matrix",(RN,RN))
## c_v1_act = topo.tests.lissom_log_parser.get_matrix("topo/tests/or_map_topo.000001p000.Primary_Activity.matrix",(BaseN,BaseN))
## compare_elements(Retina.activity,c_retina_act,6,Retina.name)
## compare_elements(V1.activity,c_v1_act,5,V1.name)


## # compare weights 
## unit_i,unit_j = 24,70

## topo_aff_weights = V1.in_connections[0].cfs[unit_i][unit_j].weights
## topo_latexc_weights = V1.in_connections[1].cfs[unit_i][unit_j].weights
## topo_latinh_weights = V1.in_connections[2].cfs[unit_i][unit_j].weights

## # CEBHACKALERT: turning off situate in c++ lissom appears to make the weight plot unsituated but
## # leaves the matrix output situated! So I take the right slice. I will automate this in the
## # get_matrix() function (unless the C could be changed easily?). Then almost all these lines will go.
## import Numeric
## c_aff_weights = topo.tests.lissom_log_parser.get_matrix("topo/tests/or_map_topo.000001.wts.Primary.Afferent0.0"+str(unit_i)+"_0"+str(unit_j)+".matrix",(RN,RN)) 
## c_aff_weights = Numeric.array(c_aff_weights)
## c_aff_weights = c_aff_weights[7:18,22:32]
## assert c_aff_weights.shape==topo_aff_weights.shape
## c_aff_weights = c_aff_weights.tolist()

## c_latexc_weights = topo.tests.lissom_log_parser.get_matrix("topo/tests/or_map_topo.000001.wts.Primary.LateralExcitatory.0"+str(unit_i)+"_0"+str(unit_j)+".matrix",(BaseN,BaseN)) 
## c_latexc_weights = Numeric.array(c_latexc_weights)
## c_latexc_weights = c_latexc_weights[17:31,63:71]
## assert c_latexc_weights.shape==topo_latexc_weights.shape
## c_latexc_weights = c_latexc_weights.tolist()
## # end CEBHACKALERT

## compare_elements(topo_aff_weights,c_aff_weights,7,"V1 afferent weights")
## compare_elements(topo_latexc_weights,c_latexc_weights,7,"V1 lateral excitatory weights")





