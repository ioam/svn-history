"""
Test LISSOM.

$Id$
"""
__version__='$Revision$'





import unittest


# CEBHACKALERT:
# - This test is not set out properly at the moment.
#   It's just temporary.
#
# - When there's a lissom_or and a reference lissom in examples,
#   this could be based on either. Basing it on the reference
#   one would allow this file to match output from the matching
#   c++ lissom. At the moment, the values held to be true are just
#   from an earlier copy of Topographica (release_0_8_1)
#
# 
# - Should test change_bounds, and so on.



import random
import RandomArray
import fixedpoint
#import pdb # debugger

from math import pi, sqrt
from itertools import chain
from fixedpoint import FixedPoint

from topo.sheets.lissom import LISSOM
from topo.sheets.generatorsheet import GeneratorSheet
from topo.projections.basic import CFProjection
from topo.responsefns.basic import CFDotProduct
import topo.patterns.basic
import topo.patterns.random
from topo.base.sheet import BoundingBox
from topo.base.parameter import DynamicNumber
from topo.learningfns.optimized import DivisiveHebbian
from topo.patterns import PatternGeneratorParameter


fixedpoint.DEFAULT_PRECISION=3

GeneratorSheet.density = 10
GeneratorSheet.period = 1
GeneratorSheet.bounds = BoundingBox(points=((-0.7,-0.7),(0.7,0.7)))

random.seed(1234)
topo.patterns.basic.Gaussian.scale = 1.0
topo.patterns.basic.Gaussian.x = DynamicNumber(lambda : random.uniform(-0.5,0.5),softbounds=(-1.0,1.0))
topo.patterns.basic.Gaussian.y = DynamicNumber(lambda : random.uniform(-0.5,0.5),softbounds=(-1.0,1.0))
topo.patterns.basic.Gaussian.orientation = DynamicNumber(lambda :random.uniform(-pi,pi),softbounds=(0,2*pi))
topo.patterns.basic.Gaussian.size = 0.5
topo.patterns.basic.Gaussian.aspect_ratio = 0.1/0.5
topo.patterns.basic.Gaussian.bounds = BoundingBox(points=((-0.5,-0.5),(0.5,0.5)))


LISSOM.density = 10
LISSOM.bounds = BoundingBox(points=((-0.5,-0.5),(0.5,0.5)))

afferent_weight_bounds   = BoundingBox(points=((-0.1,-0.1),(0.1,0.1)))
excitatory_weight_bounds = BoundingBox(points=((-0.1,-0.1),(0.1,0.1)))
inhibitory_weight_bounds = BoundingBox(points=((-0.1,-0.1),(0.1,0.1)))

RandomArray.seed(500,500)
CFProjection.weights_generator = topo.patterns.random.UniformRandom()
CFProjection.response_fn=CFDotProduct()
CFProjection.learning_fn=DivisiveHebbian()

###########################################
# build simulation

s = topo.base.simulator.Simulator()


Retina = GeneratorSheet(input_generator=topo.patterns.basic.Gaussian(),
                        name='Retina')
V1 = LISSOM(name='V1')

# CEBHACKALERT: the commented-out 'weights_shape' code in each of the following
# connect sections makes the ConnectionFields circular.

s.connect(Retina,V1, delay = FixedPoint("0.05"),
          connection_type=CFProjection,
          connection_params = dict(strength = 1.0, name='Afferent0',
                                   weights_bounds = afferent_weight_bounds,
##                                     weights_shape = topo.patterns.basic.Disk(
##                                                       size=2*rf_radius/BaseRN,
##                                                       aspect_ratio=1.0,
##                                                       scale=1.0,offset=0.0,
##                                                       smoothing=0.0),
                                   learning_rate=0.1))

s.connect(V1,V1, delay = FixedPoint("0.05"), dest_port="exc",
          connection_type=CFProjection,
          connection_params = dict(strength = 1.0, name='LateralExcitatory',
                                   weights_bounds = excitatory_weight_bounds,
##                                     weights_shape = topo.patterns.basic.Disk(
##                                                       size=2*exc_rad/BaseN,
##                                                       aspect_ratio=1.0,
##                                                       scale=1.0,offset=0.0,
##                                                       smoothing=0.0),
                                   learning_rate=0.1))

s.connect(V1,V1, delay = FixedPoint("0.05"), dest_port="inh",
          connection_type=CFProjection,
          connection_params = dict(strength = -1.0, name='LateralInhibitory',
                                   weights_bounds = inhibitory_weight_bounds,
##                                     weights_shape = topo.patterns.basic.Disk(
##                                                       size=2*inh_rad/BaseN,
##                                                       aspect_ratio=1.0,
##                                                       scale=1.0,offset=0.0,
##                                                       smoothing=0.0),
                                   learning_rate=0.1))
        

s.run(1)



## TRUE VALUES
from Numeric import array
trueV1activity_1 = array(
      [[ 0.        ,  0.        ,  0.        ,  0.        ,  0.        ,  0.        ,
              0.        ,  0.        ,  0.        ,  0.05769338],
       [ 0.        ,  0.        ,  0.        ,  0.        ,  0.        ,  0.        ,
              0.        ,  0.07628979,  0.98036019,  0.75108557],
       [ 0.        ,  0.        ,  0.        ,  0.        ,  0.        ,  0.        ,
              0.        ,  0.3789181 ,  0.64169485,  0.84649156],
       [ 0.        ,  0.        ,  0.        ,  0.        ,  0.        ,  0.        ,
              0.        ,  0.3962008 ,  0.6872235 ,  0.97567701],
       [ 0.        ,  0.        ,  0.        ,  0.        ,  0.        ,  0.        ,
              0.        ,  0.06008094,  0.94814603,  1.        ],
       [ 0.        ,  0.        ,  0.        ,  0.        ,  0.        ,  0.        ,
              0.        ,  0.18469687,  0.69658426,  1.        ],
       [ 0.        ,  0.        ,  0.        ,  0.        ,  0.        ,  0.        ,
              0.        ,  0.60183836,  0.54907018,  0.89323473],
       [ 0.        ,  0.        ,  0.        ,  0.        ,  0.        ,  0.        ,
              0.        ,  0.13728851,  0.52079756,  1.        ],
       [ 0.        ,  0.        ,  0.        ,  0.        ,  0.        ,  0.        ,
              0.        ,  0.        ,  0.64268149,  0.82713208],
       [ 0.        ,  0.        ,  0.        ,  0.        ,  0.        ,  0.        ,
              0.        ,  0.20107687,  0.92360782,  0.74979364]])

trueV1activity_2 = array(
      [[ 0.        ,  0.        ,  0.        ,  0.        ,  0.        ,  0.        ,
              0.40594947,  0.        ,  0.94295788,  0.63281513],
       [ 0.        ,  0.        ,  0.        ,  0.        ,  0.        ,  0.        ,
              0.        ,  0.41441513,  1.        ,  1.        ],
       [ 0.        ,  0.        ,  0.        ,  0.        ,  0.        ,  0.        ,
              0.        ,  0.35357402,  0.80182225,  0.90179157],
       [ 0.        ,  0.        ,  0.        ,  0.        ,  0.        ,  0.        ,
              0.        ,  0.17650606,  0.20653095,  0.65564421],
       [ 0.        ,  0.        ,  0.        ,  0.        ,  0.        ,  0.        ,
              0.        ,  0.        ,  0.17703999,  0.36664038],
       [ 0.        ,  0.        ,  0.        ,  0.        ,  0.        ,  0.        ,
              0.        ,  0.        ,  0.        ,  0.1808876 ],
       [ 0.        ,  0.        ,  0.        ,  0.        ,  0.        ,  0.        ,
              0.        ,  0.        ,  0.        ,  0.        ],
       [ 0.        ,  0.        ,  0.        ,  0.        ,  0.        ,  0.        ,
              0.        ,  0.        ,  0.        ,  0.        ],
       [ 0.        ,  0.        ,  0.        ,  0.        ,  0.        ,  0.        ,
              0.        ,  0.        ,  0.        ,  0.        ],
       [ 0.        ,  0.        ,  0.        ,  0.        ,  0.        ,  0.        ,
              0.        ,  0.        ,  0.        ,  0.        ]])

trueV1activity_100 = array(
      [[ 0.        ,  0.        ,  0.        ,  0.        ,  0.        ,  0.04296006,
              0.37783136,  0.        ,  0.75920839,  0.3136163 ],
       [ 0.        ,  0.        ,  0.        ,  0.        ,  0.        ,  0.        ,
              0.23883402,  0.71347547,  1.        ,  0.89345175],
       [ 0.        ,  0.        ,  0.        ,  0.        ,  0.        ,  0.        ,
              0.11273809,  0.64296169,  1.        ,  1.        ],
       [ 0.        ,  0.        ,  0.        ,  0.        ,  0.        ,  0.        ,
              0.        ,  0.48084372,  1.        ,  1.        ],
       [ 0.        ,  0.        ,  0.        ,  0.        ,  0.        ,  0.        ,
              0.        ,  0.27324691,  0.83362928,  1.        ],
       [ 0.        ,  0.        ,  0.        ,  0.        ,  0.        ,  0.        ,
              0.        ,  0.15434023,  0.6363124 ,  0.99712799],
       [ 0.        ,  0.        ,  0.        ,  0.        ,  0.        ,  0.        ,
              0.        ,  0.05253129,  0.45349253,  0.80927694],
       [ 0.        ,  0.        ,  0.        ,  0.        ,  0.        ,  0.        ,
              0.        ,  0.        ,  0.25930859,  0.59356245],
       [ 0.        ,  0.        ,  0.        ,  0.        ,  0.        ,  0.        ,
              0.        ,  0.        ,  0.0987682 ,  0.4108372 ],
       [ 0.        ,  0.        ,  0.        ,  0.        ,  0.        ,  0.        ,
              0.        ,  0.        ,  0.00516546,  0.25693517]])




class TestLissom(unittest.TestCase):


    def test_activity(self):
        """
        """
        n_rows,n_cols = V1.activity.shape
        for i in range(n_rows):
            for j in range(n_cols):
                self.assertEqual(V1.activity[i,j],trueV1activity_1[i,j])

        s.run(1)
        for i in range(n_rows):
            for j in range(n_cols):
                self.assertEqual(V1.activity[i,j],trueV1activity_2[i,j])

        s.run(98)
        for i in range(n_rows):
            for j in range(n_cols):
                self.assertEqual(V1.activity[i,j],trueV1activity_100[i,j])


        

suite = unittest.TestSuite()
suite.addTest(unittest.makeSuite(TestLissom))

if __name__ == '__main__':
    unittest.TextTestRunner(verbosity=2).run(suite)
