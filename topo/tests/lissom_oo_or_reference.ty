"""

$Id$
"""
__version__='$Revision$'

# (needs updating to use schedule_command)


# CEBHACKALERT: parameters not all yet setup to match


# CEBHACKALERT: learning rates need to be adjusted
# for all the times the bounds change.

# Current matching status:



import random
import fixedpoint
#import pdb # debugger

from math import pi, sqrt
from itertools import chain
from fixedpoint import FixedPoint

from topo.sheets.lissom import LISSOM
from topo.sheets.generatorsheet import GeneratorSheet
from topo.projections.basic import CFProjection,SharedWeightProjection
from topo.responsefns.optimized import CFPDotProduct_opt1
import topo.patterns.basic
from topo.base.sheet import BoundingBox
from topo.base.parameterclasses import DynamicNumber
from topo.base.cf import CFSheet
from topo.base.boundingregion import BoundingBox
from topo.learningfns.optimized import CFProjectionHebbian_opt1
from topo.outputfns.optimized import CFProjectionDivisiveSumNormalize_opt1
from topo.outputfns.basic import DivisiveSumNormalize,PiecewiseLinear
from topo.patterns import PatternGeneratorParameter
import topo.tests.lissom_log_parser

###########################################
# Variables to match the C++ version of LISSOM

### (1)
BaseN=48.0
BaseRN=24.0
BaseLN=24.0
area_scale=1.0
#num_eyes=1
rf_radius=BaseRN/4.0+0.5


inh_rad=max(2.5,BaseN/4.0-1.0)
exc_rad=max(2.5,BaseN/10.0)
min_exc_rad=max(1.0,BaseN/44+0.5)
#default_afferent_size_scale=BaseN/BaseRN
gammaexc=0.9
gammainh=0.9
delta=0.083
beta=0.633


### (2)
randomness = 0.0
#smooth_circular_radius_trim = -0.25

rf_radius_scale=5.0/rf_radius
#retina_area_scale = (BaseRN*area_scale/24.0*rf_radius_scale)*(BaseRN*area_scale/24.0*rf_radius_scale)
#inputs_pereye=max(retina_area_scale,1)
xsigma=6.0
ysigma=1.5
scale_input=1.0


# radius of LGN DoG center Gaussian
sigma_c = 0.5 

# radius of LGN DoG surround Gaussian
sigma_s = 4*sigma_c 

# radius of LGN afferent connections
r_L = 4.7*sigma_s

# buffers so sheet above has full rfs...
lgn_edge_buffer = round(rf_radius,0)
retina_edge_buffer=round(rf_radius+r_L,0)

# ...and actual numbers of neurons with the buffers
RN=round(BaseRN*area_scale+2*retina_edge_buffer,0)
LN=round(BaseLN*area_scale+2*lgn_edge_buffer,0)


### (3)
acs=6.5*6.5/rf_radius/rf_radius
ecs=19.5*19.5/exc_rad/exc_rad
ics=47.5*47.5/inh_rad/inh_rad
alpha_input=0.007*acs
alpha_exc=0.002*ecs
alpha_inh=0.00025*ics

tsettle=8

assert LN == 38
assert lgn_edge_buffer == 7
assert xsigma == 6
assert ysigma == 1.5
#assert inputs_pereye == 1
#assert round(retina_area_scale,6) == 0.591716
assert rf_radius == 6.5
assert delta == 0.083
assert beta == 0.633
#assert default_afferent_size_scale == 3
assert rf_radius == 6.5
assert inh_rad == 11
assert exc_rad == 4.8
assert area_scale == 1
assert BaseRN == 24
assert BaseN == 48
#assert num_eyes==1
assert gammaexc==0.9
assert gammainh==0.9
assert randomness == 0.0
assert round(rf_radius_scale,6)==0.769231
assert scale_input==1.0
assert acs==1
assert round(ecs,4)==16.5039
assert round(ics,4)==18.6467
assert round(alpha_input,3)==0.007
assert round(alpha_exc,7)==0.0330078
assert round(alpha_inh,8)==0.00466167
assert tsettle == 8
assert round(min_exc_rad,5) == 1.59091


###########################################
# Set parameters

# Number of decimal places for simulator time
fixedpoint.DEFAULT_PRECISION=3
random.seed(1234)

# input generation params
GeneratorSheet.density = BaseRN*area_scale
GeneratorSheet.period = 1

# take the input pattern position parameters from the log file output of the equivalent c++ simulation
n_inputs,input_x,input_y,input_orientation = topo.tests.lissom_log_parser.get_input_params(log_file="topo/tests/oo_or_map_topo.log")
n_inputs-=1;input_x.next();input_y.next();input_orientation.next() # c++ lissom's first iteration is just a test

print "Number of patterns available for learning iterations:",n_inputs

gaussian_width = xsigma/BaseRN/sqrt(2.0)
gaussian_height = ysigma/BaseRN/sqrt(2.0)

input_pattern = topo.patterns.basic.Gaussian(scale=scale_input,
                                             size = 2*gaussian_height,
                                             aspect_ratio= gaussian_width/gaussian_height,
                                             x=DynamicNumber(lambda : input_x.next()/BaseLN - 0.5*LN/BaseLN),
                                             y=DynamicNumber(lambda : input_y.next()/BaseLN - 0.5*LN/BaseLN),
                                             orientation=DynamicNumber(lambda : round(2*pi*input_orientation.next()/360.0,1)))


retina_bounds = BoundingBox(radius= RN/(2.0*BaseRN*area_scale))
lgn_bounds = BoundingBox(radius=LN/(2.0*BaseLN*area_scale))
                                               
#LISSOM.tsettle=tsettle

# division done here once for convenience
min_exc_radius = min_exc_rad/BaseN

# Connection parameters
lgn_weight_bounds = BoundingBox(radius=r_L/BaseLN)
afferent_weight_bounds   = BoundingBox(radius=rf_radius/BaseRN)               # 137 units
excitatory_weight_bounds = BoundingBox(radius=exc_rad/BaseN, min_radius=min_exc_radius)  # 97 units
inhibitory_weight_bounds = BoundingBox(radius=inh_rad/BaseN)                  # 421 units

# Circular ConnectionFields
CFProjection.weights_shape = topo.patterns.basic.Disk(smoothing=0.0)

# Specify weight initialization
CFProjection.weights_generator = topo.patterns.basic.Constant()

# Specify the response function
# inlinec.optimized should make this unnecessary.
CFProjection.response_fn=CFPDotProduct_opt1()

# Specify learning function
CFProjection.learning_fn=CFProjectionHebbian_opt1()

CFProjection.weights_output_fn=CFProjectionDivisiveSumNormalize_opt1()

SharedWeightProjection.weights_output_fn.single_cf_fn = DivisiveSumNormalize()

###########################################
# build simulation

s = topo.base.simulator.Simulator()

Retina = GeneratorSheet(name='Retina',bounds=retina_bounds,
                        input_generator=input_pattern)

LGNOn = CFSheet(bounds=lgn_bounds,name='LGNOn',density=24.0,
                output_fn=PiecewiseLinear(lower_bound=0.0,upper_bound=1.0))

LGNOff = CFSheet(bounds=lgn_bounds,name='LGNOff',density=24.0,
                 output_fn=PiecewiseLinear(lower_bound=0.0,upper_bound=1.0))

V1 = LISSOM(name='V1', density=48.0,
            output_fn=PiecewiseLinear(lower_bound=delta,upper_bound=beta))


# Use Composite for center/surround instead of two projections
# (also remove SharedWeightProjection.weights_output_fn... line above
##########################################################################
## from topo.base.parameterclasses import Wrapper

## centerg = topo.patterns.basic.Gaussian(
##     size=2*sigma_c/BaseRN,aspect_ratio=1,output_fn=DivisiveSumNormalize())

## surroundg = topo.patterns.basic.Gaussian(
##     size=2*sigma_s/BaseRN,aspect_ratio=1,output_fn=DivisiveSumNormalize())

## ong = topo.patterns.basic.CompositePatternGenerator(
##     generators=[centerg,surroundg],operator=Wrapper("Numeric.subtract"))

## offg = topo.patterns.basic.CompositePatternGenerator(
##     generators=[surroundg,centerg],operator=Wrapper("Numeric.subtract"))
    
## # LGN ON channel
## s.connect(Retina,LGNOn,delay=FixedPoint("0.05"),
##           connection_type=SharedWeightProjection,strength=2.33,
##           weights_bounds=BoundingBox(radius=0.375),name='ON',
##           weights_generator=ong)

## # LGN OFF channel
## s.connect(Retina,LGNOff,delay = FixedPoint("0.05"),
##           connection_type=SharedWeightProjection,strength=2.33,
##           name='Center',weights_bounds=BoundingBox(radius=0.375),
##           weights_generator=offg)
##########################################################################


# LGN ON channel


LGNOn_center = s.connect2('Retina','LGNOn',dest_port="center",delay = FixedPoint("0.05"),
                         connection_type=SharedWeightProjection,strength=2.33,
                         name='Center',weights_bounds=lgn_weight_bounds,
                         weights_generator=topo.patterns.basic.Gaussian(size=2*sigma_c/BaseRN,aspect_ratio=1))


LGNOn_surround = s.connect2('Retina','LGNOn',dest_port="surround",delay = FixedPoint("0.05"),
                           connection_type=SharedWeightProjection,strength=-2.33,
                           name='Surround',weights_bounds=lgn_weight_bounds,
                           weights_generator=topo.patterns.basic.Gaussian(size=2*sigma_s/BaseRN,aspect_ratio=1))


# LGN OFF channel
LGNOff_center = s.connect2('Retina','LGNOff',dest_port="center",delay = FixedPoint("0.05"),
                          connection_type=SharedWeightProjection,strength=-2.33,
                          name='Center',weights_bounds=lgn_weight_bounds,
                          weights_generator=topo.patterns.basic.Gaussian(size=2*sigma_c/BaseRN,aspect_ratio=1))


LGNOff_surround = s.connect2('Retina','LGNOff',dest_port="surround",delay = FixedPoint("0.05"),
                            connection_type=SharedWeightProjection,strength=2.33,
                            name='Surround',weights_bounds=lgn_weight_bounds,
                            weights_generator=topo.patterns.basic.Gaussian(size=2*sigma_s/BaseRN,aspect_ratio=1))


s.connect2('LGNOn','V1',delay=FixedPoint("0.05"),dest_port="on",
          connection_type=CFProjection,strength=0.5,name='LGNOnAfferent',
          weights_bounds=afferent_weight_bounds,learning_rate=alpha_input*137)

s.connect2('LGNOff','V1',delay=FixedPoint("0.05"),dest_port="off",
          connection_type=CFProjection,strength=0.5,name='LGNOffAfferent',
          weights_bounds=afferent_weight_bounds,learning_rate=alpha_input*137)


s.connect2('V1','V1',delay=FixedPoint("0.05"),dest_port="exc",
          connection_type=CFProjection,strength=0.9,name='LateralExcitatory',
          weights_bounds=excitatory_weight_bounds,learning_rate=alpha_exc*97) 
            
s.connect2('V1','V1',delay=FixedPoint("0.05"), dest_port="inh",
          connection_type=CFProjection,strength=-0.9,name='LateralInhibitory',
          weights_bounds=inhibitory_weight_bounds,learning_rate=alpha_inh*421)         


#V1.set_projections_to_jointly_normalize(['LGNOnAfferent','LGNOffAfferent'])

# Times are 1 less than the or_map_topo.param c++ lissom simulation because that one uses
# "hook before_input" to schedule events. So, an event at t=200 is executed before t=200's
# input pattern is presented. In Topographica, an event scheduled at t=0 is executed
# after time=0's input pattern is presented. So one at t=199 is executed before t=200's
# input pattern is presented, and is therefore  equivalent to or_map_topo's event scheduled at t=200.


# this results in 37 units
s.schedule_action(199, V1.projections()['LateralExcitatory'].change_bounds, BoundingBox(radius=0.6*exc_rad/BaseN,min_radius=min_exc_radius))

# and this results in 21 units
s.schedule_action(499, V1.projections()['LateralExcitatory'].change_bounds, BoundingBox(radius=0.42*exc_rad/BaseN,min_radius=min_exc_radius))



# Schedule action requires a function, so we create a temporary one
def set_learning_rate(projection_name, rate):
    """Set the learning rate on the named projection of V1."""
    V1.projections()[projection_name].learning_rate=rate


# number of units changes with the bounds change
s.schedule_action(  199, set_learning_rate, "LateralExcitatory", alpha_exc*37)

# scheduled change AND number of units changes with bounds change
s.schedule_action(  499, set_learning_rate, "LateralExcitatory", 0.001*ecs*21)


s.schedule_action(  499, set_learning_rate, "LGNOnAfferent", 0.005*acs*137)
s.schedule_action( 1999, set_learning_rate, "LGNOnAfferent", 0.004*acs*137)
s.schedule_action( 3999, set_learning_rate, "LGNOnAfferent", 0.003*acs*137)
s.schedule_action(19999, set_learning_rate, "LGNOnAfferent", 0.0015*acs*137)

s.schedule_action(  499, set_learning_rate, "LGNOffAfferent", 0.005*acs*137)
s.schedule_action( 1999, set_learning_rate, "LGNOffAfferent", 0.004*acs*137)
s.schedule_action( 3999, set_learning_rate, "LGNOffAfferent", 0.003*acs*137)
s.schedule_action(19999, set_learning_rate, "LGNOffAfferent", 0.0015*acs*137)


def set_deltabeta(x,y):
    """Set the threshold function limits on V1."""
    V1.output_fn.lower_bound=x
    V1.output_fn.upper_bound=y

s.schedule_action(  199, set_deltabeta,0.093 , 0.643)
s.schedule_action(  499, set_deltabeta,0.103 , 0.653)
s.schedule_action(  999, set_deltabeta,0.133 , 0.663)
s.schedule_action( 1999, set_deltabeta,0.163 , 0.683)
s.schedule_action( 2999, set_deltabeta,0.183 , 0.713)
s.schedule_action( 3999, set_deltabeta,0.183 , 0.743)
s.schedule_action( 4999, set_deltabeta,0.193 , 0.773)
s.schedule_action( 6499, set_deltabeta,0.203 , 0.803)
s.schedule_action( 7999, set_deltabeta,0.213 , 0.833)
s.schedule_action(19999, set_deltabeta,0.223 , 0.863)






# CEBHACKALERT: actual tests commented out.

def compare_elements(topo_matrix,lissom_matrix,dp,topo_matrix_name):
    """
    Go through the two matrices element-by-element and check for match to the specified
    number of decimal places (dp).
    """
    r,c = topo_matrix.shape
    for i in range(r):
        for j in range(c):
            t_value = round(topo_matrix[i,j],dp)
            l_value = round(lissom_matrix[i][j],dp)
            # CEBHACKALERT: will become some kind of assert
            if t_value != l_value:
                print "\n" + topo_matrix_name + " element ("+str(i)+","+str(j)+") didn't match to " + str(dp) + " decimal places.\nTopographica value="+str(t_value)+", C++ LISSOM value="+str(l_value)

    
## # CEBHACKALERT: will check values at different iterations (including after change_bounds() etc).
## # Also will be putting data files in a reference/ subdirectory
## s.run(1)

## # compare C++ LISSOM and Topogrpahica activity values in the Retina and V1
## c_retina_act = topo.tests.lissom_log_parser.get_matrix("topo/tests/or_map_topo.000001p000.Eye0_Activity.matrix",(RN,RN))
## c_v1_act = topo.tests.lissom_log_parser.get_matrix("topo/tests/or_map_topo.000001p000.Primary_Activity.matrix",(BaseN,BaseN))
## compare_elements(Retina.activity,c_retina_act,6,Retina.name)
## compare_elements(V1.activity,c_v1_act,5,V1.name)


## # compare weights 
## unit_i,unit_j = 24,70

## topo_aff_weights = V1.in_connections[0].cfs[unit_i][unit_j].weights
## topo_latexc_weights = V1.in_connections[1].cfs[unit_i][unit_j].weights
## topo_latinh_weights = V1.in_connections[2].cfs[unit_i][unit_j].weights

## # CEBHACKALERT: turning off situate in c++ lissom appears to make the weight plot unsituated but
## # leaves the matrix output situated! So I take the right slice. I will automate this in the
## # get_matrix() function (unless the C could be changed easily?). Then almost all these lines will go.
## import Numeric
## c_aff_weights = topo.tests.lissom_log_parser.get_matrix("topo/tests/or_map_topo.000001.wts.Primary.Afferent0.0"+str(unit_i)+"_0"+str(unit_j)+".matrix",(RN,RN)) 
## c_aff_weights = Numeric.array(c_aff_weights)
## c_aff_weights = c_aff_weights[7:18,22:32]
## assert c_aff_weights.shape==topo_aff_weights.shape
## c_aff_weights = c_aff_weights.tolist()

## c_latexc_weights = topo.tests.lissom_log_parser.get_matrix("topo/tests/or_map_topo.000001.wts.Primary.LateralExcitatory.0"+str(unit_i)+"_0"+str(unit_j)+".matrix",(BaseN,BaseN)) 
## c_latexc_weights = Numeric.array(c_latexc_weights)
## c_latexc_weights = c_latexc_weights[17:31,63:71]
## assert c_latexc_weights.shape==topo_latexc_weights.shape
## c_latexc_weights = c_latexc_weights.tolist()
## # end CEBHACKALERT

## compare_elements(topo_aff_weights,c_aff_weights,7,"V1 afferent weights")
## compare_elements(topo_latexc_weights,c_latexc_weights,7,"V1 lateral excitatory weights")




# Performance profiling
#
# Example 1
#import hotshot,hotshot.stats
#prof = hotshot.Profile("abc")
#prof.runctx('s.run(10000)',globals(),locals())
#prof.close()
#
#p = hotshot.stats.load("abc")
#p.strip_dirs().sort_stats('cumulative','time').print_stats()
#
# Example 2
#import profile,pstats
#profile.runctx('s.run(10000)',globals(),locals(),"abc")
#p = pstats.Stats('abc')
#p.strip_dirs().sort_stats('cumulative').print_stats()

