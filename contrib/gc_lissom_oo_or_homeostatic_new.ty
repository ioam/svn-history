"""

$Id: lissom_oo_or_homeostatic.ty 8650 2008-06-17 04:28:07Z jbednar $

"""
__version__='$Revision: 8650 $'

import numpy

from math import pi, sqrt


import topo.pattern.basic
import topo.pattern.random


from topo.pattern.basic import Gaussian
from topo.sheet.lissom import JointScaling, LISSOM
from topo.sheet.optimized import LISSOM_Opt,compute_joint_norm_totals_opt
from topo.sheet.generator import GeneratorSheet
from topo.projection.basic import CFProjection, SharedWeightCFProjection
from topo.responsefn.optimized import CFPRF_DotProduct_opt
from topo.base.cf import CFSheet, CFPLF_PluginScaled
from topo.base.boundingregion import BoundingBox
from topo.learningfn.optimized import CFPLF_Hebbian_opt,CFPLF_Scaled_opt
from topo.outputfn.optimized import CFPOF_DivisiveNormalizeL1_opt
from topo.outputfn.basic import PiecewiseLinear, DivisiveNormalizeL1, PipelineOF, IdentityOF, ActivityAveragingOF
from topo.outputfn.basic import AttributeTrackingOF, Sigmoid, HalfRectify,HalfRectifyAndPower, HomeostaticMaxEnt
from topo.misc.numbergenerator import UniformRandom, BoundedNumber, ExponentialDecay
from topo.pattern.image import Image
from contrib.jacommands import ActivityHysteresis,CascadeHomeostatic

###############################################################
####Different input types which can be used for development###
dataset=locals().get('dataset',"Gaussian") #set the input type by choosing the dataset parameter 

if dataset=="Gaussian":
    input_type=Gaussian
    num_inputs=locals().get('num_inputs',2) #in the case where dataset=Gaussian, must also set the number of Gaussians per iteration, default is 2
    inputs=[input_type(x=UniformRandom(lbound=-0.75,ubound=0.75,seed=12+i),
                       y=UniformRandom(lbound=-0.75,ubound=0.75,seed=35+i),
                       orientation=UniformRandom(lbound=-pi,ubound=pi,seed=21+i),
                       size=0.088388, aspect_ratio=4.66667, scale= locals().get('scale', 1.0), bounds=BoundingBox(radius=1.125))
            #Set the contrast of the gaussian patterns by setting the scale parameter.
            for i in xrange(num_inputs)]
    
    combined_inputs = topo.pattern.basic.SeparatedComposite(min_separation=0,generators=inputs)
    
elif dataset=="Natural":
	input_type=topo.pattern.image.Image
	image_filenames=["images/mcgill_img/foliage/%02d.png"%(i+1) for i in xrange(98)]
	inputs=[input_type(filename=f,
				size=10.0,  #size_normalization='original',(size=10.0)
				x=UniformRandom(lbound=-0.75,ubound=0.75,seed=12),
				y=UniformRandom(lbound=-0.75,ubound=0.75,seed=36),
				orientation=UniformRandom(lbound=-pi,ubound=pi,seed=65))
			for f in image_filenames]

	combined_inputs =topo.pattern.basic.Selector(generators=inputs)


###############################################################################

#Sheet coordinates of units to track for debugging
units=locals().get('units',[(0.0, 0.0), (0.25,0.25), (0.49,0.49)])


#Set targets based on frequency of occurance of V1 activation
frequency=locals().get('frequency',2)

#Target average afferent activity and target average V1 activity set based on
#frequency and balance between afferent and lateral activity
mu=locals().get('mu',0.0045*frequency)
balance = locals().get('balance',4.0)
afferent_target = locals().get('afferent_target',mu*balance)

#Smoothing value for exponential averaging
smoothing=locals().get('smoothing',0.999)

#Sheet output functions
#LGN
LGN_on_output_fn=HalfRectify()
LGN_off_output_fn=HalfRectify()

OF=locals().get('OF',"Homeo") #set the input type by choosing the dataset parameter

#V1

Attrib_Tracker=AttributeTrackingOF(object="topo.sim['V1']", attrib_names=['x_avg', 'sf', 'lr_sf', 'scaled_x_avg'], units=units)

if OF ==   'Cascade':
	HE=CascadeHomeostatic(mu=mu, step=9) 
else:
	HE=HomeostaticMaxEnt(smoothing=smoothing, eta=locals().get('eta',0.016),mu=mu, step=9)

V1_Tracker=AttributeTrackingOF(object=HE, coordframe="topo.sim['V1']",attrib_names=['a', 'b','y_avg'], units=units, step=9)
V1_OF=PipelineOF(output_fns=[Attrib_Tracker, HE, V1_Tracker])

if OF == 'HR':
	t  = locals().get('treshold',0.0)
	e =  locals().get('exponent',1.5)
	V1_OF = HalfRectifyAndPower(e=e,t=t)

#Can set initial output function parameters otherwise they will be generated randomly 
#V1_OF.a_init=12.0 
#V1_OF.b_init=-5.0



# Specify weight initialization, response function, and learning function
CFProjection.cf_shape = topo.pattern.basic.Disk(smoothing=0.0)
CFProjection.weights_generator = topo.pattern.basic.Constant()
CFProjection.response_fn=CFPRF_DotProduct_opt()
CFProjection.learning_fn=CFPLF_Hebbian_opt()
CFProjection.weights_output_fn=CFPOF_DivisiveNormalizeL1_opt()
SharedWeightCFProjection.response_fn=CFPRF_DotProduct_opt()


# DoG weights for the LGN

centerg   = Gaussian(size=0.07385,aspect_ratio=1.0,output_fn=DivisiveNormalizeL1())
surroundg = Gaussian(size=0.29540,aspect_ratio=1.0,output_fn=DivisiveNormalizeL1())
    
on_weights = topo.pattern.basic.Composite(
    generators=[centerg,surroundg],operator=numpy.subtract)

off_weights = topo.pattern.basic.Composite(
    generators=[surroundg,centerg],operator=numpy.subtract)

#Function for generating Gaussian random initial weights
def gauss_rand(size):
    return topo.pattern.basic.Composite(operator=numpy.multiply, 
                                         generators=[Gaussian(aspect_ratio=1.0, size=size),
                                                     topo.pattern.random.UniformRandom()])


default_retinal_density = locals().get('default_retinal_density',default_density/2)

###########################################
# build simulation

topo.sim['Retina']=GeneratorSheet(nominal_density=locals().get('default_retinal_density', 24),
                                  input_generator=combined_inputs,
                                  period=1.0, phase=0.05,
                                  nominal_bounds=BoundingBox(radius=0.5+0.25+0.375))

topo.sim['LGNOn']=LISSOM(nominal_density=locals().get('default_retinal_density', 24),
                          nominal_bounds=BoundingBox(radius=0.5+0.25+0.25),
                          output_fn=LGN_on_output_fn,tsettle=0,
                          measure_maps=False)
                          
topo.sim['LGNOff']=LISSOM(nominal_density=locals().get('default_retinal_density', 24),
                           nominal_bounds=BoundingBox(radius=0.5+0.25+0.25),
                           output_fn=LGN_off_output_fn,tsettle=0,
                           measure_maps=False)


topo.sim['V1'] = JointScaling(nominal_density=locals().get('default_density',48.0),
                              nominal_bounds=BoundingBox(radius=0.5),tsettle=9,
                              plastic=True,
                              output_fn=PipelineOF(output_fns=[ActivityHysteresis(time_constant=0.5),V1_OF]),
                              target=afferent_target, smoothing=smoothing,
                              target_lr=locals().get('target_lr',0.045))

#make normalization fast
topo.sim["V1"].joint_norm_fn=compute_joint_norm_totals_opt


V1Inh = locals().get('V1Inh',False)

if V1Inh:
	topo.sim['V1Inh'] = LISSOM_Opt(nominal_density=locals().get('default_density',48.0),
	                              nominal_bounds=BoundingBox(radius=0.5),tsettle=1,
	                              plastic=False,
	                              output_fn=HalfRectify())


#V1

topo.sim.connect('Retina','LGNOn',delay=0.05,
                 connection_type=SharedWeightCFProjection,strength=2.33,
                 nominal_bounds_template=BoundingBox(radius=0.375),name='Afferent',
                 weights_generator=on_weights)

topo.sim.connect('Retina','LGNOff',delay=0.05,
                 connection_type=SharedWeightCFProjection,strength=2.33,
                 nominal_bounds_template=BoundingBox(radius=0.375),name='Afferent',
                 weights_generator=off_weights)

topo.sim.connect('LGNOn','V1',delay=0.05, dest_port=('Activity','JointNormalize', 'Afferent'),
                 connection_type=CFProjection,
                 learning_fn=CFPLF_Scaled_opt(),
                 strength=7.0,name='LGNOnAfferent',
                 weights_generator=gauss_rand(size=2*0.27083),
                 nominal_bounds_template=BoundingBox(radius=0.27083),
		 learning_rate=locals().get('aff_lr',0.137*5))
               		 
topo.sim.connect('LGNOff','V1',delay=0.05, dest_port=('Activity','JointNormalize', 'Afferent'),
		 		 connection_type=CFProjection,
                 learning_fn=CFPLF_Scaled_opt(),
                 strength=7.0,name='LGNOffAfferent',
                 weights_generator=gauss_rand(size=2*0.27083),
                 nominal_bounds_template=BoundingBox(radius=0.27083),
		 learning_rate=locals().get('aff_lr',0.137*5))

topo.sim.connect('V1','V1',delay=0.05,name='LateralExcitatory',
                 connection_type=CFProjection,
                 strength=locals().get('exc_strength',1.0),
                 weights_generator=topo.pattern.basic.Gaussian(aspect_ratio=1.0, size=locals().get('exc_size',0.04)),
                 nominal_bounds_template=BoundingBox(radius=locals().get('exc_size',0.04)),learning_rate=0.0) 

topo.sim.connect('V1','V1',delay=0.05,name='LateralInhibitory',
                 connection_type=CFProjection,
                 strength=-1.0*locals().get('inh_strength',1.0),
                 #inh_strength should be increased for more distributed datasets i.e. when the frequency parameter is higher
                 weights_generator=gauss_rand(size=2*0.22917),
                 nominal_bounds_template=BoundingBox(radius=0.22917),learning_rate=locals().get('lat_lr',1.80873))
	               		 


#V1 Inh
if V1Inh:
	topo.sim.connect('LGNOn','V1Inh',delay=0.05, dest_port=('Activity','JointNormalize', 'Afferent'),
	                 connection_type=SharedWeightCFProjection,
	                 strength=7.0,name='LGNOnAfferent',
	                 weights_generator=gauss_rand(size=2*0.27083),
	                 nominal_bounds_template=BoundingBox(radius=0.27083))
	               		 
	topo.sim.connect('LGNOff','V1Inh',delay=0.05, dest_port=('Activity','JointNormalize', 'Afferent'),
			 		 connection_type=SharedWeightCFProjection,
	                 strength=7.0,name='LGNOffAfferent',
	                 weights_generator=gauss_rand(size=2*0.27083),
	                 nominal_bounds_template=BoundingBox(radius=0.27083))
	                 
	topo.sim.connect('V1Inh','V1',delay=0.05,name='UniformInhibition',
	                 connection_type=SharedWeightCFProjection,
	                 strength=locals().get('ui_strength',-0.1),
	                 weights_generator=topo.pattern.basic.Gaussian(aspect_ratio=1.0, size=0.08,
	                 nominal_bounds_template=BoundingBox(radius=0.08),learning_rate=0.0)) 
                 


import contrib.jacommands
contrib.jacommands.AddGC()

if OF == 'HR':
	topo.sim["V1"].tsettle=16
	

# default locations for model editor
topo.sim.grid_layout([[None,    'V1',     None],
                      ['LGNOn', None,     'LGNOff'],
                      [None,    'Retina', None]], xstart=150)

