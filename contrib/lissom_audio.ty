"""
Bilal Khan, 2009/2010

Cochlea Spectrogram
Auditory STRFs in ICc, MGBv
LISSOM A1

$Id$
"""
__version__='$Revision$'


import numpy
import param

from topo import learningfn, transferfn, pattern, projection, responsefn, sheet
from topo.misc.commandline import global_params as p

import topo.learningfn.optimized
import topo.learningfn.projfn 
import topo.transferfn.optimized 
import topo.pattern.random
import topo.responsefn.optimized 
import topo.sheet.lissom
import topo.sheet.optimized

# Spectral smoothing windows
from topo.pattern.basic import rectangular
from numpy import bartlett, blackman, hamming, hanning, kaiser

from topo.pattern.audio import AudioFile, AudioFolder
from topo.base.patterngenerator import PatternGenerator

# for pattern generators
from topo.pattern.basic import Composite, Sigmoid
from topo.base.sheetcoords import SheetCoordinateSystem
from topo.misc.patternfn import float_error_ignore
from numpy import log, max, subtract, add, divide, power, exp, pi
          
        
        
###################################
###   COMMAND LINE PARAMETERS   ###
###################################       

p.add (density_multiplier = param.Number(default=1.0, bounds=(None,None), 
        doc="""Multiplicatively scales mgb and cortex densities"""),
        
       cochlea_density = param.Number(default=100.0, bounds=(0,None), inclusive_bounds=(False,True),
        doc="""The nominal_density to use for the Cochlea."""),
        
       mgbv_density = param.Number(default=50.0, bounds=(0,None), inclusive_bounds=(False,True),
        doc="""The nominal_density to use for the Medial Geniculate Body (Ventral division)."""),

       cortex_density = param.Number(default=50.0, bounds=(0,None), inclusive_bounds=(False,True),
        doc="""The nominal_density to use for Auditory Cortex (AI)."""))

p.mgbv_density = p.mgbv_density * p.density_multiplier
p.cortex_density = p.cortex_density * p.density_multiplier



#######################
###   PROJECTIONS   ###
#######################

projection.CFProjection.cf_shape=pattern.Disk(smoothing=0.0)
projection.CFProjection.weights_generator=pattern.Constant()
projection.CFProjection.weights_output_fns=[transferfn.optimized.CFPOF_DivisiveNormalizeL1_opt()]
projection.CFProjection.response_fn=responsefn.optimized.CFPRF_DotProduct_opt()
projection.CFProjection.learning_fn=learningfn.optimized.CFPLF_Hebbian_opt()



###################################
###   AUDIO PATTERN GENERATOR   ###
###################################

"""
All STRFs employed come from the domestic cat. Audible frequency range of the  cat is in fact 48-85,000Hz. 
(Hearing range of the domestic cat, Hearing Research 19, p85-88, 1985, R.Heffner, H.Heffner)

We can't get anywhere near this with the ubiquitous audio sample rate of 44,100Hz, which spans 
the range 0-22,050Hz, so we confine to the human audible range 20-20,000Hz.

Sample window of 0.05 is the smallest we can use to get a decent frequency resolution from the fft.
"""

### INDIVIDUAL FILES ###

# Guitar rendition of Daisy Bell, in tribute to the IBM 704
# which in 1962 became the first ever computer to 'sing'.

#input_pattern=AudioFile(filename="sounds/complex/daisy.wav", min_frequency=20, max_frequency=20000,
#                        amplify_from_frequency=1500, amplify_till_frequency=7000, amplify_by=2.0,
#                        windowing_function=hanning, sample_window=0.05, seconds_per_timestep=0.001)

### ALL FILES IN FOLDER ###

input_pattern=AudioFolder(folderpath="sounds/sine_waves/normalized/", min_frequency=20, max_frequency=20000, 
                          amplify_from_frequency=1500, amplify_till_frequency=7000, amplify_by=0.0,
                          windowing_function=hanning, sample_window=0.05, seconds_per_timestep=0.001)



##################
###   SHEETS   ###
##################

### CALIBRATION SHEET ###

#calibration_sheet_dimensions = (0.2,0.1)
#
#topo.sim['Calibration']=sheet.GeneratorSheet(
#    nominal_density=p.mgbv_density,
#    input_generator=pattern.Constant(),
#    nominal_bounds=sheet.BoundingBox(
#            points=((-calibration_sheet_dimensions[0]/2, -calibration_sheet_dimensions[1]/2),
#                    (calibration_sheet_dimensions[0]/2, calibration_sheet_dimensions[1]/2))))
    
### COCHLEA ###

cochlea_dimensions = (1.0,1.0) # 100 msecs, 10 frequency bins (10 octaves)

topo.sim['Cochlea']=sheet.GeneratorSheet(
    nominal_density=p.cochlea_density,
    nominal_bounds=sheet.BoundingBox(points=((-cochlea_dimensions[0]/2, -cochlea_dimensions[1]/2),
                                             (cochlea_dimensions[0]/2, cochlea_dimensions[1]/2) )),
    input_generator=input_pattern, period=1.0, phase=0.05)


### MEDIAL GENICULATE BODY (Ventral Division) ###    

mgbv_connection_dimensions = (0.2,0.1) # 20 msecs, 1 octave
mgbv_dimensions = (cochlea_dimensions[0]-mgbv_connection_dimensions[0], 
                   cochlea_dimensions[1])#-mgbv_connection_dimensions[1])
                   
topo.sim['MGBv']=sheet.CFSheet(
    nominal_density=p.mgbv_density, output_fns=[transferfn.HalfRectify()],
    nominal_bounds=sheet.BoundingBox(points=((-mgbv_dimensions[0]/2, -mgbv_dimensions[1]/2),
                                             (mgbv_dimensions[0]/2, mgbv_dimensions[1]/2))) )
        
        
### AUDITORY CORTEX (Primary Division) ###    
        
a1_connection_dimensions = (0.27083,0.27083)        
a1_dimensions = (mgbv_dimensions[0]-a1_connection_dimensions[0], 
                 mgbv_dimensions[1])#-a1_connection_dimensions[1])
                                                  
topo.sim['A1']=sheet.lissom.LISSOM(
    nominal_density=p.cortex_density, tsettle=9,
    nominal_bounds=sheet.BoundingBox(points=((-a1_dimensions[0]/2, -a1_dimensions[1]/2),
                                             (a1_dimensions[0]/2, a1_dimensions[1]/2))),
    output_fns=[transferfn.PiecewiseLinear(lower_bound=0.083,upper_bound=0.633)],
    joint_norm_fn=sheet.optimized.compute_joint_norm_totals_opt)
    


#######################
###   CONNECTIONS   ###
#######################

### COCHLEA TO MEDIAL GENICULATE BODY ###

topo.sim.connect('Cochlea', 'MGBv', name='Cochlea Afferent', delay=0.05, 
    nominal_bounds_template=sheet.BoundingBox(
        points=((-mgbv_connection_dimensions[0]/2, -mgbv_connection_dimensions[1]/2),
                (mgbv_connection_dimensions[0]/2, mgbv_connection_dimensions[1]/2))),
    connection_type=projection.CFProjection, cf_shape=pattern.Constant(), strength=1.0, 
    weights_generator=pattern.SigmoidedDoG(center_size=0.03, center_aspect_ratio=3.9,
                                surround_size=0.09, surround_aspect_ratio=1.8, 
                                sigmoid_slope=20.0, sigmoid_x=0.01, size=0.5))      
                           
                                                                                                                                                                                                                     
### MEDIAL GENICULATE BODY TO CORTEX ###

topo.sim.connect(
    'MGBv', 'A1', name='MGB Afferent',
    dest_port=('Activity','JointNormalize','Afferent'),
    connection_type=projection.CFProjection,
    nominal_bounds_template=sheet.BoundingBox(
        points=((-a1_connection_dimensions[0]/2, -a1_connection_dimensions[1]/2),
                (a1_connection_dimensions[0]/2, a1_connection_dimensions[1]/2))),
    delay=0.05, learning_rate=0.9590/8, strength=1.0,
    weights_generator=pattern.random.GaussianCloud(gaussian_size=0.27083))

topo.sim.connect(
    'A1', 'A1', name='Lateral Excitatory', delay=0.05, strength=0.9,
    connection_type=projection.ResizableCFProjection, learning_rate=2.55528,
    nominal_bounds_template=sheet.BoundingBox(radius=0.10417),
    weights_generator=pattern.random.GaussianCloud(gaussian_size=0.10417))
        
topo.sim.connect(
    'A1', 'A1', name='Lateral Inhibitory', delay=0.05, strength=-0.9,
    connection_type=projection.CFProjection, learning_rate=1.80873,
    nominal_bounds_template=sheet.BoundingBox(radius=0.22917),
    weights_generator=pattern.random.GaussianCloud(gaussian_size=0.22917))



####################
###   ANALYSIS   ###
####################

# Measure feature maps based on unthresholded initial response
# for speed and reliability.
from topo.analysis.featureresponses import MeasureResponseCommand

MeasureResponseCommand.duration = 0.175
MeasureResponseCommand.apply_output_fns = False



##############################
###   PATTERN GENERATORS   ###
##############################

# BKALERT: log gaussian function and pattern below have been modified so that we have
# a standard gaussian in one direction (fixed central peak), and a log gaussian in the 
# other (movable peak). It is very much possible to have both axis with movable peaks,
# indeed that is the whole point, but the current implementation this messes up when 
# the pattern is rotated. To overcome this will involve first deciding what exactly we 
# mean as the 'centre' of a log gaussian (it has movable peaks and isn't necessarily 
# symetric) and then overloading the rotation function inherited from PatternGenerators
# in order to rotate about this centre. Without this rotation results in understandable 
# but unpredictable behaviour. 

# NOTE: The pattern as it is now (peak movable in *only one* axis) *can* be rotated. The
# log_gaussian and LogGaussian classes may be moved to misc.patternfn and pattern.basic
# respectively once the above issue is resolved, till then they're not ready for prime 
# time.

def log_gaussian(x, y, x_sigma, y_sigma, x_peak_position):
    """
    Two-dimensional oriented Log Gaussian pattern (i.e., 2D version of a
    bell curve with an independent, movable peak). Much like a normal 
    distribution, but not necessarily placing the peak above the center,
    and not necessarily summing to 1.0).
    """
    if x_sigma==0.0 or y_sigma==0.0:
        return x * 0.0

    with float_error_ignore():

        # Adjust ranges such that they
        # contain only positive values.
        x = log(add(x,x.max()))
#        y = log(add(x,x.max()))

        # Adjust position of peak
        x = subtract(x,x_peak_position)
#        y = subtract(y,y_peak_position)

        # Adjust decay rate
        x = divide( power(x,2),power(x_sigma,2) )
        y = divide( power(y,2),power(y_sigma,2) )
    
        return exp(-0.5 * (x + y))
        
        
class LogGaussian(PatternGenerator):
    """
    2D Log Gaussian pattern generator allowing standard gaussian 
    patterns but with the added advantage of movable peaks.

    The sigmas, governing decay rates from the peak of the Gaussian,
    are calculated from the size and aspect_ratio parameters as
    follows:

      y_sigma = size / 2
      x_sigma = y_sigma * aspect_ratio

    """
    
    aspect_ratio = param.Number(default=3.7,bounds=(0.0,None),softbounds=(0.0,10.0),
        doc="""Ratio of the pattern's width to its height.""")
    
    x = param.Number(default=0.5)
    
    size = param.Number(default=0.5)
    
    def _setup_xy(self,bounds,xdensity,ydensity,x,y,orientation):
        """
        Produce pattern coordinate matrices from the bounds and
        density (or rows and cols), and transforms them according to
        x, y, and orientation.
        """
        self.debug(lambda:"bounds=%s, xdensity=%s, ydensity=%s, x=%s, y=%s, orientation=%s"%(bounds,xdensity,ydensity,x,y,orientation))
        # Generate vectors representing coordinates at which the pattern
        # will be sampled.

        # CB: note to myself - use slice_._scs if supplied?
        x_points,y_points = SheetCoordinateSystem(bounds,xdensity,ydensity).sheetcoordinates_of_matrixidx()
            
        # Generate matrices of x and y sheet coordinates at which to
        # sample pattern, at the correct orientation
        self.pattern_x, self.pattern_y = self._create_and_rotate_coordinate_arrays(x_points,y_points-y,orientation)
            
    def function(self, p):
        y_sigma = p.size/2.0
        x_sigma = y_sigma*p.aspect_ratio
        
        return log_gaussian(self.pattern_x, self.pattern_y, x_sigma, y_sigma, p.x)

        
# BKALERT: The SigmoidedDolg pattern on the other hand is complete and ready for prime 
# time, it's kept here for now since its pretty useless without the above two.
class SigmoidedDoLG(PatternGenerator):
    """
    Sigmoid multiplicatively combined with a difference of Log Gaussians,
    such that one part of the plane can be the mirror image of the other.
    """
        
    center_size = param.Number(default=0.25, bounds=(0.1,None), softbounds=(0.1,5.0),doc="""
        size parameter for the center Gaussian.""")
    
    center_aspect_ratio = param.Number(default=7.0, bounds=(0.1,None), softbounds=(0.1,5.0),doc="""
        aspect_ratio parameter for the center Gaussian.""")
    
    center_x_peak = param.Number(default=-0.2,bounds=(None,None),softbounds=(-10.0,10.0),
        doc="""Position of peak along the X axis, relative to the pattern.""")

    center_y_peak = param.Number(default=0.29,bounds=(None,None),softbounds=(-10.0,10.0),
        doc="""Position of peak along the Y axis, relative to the pattern.""")
        
    surround_size = param.Number(default=0.57, bounds=(0.1,None), softbounds=(0.1,5.0),doc="""
        size parameter for the surround Gaussian.""")
    
    surround_aspect_ratio = param.Number(default=1.8, bounds=(0.1,None), softbounds=(0.1,5.0),doc="""
        aspect_ratio parameter for the surround Gaussian.""")
 
    surround_x_peak = param.Number(default=0.0,bounds=(None,None),softbounds=(-10.0,10.0),
        doc="""Position of peak along the X axis, relative to the pattern.""")

    surround_y_peak = param.Number(default=0.24,bounds=(None,None),softbounds=(-10.0,10.0),
        doc="""Position of peak along the Y axis, relative to the pattern.""")
           
    sigmoid_slope = param.Number(default=8.0, bounds=(None,None), softbounds=(-100.0,100.0),doc="""
        slope parameter for the Sigmoid.""")
    
    sigmoid_x = param.Number(default=0.5, bounds=(None,None), softbounds=(-1.0,1.0),doc="""
        x parameter for the Sigmoid.""")

    sigmoid_y = param.Number(default=0.0, bounds=(None,None), softbounds=(-1.0,1.0),doc="""
        y parameter for the Sigmoid.""")

                                                                                       
    def function(self, p):
        center = LogGaussian(size=p.center_size*p.size, aspect_ratio=p.center_aspect_ratio,
                     orientation=p.orientation, x=p.x, y=p.y, x_peak=p.center_x_peak, 
                     y_peak=p.center_y_peak, output_fns=[topo.transferfn.DivisiveNormalizeL1()])
                                
        surround = LogGaussian(size=p.surround_size*p.size, aspect_ratio=p.surround_aspect_ratio,
                       orientation=p.orientation, x=p.x, y=p.y, x_peak=p.surround_x_peak,
                       y_peak=p.surround_y_peak, output_fns=[topo.transferfn.DivisiveNormalizeL1()])
        
        dolg = Composite(generators=[center, surround], operator=numpy.subtract,
                   xdensity=p.xdensity, ydensity=p.ydensity, bounds=p.bounds)
        
        sigmoid = Sigmoid(slope=p.sigmoid_slope,
                      x=p.sigmoid_x+p.x+(p.center_size/2)*p.center_aspect_ratio,
                      y=p.sigmoid_y+p.y, orientation=p.orientation+pi/2)

        return Composite(generators=[dolg, sigmoid], operator=numpy.multiply,
                   xdensity=p.xdensity, ydensity=p.ydensity, bounds=p.bounds)()

