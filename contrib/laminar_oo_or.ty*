"""
The laminar_or.ty extended with LGN
Two layer model with one inhibitory and one excitatory sheet.
Recurrent short range connections between sheets, long range excitation and short range inhibition
Based on lissom_oo_or_noshrinking - work in progress.
Has homeostatic plasticity of Excitatory units (updated at each settling step),a sigmoid output function for inhibitory units and no shrinking of excitatory connections.

Currently updated with new lissom_oo_or_noshrinking parameters but not yet tested - will need to change strengths.

$Id$
"""
__version__='$Revision$'

import numpy
import copy

from math import pi, sqrt


import topo.pattern.basic
import topo.pattern.random

from topo.sheet.lissom import LISSOM
from topo.sheet.generator import GeneratorSheet
from topo.projection.basic import CFProjection, SharedWeightCFProjection
from topo.responsefn.optimized import CFPRF_DotProduct_opt
from topo.base.cf import CFSheet
from topo.base.boundingregion import BoundingBox
from topo.learningfn.optimized import CFPLF_Hebbian_opt
from topo.outputfn.optimized import CFPOF_DivisiveNormalizeL1_opt
from topo.outputfn.basic import PiecewiseLinear, DivisiveNormalizeL1, HomeostaticMaxEnt
from topo.outputfn.basic import GeneralizedLogistic, Sigmoid
from topo.pattern.basic import Gaussian, Composite, SeparatedComposite
from topo.misc.numbergenerator import UniformRandom, BoundedNumber, ExponentialDecay


num_inputs=2
input_type=topo.pattern.basic.Gaussian
inputs=[input_type(x=UniformRandom(lbound=-0.75,ubound=0.75,seed=12+i),
                   y=UniformRandom(lbound=-0.75,ubound=0.75,seed=34+i),
                   orientation=UniformRandom(lbound=-pi,ubound=pi,seed=56+i),
                   size=0.088388, aspect_ratio=4.66667, scale=1.0,
                   bounds=BoundingBox(radius=0.8))
                for i in xrange(num_inputs)]

combined_inputs = SeparatedComposite(min_separation=2.2*0.27083,generators=inputs)

# Specify weight initialization, response function, and learning function
CFProjection.weights_generator=topo.pattern.random.UniformRandom()
CFProjection.cf_shape=topo.pattern.basic.Disk(smoothing=0.0)
CFProjection.response_fn=CFPRF_DotProduct_opt()
CFProjection.learning_fn=CFPLF_Hebbian_opt()
CFProjection.weights_output_fn=CFPOF_DivisiveNormalizeL1_opt()


###########################################
# build simulation


# sheet initialization
topo.sim['Retina']=GeneratorSheet(nominal_density=24.0,
                                  input_generator=combined_inputs,
                                  period=1.0, phase=0.05,
                                  nominal_bounds=BoundingBox(radius=0.5+0.25+0.375))

topo.sim['LGNOn']=CFSheet(nominal_density=24.0,
                          nominal_bounds=BoundingBox(radius=0.5+0.25),
                          output_fn=PiecewiseLinear(lower_bound=0.0,upper_bound=1.0),
                          measure_maps=False)

topo.sim['LGNOff']=CFSheet(nominal_density=24.0,
                           nominal_bounds=BoundingBox(radius=0.5+0.25),
                           output_fn=PiecewiseLinear(lower_bound=0.0,upper_bound=1.0),
                           measure_maps=False)

topo.sim['V1Exc'] =  LISSOM(nominal_density=locals().get('default_density',48.0),
                            nominal_bounds=BoundingBox(radius=0.5),tsettle=15,
                            output_fn=HomeostaticMaxEnt(a_init=14.5, b_init=-4, eta=0.0002, mu=0.01))

topo.sim['V1Inh'] =  LISSOM(nominal_density=locals().get('default_density',48.0),
                            nominal_bounds=BoundingBox(radius=0.5),tsettle=14,
                            output_fn=Sigmoid(r=14.5, k=-4)) # Should this be homeostatic?



# connection initialization

# DoG weights for the LGN
centerg = topo.pattern.basic.Gaussian(
    size=0.07385,aspect_ratio=1.0,output_fn=DivisiveNormalizeL1())

surroundg = topo.pattern.basic.Gaussian(
    size=0.2954, aspect_ratio=1.0,output_fn=DivisiveNormalizeL1())

on_weights  = Composite(generators=[centerg,surroundg],operator=numpy.subtract)
off_weights = Composite(generators=[surroundg,centerg],operator=numpy.subtract)

# Retina -> LGN

## LGN ON channel

topo.sim.connect('Retina','LGNOn',delay=0.05,
                 connection_type=SharedWeightCFProjection,strength=2.33,
                 nominal_bounds_template=BoundingBox(radius=0.375),name='Afferent',
                 weights_generator=on_weights)

topo.sim.connect('Retina','LGNOff',delay=0.05,
                 connection_type=SharedWeightCFProjection,strength=2.33,
                 nominal_bounds_template=BoundingBox(radius=0.375),name='Afferent',
                 weights_generator=off_weights)

## LGN -> V1 Exc
topo.sim.connect('LGNOn','V1Exc',delay=0.05,dest_port=('Activity','JointNormalize', 'Afferent'),
                 connection_type=CFProjection,strength=1.0,name='LGNOnAfferent',
                 weights_generator=topo.pattern.basic.Composite(operator=numpy.multiply, 
                  generators=[Gaussian(aspect_ratio=1.0, size=2*0.27083),
                              topo.pattern.random.UniformRandom()]),
                 nominal_bounds_template=BoundingBox(radius=0.27083),learning_rate=(BoundedNumber(bounds=(0.137,None),generator=
                 ExponentialDecay(starting_value = locals().get('LGNOnafferent_lr',0.9590), # Why does learning rate need to be higher?
                 time_constant=3200/num_inputs))))

topo.sim.connect('LGNOff','V1Exc',delay=0.05,dest_port=('Activity','JointNormalize', 'Afferent'),
                 connection_type=CFProjection,strength=1.0,name='LGNOffAfferent',
                 weights_generator=topo.pattern.basic.Composite(operator=numpy.multiply, 
                                   generators=[Gaussian(aspect_ratio=1.0, size=2*0.27083),
                                               topo.pattern.random.UniformRandom()]),
                 nominal_bounds_template=BoundingBox(radius=0.27083),learning_rate=(BoundedNumber(bounds=(0.137,None),generator=
                  ExponentialDecay(starting_value = locals().get('LGNOffafferent_lr',0.9590),
                  time_constant=3200/num_inputs))))


# Intra V1  connections

topo.sim.connect('V1Exc','V1Exc', delay=0.05,
                 connection_type=CFProjection,strength = 0.7, name='LateralExcitatory_local',
                 weights_generator=topo.pattern.basic.Gaussian(aspect_ratio=1.0, size=0.04),
                 nominal_bounds_template=BoundingBox(radius=0.03),
                 learning_rate=0)

topo.sim.connect('V1Exc','V1Exc', delay=0.05,
                 connection_type=CFProjection,strength = 0.1, name='LateralExcitatory',
                 weights_generator=Composite(operator=numpy.multiply, 
                     generators=[Gaussian(aspect_ratio=1.0, size=2*0.22917),
                                 topo.pattern.random.UniformRandom()]),
                 nominal_bounds_template=BoundingBox(radius=0.229),learning_rate=1.8087)
              
topo.sim.connect('V1Exc','V1Inh', delay=0.05,
                 connection_type=CFProjection,strength = 0.6, name='V1Exc_to_V1Inh_local',
                 weights_generator=topo.pattern.basic.Gaussian(aspect_ratio=1.0, size=0.04),
                 nominal_bounds_template = BoundingBox(radius=0.03),learning_rate=0)

topo.sim.connect('V1Exc','V1Inh', delay=0.05,
                 connection_type=CFProjection,strength = 1.0, name='V1Exc_to_V1Inh',
                 weights_generator=Composite(operator=numpy.multiply, 
                     generators=[Gaussian(aspect_ratio=1.0, size=2*0.22917),
                                 topo.pattern.random.UniformRandom()]),
                 nominal_bounds_template=BoundingBox(radius=0.229),learning_rate=1.8087)
            

topo.sim.connect('V1Inh','V1Exc', delay=0.05,
                 connection_type=CFProjection,strength=-0.35, name='V1Inh_to_V1Exc',
                 weights_generator=topo.pattern.basic.Gaussian(aspect_ratio=1.0, size=0.04),
                 nominal_bounds_template = BoundingBox(radius=0.03),learning_rate=0)

topo.sim.connect('V1Inh','V1Inh', delay=0.05,
                 connection_type=CFProjection,strength=-0.35, name='V1Inh_to_V1Inh',
                 weights_generator=topo.pattern.basic.Gaussian(aspect_ratio=1.0, size=0.04),
                 nominal_bounds_template = BoundingBox(radius=0.03),learning_rate=0)


