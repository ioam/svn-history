"""
A LISSOM-based direction map (with ON/OFF channels).

Under construction: moving away from the '4 eyes' approach.

$Id$
"""
__version__='$Revision$'


from math import pi, sqrt
import copy
import numpy

from topo import learningfn,numbergen,outputfn,pattern,projection,responsefn,sheet 

import topo.learningfn.optimized
import topo.learningfn.projfn 
import topo.outputfn.optimized 
import topo.pattern.random
import topo.responsefn.optimized 
import topo.sheet.lissom
import topo.sheet.optimized


### Specify weight initialization, response function, and learning function
projection.CFProjection.cf_shape = pattern.Disk(smoothing=0.0)
projection.CFProjection.weights_generator = pattern.Constant()
projection.CFProjection.response_fn=responsefn.optimized.CFPRF_DotProduct_opt()
projection.CFProjection.learning_fn=learningfn.optimized.CFPLF_Hebbian_opt()
projection.CFProjection.weights_output_fn=outputfn.optimized.CFPOF_DivisiveNormalizeL1_opt()
projection.SharedWeightCFProjection.response_fn=responsefn.optimized.CFPRF_DotProduct_opt()


## ALERT: clean up then move into topo/
from topo import param
class Translator(pattern.PatternGenerator):
    """
    PatternGenerator that translates another PatternGenerator over
    time.

    This PatternGenerator will create a series of episodes, where in
    each episode the underlying generator is moved in a fixed
    direction at a fixed speed.  To begin an episode, the Translator's
    x, y, and direction are evaluated (e.g. from random
    distributions), and the underlying generator is then drawn at
    those values plus changes over time that are determined by the
    speed.  The orientation of the underlying generator should be set
    to 0 to get motion perpendicular to the generator's orientation
    (which is typical).
    """
    
    generator = param.ClassSelector(default=pattern.Gaussian(),
        class_=pattern.PatternGenerator,doc="""Pattern to be translated.""")

    direction = param.Number(default=0.0,bounds=(-pi,pi),doc="""
        The direction in which the pattern should move, in radians.""")
    
    speed = param.Number(default=0.01,bounds=(0.0,None),doc="""
        The speed with which the pattern should move,
        in sheet coordinates per simulation time unit.""")

    reset_period = param.Number(default=1,bounds=(0.0,None),doc="""
        Period between generating each new translation episode.""")

    # ALERT: Not yet implemented
    episode_interval = param.Number(default=0,doc="""
        Interval between successive translation episodes.
        
        If nonzero, the episode_separator pattern is presented for
        this amount of simulation time after each episode, e.g. to
        allow processing of the previous episode to complete.""")

    episode_separator = param.ClassSelector(default=pattern.Constant(scale=0.0),
         class_=pattern.PatternGenerator,doc="""
         Pattern to display during the episode_interval, if any.
         The default is a blank pattern.""")
                                                                              

    def _advance_params(self):
        """
        Explicitly generate new values for these parameters only
        when appropriate.
        """
        for param in ['x','y','direction']:
            self.force_new_dynamic_value(param)
        self.last_time = topo.sim.time()

       
    def __init__(self,**params):
        super(Translator,self).__init__(**params)
        self._advance_params()

        
    def __call__(self,**params):
        p=ParamOverrides(self,params)
        
        if topo.sim.time() >= self.last_time + p.reset_period:
            self._advance_params()

        # Access parameter values without giving them new values
        x = self.inspect_value('x')
        y = self.inspect_value('y')
        direction = self.inspect_value('direction')

        # compute how much time elapsed from the last reset
        # float(t) required because time could be e.g. gmpy.mpq
        t = float(topo.sim.time()-self.last_time)

        ## CEBALERT: mask gets applied twice, both for the underlying
        ## generator and for this one.  (leads to redundant
        ## calculations in current lissom_oo_or usage, but will lead
        ## to problems/limitations in the future).
        return p.generator(
            xdensity=p.xdensity,ydensity=p.ydensity,bounds=p.bounds,
            x=x+t*cos(direction)*p.speed+p.generator.x,
            y=y+t*sin(direction)*p.speed+p.generator.y,
            orientation=(direction-pi/2)+p.generator.orientation)




### Input patterns
num_inputs=1

# Number of separate delay lines in the LGN
num_lags=4
input_period=num_lags # By default

input = Translator(
    x=numbergen.UniformRandom(lbound=-0.75,
                              ubound=0.75,seed=12),
    y=numbergen.UniformRandom(lbound=-0.75,
                              ubound=0.75,seed=34),
    direction=numbergen.UniformRandom(lbound=-pi,
                                      ubound=pi,seed=99),
    generator=pattern.Gaussian(size=0.088388, aspect_ratio=4.66667, scale=1.0,
                               bounds=sheet.BoundingBox(radius=0.8)),
    reset_period=input_period,
    speed=0.04)


### Sheets
retina_density = locals().get('default_retina_density',24.0)
lgn_density = locals().get('default_lgn_density',24.0)

topo.sim['Retina']=sheet.GeneratorSheet(
    nominal_density=retina_density,period=1.0,phase=0.05,
    nominal_bounds=sheet.BoundingBox(radius=0.5+0.25+0.375),
    input_generator=input)


topo.sim['LGNOn']=sheet.CFSheet(
    nominal_density=lgn_density,
    nominal_bounds=sheet.BoundingBox(radius=0.5+0.25),
    output_fn=outputfn.PiecewiseLinear(lower_bound=0.0,upper_bound=1.0),
    measure_maps=False)

topo.sim['LGNOff']=sheet.CFSheet(
    nominal_density=lgn_density,
    nominal_bounds=sheet.BoundingBox(radius=0.5+0.25),
    output_fn=outputfn.PiecewiseLinear(lower_bound=0.0,upper_bound=1.0),
    measure_maps=False)

topo.sim['V1'] = sheet.lissom.LISSOM(
    nominal_density=locals().get('default_density',48.0),
    nominal_bounds=sheet.BoundingBox(radius=0.5),tsettle=9,
    output_fn=outputfn.PiecewiseLinear(lower_bound=0.083,upper_bound=0.633),
    joint_norm_fn=sheet.optimized.compute_joint_norm_totals_opt)



### Connections

# DoG weights for the LGN
centerg   = pattern.Gaussian(size=0.07385,aspect_ratio=1.0,
                             output_fn=outputfn.optimized.DivisiveNormalizeL1())
surroundg = pattern.Gaussian(size=0.29540,aspect_ratio=1.0,
                             output_fn=outputfn.optimized.DivisiveNormalizeL1())

on_weights = pattern.Composite(
    generators=[centerg,surroundg],operator=numpy.subtract)

off_weights = pattern.Composite(
    generators=[surroundg,centerg],operator=numpy.subtract)

    
topo.sim.connect('Retina','LGNOn',delay=0.05,
                 connection_type=projection.SharedWeightCFProjection,strength=2.38,
                 nominal_bounds_template=sheet.BoundingBox(radius=0.375),
                 name='Afferent',weights_generator=on_weights)

topo.sim.connect('Retina','LGNOff',delay=0.05,
                 connection_type=projection.SharedWeightCFProjection,strength=2.38,
                 nominal_bounds_template=sheet.BoundingBox(radius=0.375),
                 name='Afferent',weights_generator=off_weights)


for i in xrange(num_lags):

    topo.sim.connect(
        'LGNOn','V1',delay=0.05+i,
        dest_port=('Activity','JointNormalize', 'Afferent'),
        connection_type=projection.CFProjection,strength=1.0,
        name='LGNOnAfferent'+str(i),
        nominal_bounds_template=sheet.BoundingBox(radius=0.27083),
        learning_rate=0.9590/2,
        weights_generator=pattern.random.GaussianCloud(gaussian_size=2*0.27083))

    topo.sim.connect(
        'LGNOff','V1',delay=0.05+i,
        dest_port=('Activity','JointNormalize', 'Afferent'),
        connection_type=projection.CFProjection,strength=1.0,
        name='LGNOffAfferent'+str(i),
        nominal_bounds_template=sheet.BoundingBox(radius=0.27083),
        learning_rate=0.9590/2,
        weights_generator=pattern.random.GaussianCloud(gaussian_size=2*0.27083))



topo.sim.connect(
    'V1','V1',delay=0.05,name='LateralExcitatory',
    connection_type=projection.CFProjection,strength=0.9,
    nominal_bounds_template=sheet.BoundingBox(radius=0.10417),
    weights_generator=pattern.random.GaussianCloud(gaussian_size=2*0.10417),
    learning_rate=2.55528) 
            
topo.sim.connect(
    'V1','V1',delay=0.05,name='LateralInhibitory',
    connection_type=projection.CFProjection,strength=-0.9,
    weights_generator=pattern.random.GaussianCloud(gaussian_size=2*0.22917),
    nominal_bounds_template=sheet.BoundingBox(radius=0.22917),
    learning_rate=1.80873)  



### Actions scheduled to occur as the simulation proceeds.
sheet.lissom.schedule_events("topo.sim['V1']",st=input_period/num_inputs,aff_name="Afferent")


### Default locations for model editor
topo.sim.grid_layout([[None, 'V1'],
                      [('LGNOn' ) for i in xrange(num_lags)],
                      [('LGNOff') for i in xrange(num_lags)],
                      [('Retina') for i in xrange(num_lags)]],
                     xstart=150, xstep=300)


### Set up appropriate defaults for analysis

# Measure feature maps based on unthresholded initial response for
# speed and reliability.
# Appropriate for original DR model; will need updating for 
# new one.
from topo.analysis.featureresponses import MeasureResponseCommand
MeasureResponseCommand.duration=4.0
MeasureResponseCommand.apply_output_fn=True
