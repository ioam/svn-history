"""
A LISSOM-based direction map (with ON/OFF channels).

Under construction: moving away from the '4 eyes' approach.

$Id$
"""
__version__='$Revision$'


from math import pi, sqrt
import copy
import numpy

from topo import learningfn,numbergen,outputfn,pattern,projection,responsefn,sheet 

import topo.learningfn.optimized
import topo.learningfn.projfn 
import topo.outputfn.optimized 
import topo.pattern.random
import topo.responsefn.optimized 
import topo.sheet.lissom
import topo.sheet.optimized


### Specify weight initialization, response function, and learning function
projection.CFProjection.cf_shape = pattern.Disk(smoothing=0.0)
projection.CFProjection.weights_generator = pattern.Constant()
projection.CFProjection.response_fn=responsefn.optimized.CFPRF_DotProduct_opt()
projection.CFProjection.learning_fn=learningfn.optimized.CFPLF_Hebbian_opt()
projection.CFProjection.weights_output_fn=outputfn.optimized.CFPOF_DivisiveNormalizeL1_opt()
projection.SharedWeightCFProjection.response_fn=responsefn.optimized.CFPRF_DotProduct_opt()


## ALERT: clean up then move into topo/
from topo import param
class Translator(pattern.PatternGenerator):
    """
    PatternGenerator that moves another PatternGenerator over time.
    
    To create a pattern at a new location, asks the underlying
    PatternGenerator to create a new pattern at a location translated
    by an amount based on the global time.
    """

    generator = param.ClassSelector(default=pattern.Constant(scale=0.0),
        class_=pattern.PatternGenerator,doc="""Pattern to be translated.""")

##     # ALERT: currently, direction parameter is ignored (and is
##     # computed from the orientation)
##     direction = param.Number(default=0,bounds=(-pi,pi),doc="""
##         The direction in which the pattern should move, in radians.""")
    
    speed = param.Number(default=1,bounds=(0.0,None),doc="""
        The speed with which the pattern should move,
        in sheet coordinates per simulation time unit.""")
    
    reset_period = param.Number(
        default=1,bounds=(0.0,None),doc="""
        Period between requesting new (x,y) coordinates from the generator.""")

##     inter_translation_interval = param.Number(
##         default=0,doc="""Interval between translations.""")

##     inter_translation_pattern = param.ClassSelector(
##         default=pattern.Constant(scale=0.0),
##         class_=pattern.PatternGenerator,
##         doc="""Pattern to display during inter_translation_interval.""")
                                                                              

    # CB cf Composite's advance_pattern_generators
    def _advance_generator(self):
        # CEBALERT: should advance all parameters 
        for param in ['x','y','scale','orientation']:
            self.generator.force_new_dynamic_value(param)
        

    def __init__(self,**params):
        super(Translator,self).__init__(**params)
        #self.orientation = params.get('orientation',self.orientation)
        # ALERT: going to replace this temporary hack when improving
        # the whole 'last_time' mechanism
        self.last_time = -self.reset_period
        
    def __call__(self,**params):
        """Construct new pattern out of the underlying one."""
        p=ParamOverrides(self,params)
        
        # CB: are the float() calls required because the comparisons
        # involving FixedPoint fail otherwise? Or for some other
        # reason?
        if (float(topo.sim.time()) >= self.last_time + self.reset_period):
        
            self.last_time += self.reset_period
                
            # time to reset the parameter
            (self.x, self.y, self.scale, self.orientation) = (p.generator.x,p.generator.y,p.generator.scale,p.generator.orientation)
            self._advance_generator()

            #self.direction = ((pi +self.inspect_value("orientation") + pi/2.0) % (2*pi)) - pi

        # compute how much time elapsed from the last reset
        t = float(topo.sim.time())-self.last_time

        ## CEBALERT: mask gets applied twice, both for the underlying
        ## generator and for this one.  (leads to redundant
        ## calculations in current lissom_oo_or usage, but will lead
        ## to problems/limitations in the future).
        
        return p.generator(
            xdensity=p.xdensity,ydensity=p.ydensity,bounds=p.bounds,
            x=self.x+t*cos(self.orientation+pi/2)*self.speed,
            y=self.y+t*sin(self.orientation+pi/2)*self.speed,
            orientation=self.orientation)




### Input patterns
num_inputs=1

# Number of separate delay lines in the LGN
num_lags=4
input_period=num_lags # By default

input = Translator(
    reset_period=input_period,
    speed=0.04,
    generator=pattern.Gaussian(x=numbergen.UniformRandom(lbound=-0.75,
                                                         ubound=0.75,seed=12),
                               y=numbergen.UniformRandom(lbound=-0.75,
                                                         ubound=0.75,seed=34),
                               orientation=numbergen.UniformRandom(lbound=-pi,
                                                                   ubound=pi,seed=99),
                               size=0.088388, aspect_ratio=4.66667, scale=1.0,
                               bounds=sheet.BoundingBox(radius=0.8)))

### Sheets
retina_density = locals().get('default_retina_density',24.0)
lgn_density = locals().get('default_lgn_density',24.0)

topo.sim['Retina']=sheet.GeneratorSheet(
    nominal_density=retina_density,period=1.0,phase=0.05,
    nominal_bounds=sheet.BoundingBox(radius=0.5+0.25+0.375),
    input_generator=input)


topo.sim['LGNOn']=sheet.CFSheet(
    nominal_density=lgn_density,
    nominal_bounds=sheet.BoundingBox(radius=0.5+0.25),
    output_fn=outputfn.PiecewiseLinear(lower_bound=0.0,upper_bound=1.0),
    measure_maps=False)

topo.sim['LGNOff']=sheet.CFSheet(
    nominal_density=lgn_density,
    nominal_bounds=sheet.BoundingBox(radius=0.5+0.25),
    output_fn=outputfn.PiecewiseLinear(lower_bound=0.0,upper_bound=1.0),
    measure_maps=False)

topo.sim['V1'] = sheet.lissom.LISSOM(
    nominal_density=locals().get('default_density',48.0),
    nominal_bounds=sheet.BoundingBox(radius=0.5),tsettle=9,
    output_fn=outputfn.PiecewiseLinear(lower_bound=0.083,upper_bound=0.633),
    joint_norm_fn=sheet.optimized.compute_joint_norm_totals_opt)



### Connections

# DoG weights for the LGN
centerg   = pattern.Gaussian(size=0.07385,aspect_ratio=1.0,
                             output_fn=outputfn.optimized.DivisiveNormalizeL1())
surroundg = pattern.Gaussian(size=0.29540,aspect_ratio=1.0,
                             output_fn=outputfn.optimized.DivisiveNormalizeL1())

on_weights = pattern.Composite(
    generators=[centerg,surroundg],operator=numpy.subtract)

off_weights = pattern.Composite(
    generators=[surroundg,centerg],operator=numpy.subtract)

    
topo.sim.connect('Retina','LGNOn',delay=0.05,
                 connection_type=projection.SharedWeightCFProjection,strength=2.38,
                 nominal_bounds_template=sheet.BoundingBox(radius=0.375),
                 name='Afferent',weights_generator=on_weights)

topo.sim.connect('Retina','LGNOff',delay=0.05,
                 connection_type=projection.SharedWeightCFProjection,strength=2.38,
                 nominal_bounds_template=sheet.BoundingBox(radius=0.375),
                 name='Afferent',weights_generator=off_weights)


for i in xrange(num_lags):

    topo.sim.connect(
        'LGNOn','V1',delay=0.05+i,
        dest_port=('Activity','JointNormalize', 'Afferent'),
        connection_type=projection.CFProjection,strength=1.0,
        name='LGNOnAfferent'+str(i),
        nominal_bounds_template=sheet.BoundingBox(radius=0.27083),
        learning_rate=0.9590/2,
        weights_generator=pattern.random.GaussianCloud(gaussian_size=2*0.27083))

    topo.sim.connect(
        'LGNOff','V1',delay=0.05+i,
        dest_port=('Activity','JointNormalize', 'Afferent'),
        connection_type=projection.CFProjection,strength=1.0,
        name='LGNOffAfferent'+str(i),
        nominal_bounds_template=sheet.BoundingBox(radius=0.27083),
        learning_rate=0.9590/2,
        weights_generator=pattern.random.GaussianCloud(gaussian_size=2*0.27083))



topo.sim.connect(
    'V1','V1',delay=0.05,name='LateralExcitatory',
    connection_type=projection.CFProjection,strength=0.9,
    nominal_bounds_template=sheet.BoundingBox(radius=0.10417),
    weights_generator=pattern.random.GaussianCloud(gaussian_size=2*0.10417),
    learning_rate=2.55528) 
            
topo.sim.connect(
    'V1','V1',delay=0.05,name='LateralInhibitory',
    connection_type=projection.CFProjection,strength=-0.9,
    weights_generator=pattern.random.GaussianCloud(gaussian_size=2*0.22917),
    nominal_bounds_template=sheet.BoundingBox(radius=0.22917),
    learning_rate=1.80873)  



### Actions scheduled to occur as the simulation proceeds.
sheet.lissom.schedule_events("topo.sim['V1']",st=input_period/num_inputs,aff_name="Afferent")


### Default locations for model editor
topo.sim.grid_layout([[None, 'V1'],
                      [('LGNOn' ) for i in xrange(num_lags)],
                      [('LGNOff') for i in xrange(num_lags)],
                      [('Retina') for i in xrange(num_lags)]],
                     xstart=150, xstep=300)


### Set up appropriate defaults for analysis

# Measure feature maps based on unthresholded initial response for
# speed and reliability.
# Appropriate for original DR model; will need updating for 
# new one.
from topo.analysis.featureresponses import MeasureResponseCommand
MeasureResponseCommand.duration=4.0
MeasureResponseCommand.apply_output_fn=True
