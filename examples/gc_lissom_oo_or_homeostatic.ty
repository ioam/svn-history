""" 
Simulation for development of stable orientation maps based on
lissom_oo_or_noshrinking.ty (see Chapman et. al, J. Neurosci
16(20):6443, 1996).  The development is also robust to changes in the
input (e.g., number of Gaussians in the retinal input or brightness of
each Gaussian).

Afferent projection activities for individual units are scaled based
on maintaining a target average afferent activity. The learning rates
of afferent projections are also scaled in order to maintain the
overall rate of learning despite changes in LGN activity.

The sigmoidal output function for V1 is regulated using the Triesch
rule (Jochen Triesch, ICANN 2005, LNCS 3696 pp.65-70), which maintains
stable activity in V1 given a target average activity. 

The current script is set up as a debug version for plotting sheet and
projection attributes throughout development.  If the statistics of
the input (but not the contrast) are changed, then the afferent_target
and the average V1 activity need to be changed in order to maintain
similar responses in V1.

$Id: lissom_oo_or_homeostatic.ty 7925 2008-02-11 10:36:10Z judelaw $
"""
__version__='$Revision: 7925 $'

import fixedpoint
import numpy

from math import pi, sqrt
from fixedpoint import FixedPoint

import topo.patterns.basic
import topo.patterns.random

from topo.patterns.basic import Gaussian
from topo.sheets.lissom import JointScaling, LISSOM
from topo.sheets.generatorsheet import GeneratorSheet
from topo.projections.basic import CFProjection, SharedWeightCFProjection
from topo.responsefns.optimized import CFPRF_DotProduct_opt
from topo.base.cf import CFSheet, CFPLF_PluginScaled
from topo.base.boundingregion import BoundingBox
from topo.learningfns.optimized import CFPLF_Hebbian_opt
from topo.outputfns.optimized import CFPOF_DivisiveNormalizeL1_opt
from topo.outputfns.basic import PiecewiseLinear, DivisiveNormalizeL1, PipelineOF, IdentityOF, ActivityAveragingOF, AttributeTrackingOF, Sigmoid, HalfRectify, HomeostaticMaxEnt
from contrib.mycommands import SimpleHomeo
from topo.misc.numbergenerators import UniformRandom
from topo.misc.numbergenerators import UniformRandom, BoundedNumber, ExponentialDecay
from topo.patterns.image import Image

####Input type###
type_input=locals().get('ti',"Gaussian")
scale = locals().get('scale', 1.0)

rand_seedx = locals().get('seedx', 12) #For running differently seeded simulations
rand_seedy = locals().get('seedy', 36)
rand_seedo = locals().get('seedo', 54)
rand_weights=locals().get('seedweights', 500)

if type_input=="Gaussian":
    input_type=Gaussian
    num_inputs=locals().get('ni',2)
    inputs=[input_type(x=UniformRandom(lbound=-0.75,ubound=0.75,seed=rand_seedx+i),
                       y=UniformRandom(lbound=-0.75,ubound=0.75,seed=rand_seedy+i),
                       orientation=UniformRandom(lbound=-pi,ubound=pi,seed=rand_seedo+i),
                       size=0.088388, aspect_ratio=4.66667, scale=scale, bounds=BoundingBox(radius=1.125))
            for i in xrange(num_inputs)]
    
    combined_inputs = topo.patterns.basic.SeparatedComposite(min_separation=0,generators=inputs)
    
elif type_input=="Natural":
    
    input_type=topo.patterns.image.Image
    image_filenames=["images/shouval/combined%02d.png"%(i+1) for i in xrange(25)]
    inputs=[input_type(filename=f,
                       size=10.0,  #size_normalization='original',(size=10.0)
                       x=UniformRandom(lbound=-0.75,ubound=0.75,seed=rand_seedx),
                       y=UniformRandom(lbound=-0.75,ubound=0.75,seed=rand_seedy),
                       orientation=UniformRandom(lbound=-pi,ubound=pi,seed=rand_seedo))
		for f in image_filenames]

    combined_inputs =topo.patterns.basic.Selector(generators=inputs)

elif type_input=="NoisyDisks":
    
    input_type=topo.patterns.basic.Composite
    inputs=[input_type(operator=numpy.multiply,
                       generators=[topo.patterns.basic.Disk(x=UniformRandom(lbound=-2.125,ubound=2.125,seed=rand_seedx),
                                                            y=UniformRandom(lbound=-2.125,ubound=2.125,seed=rand_seedy),
                                                            size=2.0, aspect_ratio=1.0, scale=1.0,
                                                            offset=0.5,
                                                            bounds=BoundingBox(radius=1.125), smoothing=0.1),
                                   topo.patterns.random.UniformRandom(offset=locals().get('rand_offset',0.5), scale=locals().get('rand_scale',0.5))])]
            
    combined_inputs =topo.patterns.basic.Selector(generators=inputs)

elif type_input=="Disks":
    
    input_type=topo.patterns.basic.Disk
    inputs=[input_type(x=UniformRandom(lbound=-2.125,ubound=2.125,seed=rand_seedx),
                       y=UniformRandom(lbound=-2.125,ubound=2.125,seed=rand_seedy),
                       size=2.0, aspect_ratio=1.0, scale=1.0,
                       offset=0.5,
                       bounds=BoundingBox(radius=1.125), smoothing=0.1)]
            
    combined_inputs =topo.patterns.basic.Selector(generators=inputs)

elif type_input=="NoisyDiskstoNatural":

    disks_input_type=topo.patterns.basic.Composite
    disks_inputs=[disks_input_type(operator=numpy.multiply,
                       generators=[topo.patterns.basic.Disk(x=UniformRandom(lbound=-2.125,ubound=2.125,seed=rand_seedx),
                                                            y=UniformRandom(lbound=-2.125,ubound=2.125,seed=rand_seedy),
                                                            size=2.0, aspect_ratio=1.0, scale=1.0,
                                                            offset=0.5,
                                                            bounds=BoundingBox(radius=1.125), smoothing=0.1),
                                   topo.patterns.random.UniformRandom(offset=locals().get('rand_offset',0.0), scale=locals().get('rand_scale',0.5))])]
            
    disks_combined_inputs =topo.patterns.basic.Selector(generators=disks_inputs)
    
    natural_input_type=topo.patterns.image.Image
    image_filenames=["images/shouval/combined%02d.png"%(i+1) for i in xrange(25)]
    natural_inputs=[natural_input_type(filename=f,
                       size=10.0,  #size_normalization='original',(size=10.0)
                       x=UniformRandom(lbound=-0.75,ubound=0.75,seed=rand_seedx),
                       y=UniformRandom(lbound=-0.75,ubound=0.75,seed=rand_seedy),
                       orientation=UniformRandom(lbound=-pi,ubound=pi,seed=rand_seedo))
		for f in image_filenames]

    natural_combined_inputs =topo.patterns.basic.Selector(generators=natural_inputs)

#Units to track for debugging
V1_units=[(0, 47), (12, 36),(24, 24), (36, 12),(47, 0)]
LGN_units=[(0,23), (6,18), (12,12), (18,6), (23,0)]

#Smoothing value for exponential averaging
smoothing=locals().get('smoothing',0.999)

#Output functions: Sheets
#LGN
LGN_on_output_fn=HalfRectify()
LGN_off_output_fn=HalfRectify()

#Target for average total afferent projection activity 
afferent_target = locals().get('afferent_target',0.045)

#V1
triesch=locals().get('triesch', True)
if triesch==True:
    print "Triesh\n"
    Attrib_Tracker=AttributeTrackingOF(object="topo.sim['V1']", attrib_names=['x_avg', 'sf', 'lr_sf', 'scaled_x_avg'], units=V1_units)
    HE=HomeostaticMaxEnt(smoothing=smoothing, eta=locals().get('eta',0.002), a_init=locals().get('a_init',14.5),
                         b_init=locals().get('b_init',-5.5), mu=afferent_target/locals().get('ny',5))
    V1_Tracker=AttributeTrackingOF(object=HE, attrib_names=['a', 'b','y_avg'], units=V1_units, step=1)
    V1_OF=PipelineOF(output_fns=[Attrib_Tracker, HE, V1_Tracker])
elif simple==True:
    print "Simple\n"
    Attrib_Tracker=AttributeTrackingOF(object="topo.sim['V1']", attrib_names=['x_avg', 'sf', 'lr_sf', 'scaled_x_avg'], units=V1_units)
    HE=SimpleHomeo(smoothing=smoothing, eta=locals().get('eta',0.002), a_init=locals().get('a_init',14.5),
                         b_init=locals().get('b_init',-5.5), mu=afferent_target/locals().get('ny',5))
    V1_Tracker=AttributeTrackingOF(object=HE, attrib_names=['a', 'b','y_avg'], units=V1_units, step=1)
    V1_OF=PipelineOF(output_fns=[Attrib_Tracker, HE, V1_Tracker])        
else:
    Attrib_Tracker=AttributeTrackingOF(object="topo.sim['V1']", attrib_names=['x_avg', 'sf','lr_sf', 'scaled_x_avg'], units=V1_units)
    HE=Sigmoid(r=locals().get('a_init',14.5),k=locals().get('b_init',-5.5))
    AV=ActivityAveragingOF(smoothing=smoothing,step=1)
    V1_Tracker=AttributeTrackingOF(object=AV, attrib_names=['x_avg'], units=V1_units, step=1)
    V1_OF=PipelineOF(output_fns=[Attrib_Tracker, HE, AV, V1_Tracker])
    
#Output Functions: Projections

#Debugging
#LGNOnAfferent
LGNOn_Avg=ActivityAveragingOF(smoothing=smoothing,step=1)
LGNOn_Tracker=AttributeTrackingOF(object=LGNOn_Avg, attrib_names=['x_avg'], units=V1_units, step=1)
LGNOn_OF = PipelineOF(output_fns=[LGNOn_Avg, LGNOn_Tracker])

LGNOn_Avg_d=ActivityAveragingOF(smoothing=smoothing,step=1)
LGNOn_Tracker_d=AttributeTrackingOF(object=LGNOn_Avg_d, attrib_names=['x_avg'], units=V1_units, step=1)
LGNOn_OF_debug = PipelineOF(output_fns=[LGNOn_Avg_d, LGNOn_Tracker_d])
#LGNOffAfferent
LGNOff_Avg=ActivityAveragingOF(smoothing=smoothing,step=1)
LGNOff_Tracker=AttributeTrackingOF(object=LGNOff_Avg, attrib_names=['x_avg'], units=V1_units, step=1)
LGNOff_OF = PipelineOF(output_fns=[LGNOff_Avg, LGNOff_Tracker])

LGNOff_Avg_d=ActivityAveragingOF(smoothing=smoothing,step=1)
LGNOff_Tracker_d=AttributeTrackingOF(object=LGNOff_Avg_d, attrib_names=['x_avg'], units=V1_units, step=1)
LGNOff_OF_debug = PipelineOF(output_fns=[LGNOff_Avg_d, LGNOff_Tracker_d])
#LateralExcitatory
LatEx_Avg=ActivityAveragingOF(initial_average=0.0,smoothing=smoothing,step=1)
LatEx_Tracker=AttributeTrackingOF(object=LatEx_Avg, attrib_names=['x_avg'], units=V1_units, step=1)
LatEx_OF = PipelineOF(output_fns=[LatEx_Avg, LatEx_Tracker])

#LateralInhibitory
LatIn_Avg=ActivityAveragingOF(initial_average=0.0,smoothing=smoothing,step=1)
LatIn_Tracker = AttributeTrackingOF(object=LatIn_Avg, attrib_names=['x_avg'], units=V1_units, step=1)
LatIn_OF = PipelineOF(output_fns=[LatIn_Avg, LatIn_Tracker])


# Specify weight initialization, response function, and learning function
numpy.random.seed((rand_weights,rand_weights))

CFProjection.weights_shape = topo.patterns.basic.Disk(smoothing=0.0)
CFProjection.weights_generator = topo.patterns.basic.Constant()
CFProjection.response_fn=CFPRF_DotProduct_opt()
CFProjection.learning_fn=CFPLF_Hebbian_opt()
CFProjection.weights_output_fn=CFPOF_DivisiveNormalizeL1_opt()
SharedWeightCFProjection.response_fn=CFPRF_DotProduct_opt()

# DoG weights for the LGN
centerg   = Gaussian(size=0.07385,aspect_ratio=1.0,output_fn=DivisiveNormalizeL1())
surroundg = Gaussian(size=0.29540,aspect_ratio=1.0,output_fn=DivisiveNormalizeL1())

on_weights = topo.patterns.basic.Composite(
    generators=[centerg,surroundg],operator=numpy.subtract)

off_weights = topo.patterns.basic.Composite(
    generators=[surroundg,centerg],operator=numpy.subtract)

#Function for generating Gaussian random initial weights
def gauss_rand(size):
    return topo.patterns.basic.Composite(operator=numpy.multiply, 
                                         generators=[Gaussian(aspect_ratio=1.0, size=size),
                                                     topo.patterns.random.UniformRandom()])

#Whether or not to use divisive weights normalization
norm=locals().get('norm',True)

if norm==False:
    pi=topo.base.cf.CFPOF_Plugin(single_cf_fn=topo.outputfns.basic.IdentityOF())
else:
    pi = None


###########################################
# build simulation

topo.sim['Retina']=GeneratorSheet(nominal_density=locals().get('default_retina_density',24.0),
                                  input_generator=combined_inputs,
                                  period=1.0, phase=0.05,
                                  nominal_bounds=BoundingBox(radius=0.5+0.25+0.375))

topo.sim['LGNOn']=LISSOM(nominal_density=24.0,
                          nominal_bounds=BoundingBox(radius=1.0+0.25),
                          output_fn=LGN_on_output_fn,tsettle=0,
                          measure_maps=False,divisive_constant=locals().get('dc',1.0))

topo.sim['LGNOff']=LISSOM(nominal_density=24.0,
                           nominal_bounds=BoundingBox(radius=1.0+0.25),
                           output_fn=LGN_off_output_fn,tsettle=0,
                           measure_maps=False,divisive_constant=locals().get('dc',1.0))

topo.sim['V1'] = JointScaling(nominal_density=locals().get('default_density',48.0),
                              nominal_bounds=BoundingBox(radius=0.5),tsettle=9,
                              plastic=True,output_fn=V1_OF,
                              post_initialization_weights_output_fn=pi,
                              target=afferent_target, smoothing=smoothing,target_lr=locals().get('target_lr',0.045))


topo.sim.connect('Retina','LGNOn',delay=FixedPoint("0.05"),
                 connection_type=SharedWeightCFProjection,strength=2.33,
                 nominal_bounds_template=BoundingBox(radius=0.375),name='Afferent',
                 weights_generator=on_weights)

topo.sim.connect('Retina','LGNOff',delay = FixedPoint("0.05"),
                 connection_type=SharedWeightCFProjection,strength=2.33,
                 nominal_bounds_template=BoundingBox(radius=0.375),name='Afferent',
                 weights_generator=off_weights)

topo.sim.connect('LGNOn','V1',delay=FixedPoint("0.05"), dest_port=('Activity','JointNormalize', 'Afferent'),
                 connection_type=CFProjection,
                 output_fn=LGNOn_OF,
                 learning_fn=CFPLF_PluginScaled(),
                 debug_output_fn=LGNOn_OF_debug,
                 strength=1.0,name='LGNOnAfferent',
                 weights_generator=gauss_rand(size=2*0.27083),
                 nominal_bounds_template=BoundingBox(radius=0.27083),
		 learning_rate=0.137*5)
               		 
topo.sim.connect('LGNOff','V1',delay=FixedPoint("0.05"), dest_port=('Activity','JointNormalize', 'Afferent'),
		 connection_type=CFProjection,
                 output_fn=LGNOff_OF,
                 learning_fn=CFPLF_PluginScaled(),
                 debug_output_fn=LGNOff_OF_debug,
                 strength=1.0,name='LGNOffAfferent',
                 weights_generator=gauss_rand(size=2*0.27083),
                 nominal_bounds_template=BoundingBox(radius=0.27083),
		 learning_rate=0.137*5)

topo.sim.connect('V1','V1',delay=FixedPoint("0.05"),name='LateralExcitatory',
                 connection_type=CFProjection,
                 output_fn=LatEx_OF,
                 strength=locals().get('LatExcStr',1.0),
                 weights_generator=topo.patterns.basic.Gaussian(aspect_ratio=1.0, size=0.04),
                 nominal_bounds_template=BoundingBox(radius=0.03),learning_rate=0.0) 

topo.sim.connect('V1','V1',delay=FixedPoint("0.05"),name='LateralInhibitory',
                 connection_type=CFProjection,
                 output_fn=LatIn_OF,
                 strength=-locals().get('LatInhStr',1.0),
                 weights_generator=gauss_rand(size=2*0.22917),
                 nominal_bounds_template=BoundingBox(radius=0.22917),learning_rate=1.80873)

import contrib.mycommands
contrib.mycommands.AddGC()

# default locations for model editor
topo.sim.grid_layout([[None,    'V1',     None],
                      ['LGNOn', None,     'LGNOff'],
                      [None,    'Retina', None]], xstart=150)

### Input pattern changes

if type_input=="NoisyDiskstoNatural":
    topo.sim['Retina'].input_generator=disks_combined_inputs
    new_afferent_target = locals().get('new_afferent_target',0.076)
    topo.sim.schedule_command(5000,'topo.sim["Retina"].input_generator=natural_combined_inputs')
    topo.sim.schedule_command(5000,'afferent_target=natural_afferent_target')



