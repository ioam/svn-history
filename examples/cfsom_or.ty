"""
Basic example of a SOM-based orientation map with ConnectionFields.

Contains a Retina (2D Gaussian generator) and a V1 sheet.
Each V1 neuron receives input from a limited-size square area on the
Retina, called its ConnectionField.

Does not currently match any published simulation, but will probably
be tailored to one in the future.

$Id$
"""
__version__='$Revision$'


from math import pi

from topo import learningfn,numbergen,outputfn,pattern,projection,responsefn,sheet

import topo.learningfn.projfn
import topo.responsefn.optimized


# Input patterns
num_inputs=2
input_type=pattern.Gaussian
inputs=[input_type(x=numbergen.UniformRandom(lbound=-0.5,ubound=0.5,seed=12+i),
                   y=numbergen.UniformRandom(lbound=-0.5,ubound=0.5,seed=34+i),
                   orientation=numbergen.UniformRandom(lbound=-pi,ubound=pi,
                                                       seed=56+i),
                   size=2*0.3*1.5/7.0, aspect_ratio=7.0/1.5,
                   bounds=sheet.BoundingBox(radius=0.8))
                for i in xrange(num_inputs)]

# Contents of retina
combined_inputs = pattern.SeparatedComposite(max_trials=75,min_separation=0.6,
                                             generators=inputs)


# Sheets, connections, and their parameters
topo.sim['Retina'] = sheet.GeneratorSheet(input_generator=combined_inputs,
                                          period=1.0,phase=0.05,nominal_density=30)

default_density=locals().get('default_density',50.0)

topo.sim['V1'] = sheet.CFSheet(
    nominal_density=default_density,
    output_fn = outputfn.KernelMax(
        density=default_density,
        kernel_radius=numbergen.ExponentialDecay(starting_value = 0.1,
                                                 time_constant=-10000/8.0,
                                                 base=0.5)))

topo.sim.connect('Retina','V1',name='Afferent',delay=0.05,
                 connection_type=projection.CFProjection,
                 learning_rate=numbergen.ExponentialDecay(starting_value = 0.5,
                                                          time_constant=-10000/8.0,
                                                          base=0.5),
                 weights_generator = pattern.Gaussian(),
                 nominal_bounds_template=sheet.BoundingBox(radius=0.1),
                 response_fn = responsefn.optimized.CFPRF_DotProduct_opt(),
                 learning_fn=learningfn.projfn.CFPLF_EuclideanHebbian())

