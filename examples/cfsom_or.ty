"""
Basic example of a SOM-based orientation map with ConnectionFields.

Contains a Retina (2D Gaussian generator) and a V1 (CFSOM) sheet.
Each V1 neuron receives input from a limited-size square area on the
Retina, called its ConnectionField.

Does not currently match any published simulation, but will probably
be tailored to one in the future.

$Id$
"""
__version__='$Revision$'

import numpy.oldnumeric.random_array as RandomArray

import topo.patterns.random
import topo.patterns.basic
 
from topo.base.boundingregion import BoundingBox
from topo.base.cf import CFProjection, CFSheet
from topo.base.parameterclasses import DynamicNumber
from topo.learningfns.som import CFPLF_HebbianSOM,CFPLF_EuclideanHebbian
from topo.outputfns.basic import KernelMax
from topo.responsefns.optimized import CFPRF_DotProduct_opt
from topo.sheets.cfsom import CFSOM
from topo.sheets.generatorsheet import GeneratorSheet
from topo.misc.numbergenerators import UniformRandom,ExponentialDecay

topo.sim.name = "cfsom_or"

# Weight seed
RandomArray.seed(500,500)

# Input patterns
num_inputs=2
input_type=topo.patterns.basic.Gaussian
inputs=[input_type(x=DynamicNumber(UniformRandom(lbound=-0.5,ubound=0.5,seed=12+i)),
                   y=DynamicNumber(UniformRandom(lbound=-0.5,ubound=0.5,seed=34+i)),
                   orientation=DynamicNumber(UniformRandom(lbound=-pi,ubound=pi,seed=56+i)),
                   size=2*0.3*1.5/7.0, aspect_ratio=7.0/1.5,
                   bounds=BoundingBox(radius=0.8))
                for i in xrange(num_inputs)]

# Contents of retina
combined_inputs = topo.patterns.basic.SeparatedComposite(min_separation=0.6,generators=inputs)

# Sheets, connections, and their parameters
topo.sim['Retina'] = GeneratorSheet(input_generator=combined_inputs,
                                    period=1.0,phase=0.05,nominal_density=30)

default_density=locals().get('default_density',50.0)

# Original version using CFSOM.
topo.sim['V1'] = CFSOM(nominal_density=default_density,
                       learning_length=10000,radius_0=0.1,alpha_0=0.5)

topo.sim.connect('Retina','V1',name='Afferent',delay=0.05,
                  connection_type=CFProjection,
                  weights_generator = topo.patterns.basic.Gaussian(),
                  nominal_bounds_template=BoundingBox(radius=0.1),
                  response_fn = CFPRF_DotProduct_opt(),
                  learning_fn=CFPLF_HebbianSOM())


# Experimental version using KernelMax and CFPLF_EuclideanHebbian
# instead of CFSOM.  Works the same but needs optimization.  Currently
# about 50% slower at least for the first 100 iterations, possibly
# because the neighborhood kernel is evaluated over the entire
# CFSheet, not just the local neighborhood.
#
#topo.sim['V1'] = CFSheet(
#    nominal_density=default_density,
#    output_fn = KernelMax(density=default_density,
#                          kernel_radius=ExponentialDecay(starting_value = 0.1,
#                                                         time_constant=-10000/8.0,
#                                                         base=0.5)))
#
#topo.sim.connect('Retina','V1',name='Afferent',delay=0.05,
#                 connection_type=CFProjection,
#                 learning_rate=DynamicNumber(ExponentialDecay(starting_value = 0.5,
#                                                              time_constant=-10000/8.0,
#                                                              base=0.5)),
#                 weights_generator = topo.patterns.basic.Gaussian(),
#                 nominal_bounds_template=BoundingBox(radius=0.1),
#                 response_fn = CFPRF_DotProduct_opt(),
#                 learning_fn=CFPLF_EuclideanHebbian())

