"""
LISSOM-based orientation map with ON/OFF channels with Homeostatic Intrinsic Plasticity

$Id$
"""
__version__='$Revision$'

import RandomArray
import fixedpoint
import copy

from math import pi, sqrt
from fixedpoint import FixedPoint
from Numeric import sum,ones,exp

import topo.patterns.basic
import topo.patterns.random
import Numeric

from topo.sheets.lissom import LISSOM
from topo.sheets.generatorsheet import GeneratorSheet
from topo.projections.basic import CFProjection, SharedWeightCFProjection
from topo.responsefns.optimized import CFPRF_DotProduct_opt, CFPRF_SharedWeightDotProduct_opt
from topo.base.parameterclasses import DynamicNumber, Number
from topo.base.cf import CFSheet
from topo.base.boundingregion import BoundingBox
from topo.learningfns.optimized import CFPLF_Hebbian_opt
from topo.outputfns.optimized import CFPOF_DivisiveNormalizeL1_opt
from topo.outputfns.basic import PiecewiseLinear, DivisiveNormalizeL1
from topo.misc.numbergenerators import UniformRandom
from topo.base.functionfamilies import OutputFn
from topo.base.arrayutils import clip_in_place

topo.sim.name = "homeo_intrinsic_lissom_oo_or"

input_pattern = topo.patterns.basic.Gaussian(
          scale=1.0, size=2*0.0468, aspect_ratio=4.0,
          x=DynamicNumber(UniformRandom(lbound=-0.5,ubound=0.5,seed=12)),
          y=DynamicNumber(UniformRandom(lbound=-0.5,ubound=0.5,seed=34)),
          orientation=DynamicNumber(UniformRandom(lbound=-pi,ubound=pi,seed=56)))

                                 
# Specify weight initialization, response function, and learning function
RandomArray.seed(500,500)
CFProjection.weights_generator=topo.patterns.random.UniformRandom()
CFProjection.weights_shape=topo.patterns.basic.Disk(smoothing=0.0)
CFProjection.response_fn=CFPRF_DotProduct_opt()
CFProjection.learning_fn=CFPLF_Hebbian_opt()
CFProjection.weights_output_fn=CFPOF_DivisiveNormalizeL1_opt()
SharedWeightCFProjection.response_fn=CFPRF_SharedWeightDotProduct_opt()

SharedWeightCFProjection.weights_output_fn.single_cf_fn=DivisiveNormalizeL1()


class HomeostaticMaxEnt(OutputFn):
    """
    Implementation of intrinsic excitability equations from Triesch, ICANN 2005, LNCS 3696 pp. 65-70.
    """
    lstep = Number(default=8,doc="")
    a_init = Number(default=13,doc="Multiplicative parameter controlling the exponential.")
    b_init = Number(default=-4,doc="Additive parameter controlling the exponential.")
    eta = Number(default=0.0002,doc="Learning rate for homeostatic plasticity.")
    mu = Number(default=0.015,doc="Average firing rate target.")

    def __init__(self,**params):
        super(HomeostaticMaxEnt,self).__init__(**params)

	# DEBUG only: Not required for the algorithm, but useful for debugging	
	self.first_call = True
	self.y_avg_count = 0 
	self.n_step = 0
	self.beta = 0.0003
	self.ncall = 0

    def __call__(self,x):
	
	if self.first_call:
	    self.first_call = False
	    self.a = Numeric.ones(x.shape, x.typecode()) * self.a_init
	    self.b = Numeric.ones(x.shape, x.typecode()) * self.b_init

	    # DEBUG only (for computing average activity of each neuron over time) 
	    self.y_avg = Numeric.zeros(x.shape, x.typecode())
	    self.x_avg = zeros(x.shape,x.typecode())
	    self.x_hist = []

	# Apply sigmoid function to x, resulting in what Triesch calls y
        x_orig = copy.copy(x)
        x *= 0.0
	x += 1.0 / (1.0 + exp(-(self.a*x_orig + self.b)))

	# DEBUG only (computing average activity of each neuron over time) 
	self.n_step += 1	
	if self.n_step == self.lstep:
	    self.n_step = 0
	
	    # Compute average of all previous y (firing rate), for debugging
	    self.y_avg = (self.y_avg * self.y_avg_count + x) / (self.y_avg_count+1)
	    self.y_avg_count += 1

	    if self.ncall <= 500:
	        self.x_avg = ((self.x_avg*self.ncall) + x) / (self.ncall+1)
	        self.ncall += 1
	    else:
	        self.x_avg = self.beta*x + (1.0-self.beta)*self.x_avg	        

	    #self.x_hist.append (self.x_avg)
	    
	    print self.x_avg[23][23], ' - ', self.x_avg[12][12], ' - ', self.x_avg[0][0], ' - ', self.x_avg[5][5]


	# Update a and b
	self.a += self.eta * (1.0/self.a + x_orig - (2.0 + 1.0/self.mu)*x_orig*x + x_orig*x*x/self.mu)
	self.b += self.eta * (1.0 - (2.0 + 1.0/self.mu)*x + x*x/self.mu)


# DEBUG Only: OutputFn for computing average activity of each neuron
class TestFn(OutputFn):
    """ 
    Piecewise-linear output function with lower and upper thresholds
    as constructor parameters.
    """
    lower_bound = Number(default=0.0,softbounds=(0.0,1.0))
    upper_bound = Number(default=1.0,softbounds=(0.0,1.0))
    learn_step = Number(default=8,doc="Number of step before learning take place")

    def __init__(self,**params):
        super(TestFn,self).__init__(**params)

	self.first_call = True
	self.n_step = 0
	self.beta = 0.0003
	self.ncall = 0

    def __call__(self,x):

        fact = 1.0/(self.upper_bound-self.lower_bound)        
        x -= self.lower_bound
        x *= fact
        clip_in_place(x,0.0,1.0)

	if self.first_call:
	    self.first_call = False
	    #self.x_avg = self.beta * copy.copy(x)
	    #self.x_avg[12][12] = 0.01
	    self.x_avg = zeros(x.shape,x.typecode())
	    self.x_hist = []

	if self.ncall <= 500:
	    self.x_avg = ((self.x_avg*self.ncall) + x) / (self.ncall+1)
	    self.ncall += 1
	else:	    
	    self.x_avg = self.beta*x + (1.0-self.beta)*self.x_avg


	self.n_step += 1
	if self.n_step == self.learn_step:

	    self.n_step = 0
	    self.x_hist.append (self.x_avg)

	    print self.x_avg[23][23], ' ', self.x_avg[11][11], ' ', self.x_avg[0][0], ' ', self.x_avg[47][47]



###########################################
# build simulation

topo.sim['Retina']=GeneratorSheet(nominal_density=24.0,
                                  input_generator=input_pattern,
                                  period=1.0, phase=0.05,
                                  nominal_bounds=BoundingBox(radius=0.5+0.25+0.375))

topo.sim['LGNOn']=CFSheet(nominal_density=24.0,
                          nominal_bounds=BoundingBox(radius=0.5+0.25),
                          output_fn=PiecewiseLinear(lower_bound=0.0,upper_bound=1.0),
                          measure_maps=False)

topo.sim['LGNOff']=CFSheet(nominal_density=24.0,
                           nominal_bounds=BoundingBox(radius=0.5+0.25),
                           output_fn=PiecewiseLinear(lower_bound=0.0,upper_bound=1.0),
                           measure_maps=False)

topo.sim['V1'] = LISSOM(nominal_density=locals().get('default_density',48.0),
                        nominal_bounds=BoundingBox(radius=0.5), output_fn=HomeostaticMaxEnt())

#output_fn=TestFn())

#topo.sim['V1'].output_fn.lower_bound=0.083
#topo.sim['V1'].output_fn.upper_bound=0.633


# LGN ON channel
topo.sim.connect('Retina','LGNOn',delay=FixedPoint("0.05"),
                  connection_type=SharedWeightCFProjection,strength=2.33,
                  nominal_bounds_template=BoundingBox(radius=0.375),name='Center',
                  weights_generator=topo.patterns.basic.Gaussian(size=0.0417,
                                                                 aspect_ratio=1))

topo.sim.connect('Retina','LGNOn',delay = FixedPoint("0.05"),
                  connection_type=SharedWeightCFProjection,strength=-2.33,
                  name='Surround',nominal_bounds_template=BoundingBox(radius=0.375),
                  weights_generator=topo.patterns.basic.Gaussian(size=0.1667,
                                                                 aspect_ratio=1))

# LGN OFF channel
topo.sim.connect('Retina','LGNOff',delay = FixedPoint("0.05"),
                  connection_type=SharedWeightCFProjection,strength=-2.33,
                  name='Center',nominal_bounds_template=BoundingBox(radius=0.375),
                  weights_generator=topo.patterns.basic.Gaussian(size=0.0417,
                                                                 aspect_ratio=1))

topo.sim.connect('Retina','LGNOff',delay = FixedPoint("0.05"),
                  connection_type=SharedWeightCFProjection,strength=2.33,
                  name='Surround',nominal_bounds_template=BoundingBox(radius=0.375),
                  weights_generator=topo.patterns.basic.Gaussian(size=0.1667,
                                                                 aspect_ratio=1))


topo.sim.connect('LGNOn','V1',delay=FixedPoint("0.05"),
                  connection_type=CFProjection,strength=0.5,name='LGNOnAfferent',
                  nominal_bounds_template=BoundingBox(radius=0.25),learning_rate=0.9590)

topo.sim.connect('LGNOff','V1',delay=FixedPoint("0.05"),
                  connection_type=CFProjection,strength=0.5,name='LGNOffAfferent',
                  nominal_bounds_template=BoundingBox(radius=0.25),learning_rate=0.9590)


topo.sim.connect('V1','V1',delay=FixedPoint("0.05"),name='LateralExcitatory',
                  connection_type=CFProjection,strength=0.9,
                  nominal_bounds_template=BoundingBox(radius=0.10),learning_rate=3.2018) 
            
topo.sim.connect('V1','V1',delay=FixedPoint("0.05"),name='LateralInhibitory',
                  connection_type=CFProjection,strength=-0.9,
                  nominal_bounds_template=BoundingBox(radius=0.23),learning_rate=1.9626)  



### Actions scheduled to occur as the simulation proceeds.
#
# CEBHACKALERT: add missing scheduled actions from c++ lissom
# (i.e. ones relevant to all bounds and densities, not just for
#  the particular ones set in this file right now).

topo.sim.startup_commands.append("from topo.base.boundingregion import BoundingBox")

### Lateral excitatory bounds changes
topo.sim.schedule_command(200,'topo.sim["V1"].projections()["LateralExcitatory"].change_bounds(BoundingBox(radius=0.06))')
topo.sim.schedule_command(500,'topo.sim["V1"].projections()["LateralExcitatory"].change_bounds(BoundingBox(radius=0.042))')

### Lateral excitatory learning rate changes
topo.sim.schedule_command(200,'topo.sim["V1"].projections()["LateralExcitatory"].learning_rate=1.2213')
topo.sim.schedule_command(500,'topo.sim["V1"].projections()["LateralExcitatory"].learning_rate=0.3466')

### Afferent learning rate changes
topo.sim.schedule_command(  500,'topo.sim["V1"].projections()["LGNOnAfferent"].learning_rate=0.6850;topo.sim["V1"].projections()["LGNOffAfferent"].learning_rate=0.6850')
topo.sim.schedule_command( 2000,'topo.sim["V1"].projections()["LGNOnAfferent"].learning_rate=0.5480;topo.sim["V1"].projections()["LGNOffAfferent"].learning_rate=0.5480')
topo.sim.schedule_command( 4000,'topo.sim["V1"].projections()["LGNOnAfferent"].learning_rate=0.4110;topo.sim["V1"].projections()["LGNOffAfferent"].learning_rate=0.4110')
topo.sim.schedule_command(20000,'topo.sim["V1"].projections()["LGNOnAfferent"].learning_rate=0.2055;topo.sim["V1"].projections()["LGNOffAfferent"].learning_rate=0.2055')

### LISSOM output function bounds changes
'''
topo.sim.schedule_command(  200,'topo.sim["V1"].output_fn.lower_bound=0.093;topo.sim["V1"].output_fn.upper_bound=0.643')
topo.sim.schedule_command(  500,'topo.sim["V1"].output_fn.lower_bound=0.103;topo.sim["V1"].output_fn.upper_bound=0.643')
topo.sim.schedule_command( 1000,'topo.sim["V1"].output_fn.lower_bound=0.133;topo.sim["V1"].output_fn.upper_bound=0.663')
topo.sim.schedule_command( 2000,'topo.sim["V1"].output_fn.lower_bound=0.163;topo.sim["V1"].output_fn.upper_bound=0.683')
topo.sim.schedule_command( 3000,'topo.sim["V1"].output_fn.lower_bound=0.183;topo.sim["V1"].output_fn.upper_bound=0.713')
topo.sim.schedule_command( 4000,'topo.sim["V1"].output_fn.lower_bound=0.183;topo.sim["V1"].output_fn.upper_bound=0.743')
topo.sim.schedule_command( 5000,'topo.sim["V1"].output_fn.lower_bound=0.193;topo.sim["V1"].output_fn.upper_bound=0.773')
topo.sim.schedule_command( 6500,'topo.sim["V1"].output_fn.lower_bound=0.203;topo.sim["V1"].output_fn.upper_bound=0.803')
topo.sim.schedule_command( 8000,'topo.sim["V1"].output_fn.lower_bound=0.213;topo.sim["V1"].output_fn.upper_bound=0.833')
topo.sim.schedule_command(20000,'topo.sim["V1"].output_fn.lower_bound=0.223;topo.sim["V1"].output_fn.upper_bound=0.863')
'''

# default locations for model editor
topo.sim['V1'].gui_x=306.0;      topo.sim['V1'].gui_y=225.0
topo.sim['LGNOn'].gui_x=432.0;   topo.sim['LGNOn'].gui_y=345.0
topo.sim['LGNOff'].gui_x=150.0;  topo.sim['LGNOff'].gui_y=345.0
topo.sim['Retina'].gui_x=279.0;  topo.sim['Retina'].gui_y=500.0



# Uncomment to allow profiling
## import hotshot,hotshot.stats
## prof = hotshot.Profile("abc")
## prof.runctx('topo.sim.run(199)',globals(),locals())
## prof.close()
## p = hotshot.stats.load("abc")
## p.strip_dirs().sort_stats('cumulative','time').print_stats()
