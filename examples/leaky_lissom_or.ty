"""
Example of a LISSOM-based orientation map.

$Id$
"""
__version__='$Revision$'

import RandomArray
import fixedpoint

from math import pi, sqrt
from fixedpoint import FixedPoint

import topo.patterns.basic
import topo.patterns.random

from topo.sheets.slissom import SLISSOM
from topo.sheets.generatorsheet import GeneratorSheet
from topo.projections.basic import CFProjection,LeakyCFProjection
from topo.responsefns.optimized import CFPRF_DotProduct_opt
from topo.base.sheet import BoundingBox
from topo.base.parameterclasses import DynamicNumber
from topo.base.cf import CFPLF_Plugin,CFPLF_OutstarHebbian
from topo.learningfns.optimized import CFPLF_Hebbian_opt
from topo.outputfns.optimized import CFPOF_DivisiveNormalizeL1_opt
from topo.outputfns.optimized import CFPOF_DivisiveNormalizeL1
from topo.misc.numbergenerators import UniformRandom

topo.sim.name = "slissom_or"

# CEBHACKALERT: should be changed over to use circular connection fields.
# (This requires that the learning rates be adjusted.)


### Setup input
#
GeneratorSheet.nominal_density = 36.0 
GeneratorSheet.period = 1
GeneratorSheet.phase = 0.05
GeneratorSheet.nominal_bounds = BoundingBox(radius=0.72)

input_pattern = topo.patterns.basic.Gaussian(
    scale=1.0,size=2*0.0468,aspect_ratio=4.0,
    bounds=BoundingBox(radius=0.72),
    x=DynamicNumber(UniformRandom(lbound=-0.5,ubound=0.5,seed=12)),
    y=DynamicNumber(UniformRandom(lbound=-0.5,ubound=0.5,seed=34)),
    orientation=DynamicNumber(UniformRandom(lbound=-pi,ubound=pi,seed=56)))

# YC use test pattern
input_pattern = topo.patterns.basic.TwoRectangles(scale=1.0)



### LISSOM parameters
#
SLISSOM.nominal_density = locals().get('default_density',24.0)


### Specify weight initialization, response function, and learning function
#
RandomArray.seed(500,500)
CFProjection.weights_generator=topo.patterns.random.UniformRandom()
CFProjection.response_fn=CFPRF_DotProduct_opt()
CFProjection.learning_fn=CFPLF_Hebbian_opt()
CFProjection.weights_output_fn=CFPOF_DivisiveNormalizeL1_opt()

LeakyCFProjection.weights_generator=topo.patterns.random.UniformRandom()
LeakyCFProjection.response_fn=CFPRF_DotProduct_opt()
#- LeakyCFProjection.learning_fn=CFPLF_Hebbian_opt()
#- LeakyCFProjection.weights_output_fn=CFPOF_DivisiveNormalizeL1_opt()
LeakyCFProjection.learning_fn=CFPLF_OutstarHebbian()
LeakyCFProjection.weights_output_fn=CFPOF_DivisiveNormalizeL1()


### Build simulation
#
topo.sim['Retina'] = GeneratorSheet(input_generator=input_pattern)
topo.sim['V1'] = SLISSOM(tsettle=1,threshold=0.35)

topo.sim.connect('Retina','V1', delay = FixedPoint("0.10"),
          connection_type=LeakyCFProjection,strength=1.0,name='Afferent0',
          nominal_bounds_template=BoundingBox(radius=0.22),learning_rate=1.274,
	  decay_rate=0.5)

topo.sim.connect('V1','V1', delay = FixedPoint("0.05"), 
          connection_type=LeakyCFProjection,strength = 0.9, name='LateralExcitatory',
          nominal_bounds_template=BoundingBox(radius=0.1),learning_rate=2.674,
	  decay_rate=0.5)
            
topo.sim.connect('V1','V1', delay = FixedPoint("0.05"), 
          connection_type=LeakyCFProjection,strength = -0.9, name='LateralInhibitory',
          nominal_bounds_template=BoundingBox(radius=0.9),learning_rate=2.466,
	  decay_rate=0.01)


# CEBHACKALERT: scheduled events are missing. e.g. change_bounds are
# ok for this density, but for higher ones there are others that would
# make a difference. Now we can have a minimum radius for the bounds,
# we can include those events. (From c++ lissom's or_defs.)  Also
# applies to lissom_oo_or.ty.


### Schedule bounds changes
#
topo.sim.schedule_command( 200, 'topo.sim["V1"].projections()["LateralExcitatory"].change_bounds(BoundingBox(radius=0.06))')
topo.sim.schedule_command( 500, 'topo.sim["V1"].projections()["LateralExcitatory"].change_bounds(BoundingBox(radius=0.042))')
topo.sim.schedule_command(1000,'topo.sim["V1"].projections()["LateralExcitatory"].change_bounds(BoundingBox(radius=0.0336))')
topo.sim.schedule_command(2000,'topo.sim["V1"].projections()["LateralExcitatory"].change_bounds(BoundingBox(radius=0.021))')


### Schedule learning rate changes
#
topo.sim.schedule_command(  200,'topo.sim["V1"].projections()["LateralExcitatory"].learning_rate=1.445')
topo.sim.schedule_command(  500,'topo.sim["V1"].projections()["LateralExcitatory"].learning_rate=0.205')
topo.sim.schedule_command( 1000,'topo.sim["V1"].projections()["LateralExcitatory"].learning_rate=0.149') 

topo.sim.schedule_command(  500,'topo.sim["V1"].projections()["Afferent0"].learning_rate=0.911')
topo.sim.schedule_command( 2000,'topo.sim["V1"].projections()["Afferent0"].learning_rate=0.729')
topo.sim.schedule_command( 4000,'topo.sim["V1"].projections()["Afferent0"].learning_rate=0.545')
topo.sim.schedule_command(20000,'topo.sim["V1"].projections()["Afferent0"].learning_rate=0.273')


### Schedule SLISSOM output function threshold changes
#
#topo.sim.schedule_command(  0, 'topo.sim["V1"].output_fn.lower_bound=0.3; topo.sim["V1"].output_fn.upper_bound=0.31')
topo.sim.schedule_command(  200, 'topo.sim["V1"].output_fn.lower_bound=0.11; topo.sim["V1"].output_fn.upper_bound=0.66')
topo.sim.schedule_command(  500, 'topo.sim["V1"].output_fn.lower_bound=0.12; topo.sim["V1"].output_fn.upper_bound=0.67')
topo.sim.schedule_command( 1000, 'topo.sim["V1"].output_fn.lower_bound=0.15; topo.sim["V1"].output_fn.upper_bound=0.68')
topo.sim.schedule_command( 2000, 'topo.sim["V1"].output_fn.lower_bound=0.18; topo.sim["V1"].output_fn.upper_bound=0.70')
topo.sim.schedule_command( 3000, 'topo.sim["V1"].output_fn.lower_bound=0.20; topo.sim["V1"].output_fn.upper_bound=0.73')
topo.sim.schedule_command( 4000, 'topo.sim["V1"].output_fn.lower_bound=0.20; topo.sim["V1"].output_fn.upper_bound=0.76')
topo.sim.schedule_command( 5000, 'topo.sim["V1"].output_fn.lower_bound=0.21; topo.sim["V1"].output_fn.upper_bound=0.79')
topo.sim.schedule_command( 6500, 'topo.sim["V1"].output_fn.lower_bound=0.22; topo.sim["V1"].output_fn.upper_bound=0.82')
topo.sim.schedule_command( 8000, 'topo.sim["V1"].output_fn.lower_bound=0.23; topo.sim["V1"].output_fn.upper_bound=0.85')
topo.sim.schedule_command(20000, 'topo.sim["V1"].output_fn.lower_bound=0.24; topo.sim["V1"].output_fn.upper_bound=0.88')



### Uncomment lines below to profile performance
#
## import hotshot,hotshot.stats
## prof = hotshot.Profile("abc")
## prof.runctx('top.sim.run(198)',globals(),locals())
## prof.close()
## p = hotshot.stats.load("abc")
## p.strip_dirs().sort_stats('cumulative','time').print_stats()

