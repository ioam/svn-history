"""
LISSOM-based orientation map with complex cell layer.

$Id: cc_lissom_oo_or.ty 8265 2008-03-26 17:09:15Z antolikjan $
"""
__version__='$Revision: 8265 $'


import numpy

from math import pi, sqrt

from topo import param

import topo.pattern.basic
import topo.pattern.random
import __main__

from topo.sheet.lissom import LISSOM, JointNormalizingCFSheet_Continuous
from topo.sheet.optimized import NeighborhoodMask_Opt, LISSOM_Opt
from topo.sheet.generator import GeneratorSheet
from topo.projection.basic import CFProjection, SharedWeightCFProjection,OneToOneProjection
from topo.responsefn.optimized import CFPRF_DotProduct_opt
from topo.base.cf import CFSheet
from topo.base.boundingregion import BoundingBox
from topo.learningfn.optimized import CFPLF_Hebbian_opt, CFPLF_Trace_opt
from topo.outputfn.optimized import CFPOF_DivisiveNormalizeL1_opt
from topo.outputfn.basic import HalfRectify,PiecewiseLinear,DivisiveNormalizeL1, PipelineOF, HomeostaticMaxEnt,CascadeHomeostatic,AttributeTrackingOF,Sigmoid
from topo.misc.numbergenerator import UniformRandom, BoundedNumber, ExponentialDecay, Choice
from topo.pattern.basic import Gaussian
from topo.learningfn.projfn import CFPLF_Trace
from topo.base.functionfamily import CoordinateMapperFn
from contrib.jacommands import randomize_V1Simple_relative_LGN_strength,ActivityHysteresis, Translator


topo.sim.name = "CCSimple"

shared_params = {"a_init":14.5, "b_init":-4, "mu":0.01, "smoothing":0.0003}
shared_debug_params = {"debug_params":["a", "b"] , "avg_params":["x"], "units":[(0,0),(11,11),(23,23)]}
core_size=locals().get('CS',0.5)

num_inputs=1

dataset=locals().get('dataset',"Line") #set the input type by choosing the dataset parameter 


if dataset=="Line":
	input= Translator(generator=topo.pattern.basic.Line(   x=UniformRandom(lbound=-(core_size+0.15),ubound=(core_size+0.15),seed=1023),   y=UniformRandom(lbound=-(core_size+0.15),ubound=(core_size+0.15),seed=53),size=1.0, offset=0.5,scale=Choice(choices=[-0.5,0.5],seed=56),bounds = BoundingBox(radius=0.8),thickness=0.04,smoothing=0.0),orientation=UniformRandom(lbound=-pi,ubound=pi,seed=56),reset_period=locals().get('Period',5),speed=locals().get('Speed',0.02))
elif dataset=="Natural":
	import topo.pattern.image 
	input_type=topo.pattern.image.Image
	
	image_filenames=["images/mcgill_img/foliage/%02d.png"%(i+1) for i in xrange(98)]
	inputs=[input_type(filename=f,
				size=10.0,  #size_normalization='original',(size=10.0)
				x=0,
				y=0,
				orientation=0)
			for f in image_filenames]	
	input =Translator(generator=topo.pattern.basic.Selector(generators=inputs),orientation=UniformRandom(lbound=-pi,ubound=pi,seed=56),reset_period=locals().get('Period',5),speed=locals().get('Speed',0.02))


ring=topo.pattern.basic.Ring(x=UniformRandom(lbound=-1.1,ubound=1.1,seed=1023),
                                                            y=UniformRandom(lbound=-1.1,ubound=1.1,seed=511),
                                                            size=2, aspect_ratio=1.0, scale=0.8,thickness=0.03,
                                                            offset=0.0,
                                                            bounds=BoundingBox(radius=1.125), smoothing=0.02)


retinal_waves=Translator(generator=ring,orientation=UniformRandom(lbound=-pi,ubound=pi,seed=56),reset_period=locals().get('Period',5),speed=locals().get('Speed',0.02))


zeroInput = topo.pattern.basic.Null();


jitter  =  locals().get('Jitter',0.4)

class Jitter(CoordinateMapperFn):
    """Return the jittered x,y coordinate of the given coordinate."""
    scale =  jitter
    rand = param.Parameter(default=None)
    def __call__(self,x,y):
        return x+(self.rand()-0.5)*self.scale,y+(self.rand()-0.5)*self.scale

jitterOn = Jitter(rand =UniformRandom(seed=1023))
jitterOff = Jitter(rand =UniformRandom(seed=1023))

# Specify weight initialization, response function, and learning function
CFProjection.weights_generator=topo.pattern.random.UniformRandom()
CFProjection.cf_shape=topo.pattern.basic.Disk(smoothing=0.0)
CFProjection.response_fn=CFPRF_DotProduct_opt()
CFProjection.learning_fn=CFPLF_Hebbian_opt()
CFProjection.weights_output_fn=CFPOF_DivisiveNormalizeL1_opt()



## Homeostatic stuff
#Simple
units=[(0.25,0.25),(-0.25,0.25),
       (0.25,-0.25),(-0.25,-0.25)]


V1Simple_OF=Sigmoid(r=locals().get('r_init',22),k=locals().get('k_init',-12))

if locals().get('COF',"Sigmoid") == "HR":
    V1Complex_OF=HalfRectify()
else:
	V1Complex_OF=Sigmoid(r=locals().get('r_init',14.5),k=locals().get('k_init',-3))





###########################################
# build simulation

topo.sim['Retina']=GeneratorSheet(nominal_density=48.0,
                                input_generator=input,  
                                period=1.0, phase=0.05,
                                nominal_bounds=BoundingBox(radius=core_size+0.25+0.375))

topo.sim['FakeRetina1']=GeneratorSheet(nominal_density=48.0,
                                  input_generator=retinal_waves,  
                                  period=1.0, phase=0.05,
                                  nominal_bounds=BoundingBox(radius=core_size+0.25))

topo.sim['FakeRetina2']=GeneratorSheet(nominal_density=48.0,
                                  input_generator=retinal_waves,  
                                  period=1.0, phase=0.05,
                                  nominal_bounds=BoundingBox(radius=core_size+0.25))


topo.sim['LGNOn']=CFSheet(nominal_density=48.0,
                          nominal_bounds=BoundingBox(radius=core_size+0.25),
                          output_fn=PiecewiseLinear(lower_bound=0.0,upper_bound=1.0),
                          measure_maps=False)

topo.sim['LGNOff']=CFSheet(nominal_density=48.0,
                           nominal_bounds=BoundingBox(radius=core_size+0.25),
                           output_fn=PiecewiseLinear(lower_bound=0.0,upper_bound=1.0),
                           measure_maps=False)

topo.sim['V1Simple'] = JointNormalizingCFSheet_Continuous(nominal_density=locals().get('default_density',48.0),
                        nominal_bounds=BoundingBox(radius=core_size),
                        output_fn=PipelineOF(output_fns=[ActivityHysteresis(time_constant=0.5),V1Simple_OF]))

                        
topo.sim['V1Complex'] = JointNormalizingCFSheet_Continuous(nominal_density=locals().get('default_density',48.0),
                        nominal_bounds=BoundingBox(radius=core_size),
                        output_fn=PipelineOF(output_fns=[ActivityHysteresis(time_constant=0.5),V1Complex_OF]))

print topo.sim['V1Simple'].mask
#topo.sim['V1Simple'].mask = NeighborhoodMask_Opt(threshold = 0.00001,radius = 0.15,sheet = topo.sim['V1Simple'])
#topo.sim['V1Complex'].mask = NeighborhoodMask_Opt(threshold = 0.00001,radius = 0.15,sheet = topo.sim['V1Complex'])


# DoG weights for the LGN
#centerg   = Gaussian(size=0.07385,aspect_ratio=1.0,output_fn=DivisiveNormalizeL1())
centerg   = Gaussian(size=0.04,aspect_ratio=1.0,output_fn=DivisiveNormalizeL1())
surroundg = Gaussian(size=0.29540,aspect_ratio=1.0,output_fn=DivisiveNormalizeL1())

on_weights = topo.pattern.basic.Composite(
    generators=[centerg,surroundg],operator=numpy.subtract)

off_weights = topo.pattern.basic.Composite(
    generators=[surroundg,centerg],operator=numpy.subtract)


topo.sim.connect('FakeRetina1','LGNOn',delay=0.05,
                 connection_type=OneToOneProjection,strength=0.5,
                 nominal_bounds_template=BoundingBox(radius=0.375),name='Afferent')

topo.sim.connect('FakeRetina2','LGNOff',delay = 0.05,
                 connection_type=OneToOneProjection,strength=0.5,
                 nominal_bounds_template=BoundingBox(radius=0.375),name='Afferent')


#c1 = Choice(choices=[0.1,0.9],seed=56)
#c1._Dynamic_time_fn = None
#c2 = Choice(choices=[0.9,0.1],seed=56)
#c2._Dynamic_time_fn = None
g1 = Gaussian(aspect_ratio=1.0,scale=1.0,size=UniformRandom(lbound=0.4,ubound=0.4,seed=56))
g1._Dynamic_time_fn = None
g2 = Gaussian(aspect_ratio=1.0,scale=1.0,size=UniformRandom(lbound=0.4,ubound=0.4,seed=56))
g2._Dynamic_time_fn = None



#V1 Simple

topo.sim.connect('LGNOn','V1Simple',delay=0.05,dest_port=('Activity','JointNormalize', 'Afferent'),
                 connection_type=CFProjection,strength=locals().get('LGNStr',5.2),name='LGNOnAfferent',
                 weights_generator=topo.pattern.basic.Composite(operator=numpy.multiply, 
                     generators=[g1
                 ,topo.pattern.random.UniformRandom()]),
                 nominal_bounds_template=BoundingBox(radius=0.27083),
                 coord_mapper=jitterOn,apply_output_fn_init=False,
                 learning_rate=(BoundedNumber(bounds=(0.137,None),generator=
                               ExponentialDecay(starting_value = locals().get('S_lr',0.3),
                                                time_constant=locals().get('S_tc',3200)))))


topo.sim.connect('LGNOff','V1Simple',delay=0.05,dest_port=('Activity','JointNormalize', 'Afferent'),
                 connection_type=CFProjection,strength=locals().get('LGNStr',5.2),name='LGNOffAfferent',
                 weights_generator=topo.pattern.basic.Composite(operator=numpy.multiply, 
                     generators=[g2
                 ,topo.pattern.random.UniformRandom()]),
                 nominal_bounds_template=BoundingBox(radius=0.27083),
                 coord_mapper=jitterOff,apply_output_fn_init=False,
                 learning_rate=(BoundedNumber(bounds=(0.137,None),generator=
                               ExponentialDecay(starting_value = locals().get('S_lr',0.3),
                                                time_constant=locals().get('S_tc',3200)))))


simpleLateral  =  locals().get('SL',False)
if simpleLateral:
	topo.sim.connect('V1Simple','V1Simple',delay=0.05,name='LateralExcitatoryL4',
	                 connection_type=CFProjection,strength=locals().get('SxLatExcStr',0.1),
	                 weights_generator=topo.patterns.basic.Gaussian(aspect_ratio=1.0, size=locals().get('CxLatExcSize',0.04)),
	                 nominal_bounds_template=BoundingBox(radius=locals().get('CxLatExcBB',0.04)),
	                 learning_rate=0.0)
	
	topo.sim.connect('V1Simple','V1Simple',delay=0.05,name='LateralInhibitoryL4',
	                 connection_type=CFProjection,strength=-locals().get('SxLatInhStr',0.1),
	                 weights_generator=topo.patterns.basic.Composite(operator=numpy.multiply, 
	                     generators=[Gaussian(aspect_ratio=1.0, size=locals().get('CxLatInhSize',0.22917)),
	                                topo.patterns.random.UniformRandom()]),
	                 nominal_bounds_template=BoundingBox(radius=0.22917/2),
	                 learning_rate=(BoundedNumber(bounds=(0.137,None),generator=
                               ExponentialDecay(starting_value = locals().get('LatInh_lr',0.3),
                                                time_constant=locals().get('LatInh_tc',3200)))))


#V1 Complex

topo.sim.connect('V1Simple','V1Complex',delay=0.05,
                 connection_type=CFProjection,strength=locals().get('StoCStr',5),name='V1SimpleAfferent',
                 weights_generator=Gaussian(aspect_ratio=1.0, size=locals().get('StoCSize',0.15)),
                 nominal_bounds_template=BoundingBox(radius=locals().get('StoCBB',0.15)/2),learning_rate=0)
                
topo.sim.connect('V1Complex','V1Simple',delay=0.05,
                 connection_type=CFProjection,strength=locals().get('FStrExc',0.5),name='V1SimpleFeedbackExc1',
                 weights_generator=Gaussian(aspect_ratio=1.0, size=18),
                 nominal_bounds_template=BoundingBox(radius=locals().get('FExcSize',0.005)/2),
                 learning_rate=0)

topo.sim.connect('V1Complex','V1Simple',delay=0.05,
                 connection_type=CFProjection,strength=locals().get('FStrInh',-2.2),name='V1SimpleFeedbackInh',
                 weights_generator=Gaussian(aspect_ratio=1.0, size=2.5),
                 nominal_bounds_template=BoundingBox(radius=locals().get('FInhSize',0.3)/2),learning_rate=0)


topo.sim.connect('V1Complex','V1Complex',delay=0.05,name='LateralExcitatory',
                 connection_type=CFProjection,strength=locals().get('CxLatExcStr',0.5),
                 weights_generator=topo.pattern.basic.Gaussian(aspect_ratio=1.0, size=locals().get('CxLatExcSize',0.04)),
                 nominal_bounds_template=BoundingBox(radius=locals().get('CxLatExcBB',0.12)),
                 learning_rate=0.0)

topo.sim.connect('V1Complex','V1Complex',delay=0.05,name='LateralInhibitory',
                 connection_type=CFProjection,strength=-locals().get('CxLatInhStr',0.35),
                 weights_generator=topo.pattern.basic.Composite(operator=numpy.multiply, 
                     generators=[Gaussian(aspect_ratio=1.0, size=locals().get('CxLatInhSize',2*0.22917)),
                                topo.pattern.random.UniformRandom()]),
                 nominal_bounds_template=BoundingBox(radius=0.22917),
                 learning_rate=(BoundedNumber(bounds=(0.137,None),generator=
                               ExponentialDecay(starting_value = locals().get('LatInh_lr',0.3),
                                                time_constant=locals().get('LatInh_tc',3200)))))

OFComplex = "topo.sim['V1Complex'].output_fn"
OFSimple = "topo.sim['V1Simple'].output_fn"

topo.sim.schedule_command(10000,"secondStage()")


topo.sim.schedule_command(20000,OFComplex+".r=4;"+ OFComplex + ".k=-3")
topo.sim.schedule_command(20000,OFSimple+".k=-10.5;")


def offset_tf():
	return topo.sim.time()-10000


def secondStage():
    topo.sim.connect('Retina','LGNOn',delay=0.05,
                    connection_type=SharedWeightCFProjection,strength=2.33,
                    nominal_bounds_template=BoundingBox(radius=0.375),name='Afferent1',
                    weights_generator=on_weights)
    
    topo.sim.connect('Retina','LGNOff',delay = 0.05,
                    connection_type=SharedWeightCFProjection,strength=2.33,
                    nominal_bounds_template=BoundingBox(radius=0.375),name='Afferent1',
                    weights_generator=off_weights)
    
    topo.sim['FakeRetina1'].set_input_generator(zeroInput)
    topo.sim['FakeRetina2'].set_input_generator(zeroInput)
    topo.sim['LGNOn'].in_connections[0].strength=0
    topo.sim['LGNOff'].in_connections[0].strength=0
    
    topo.sim['V1Simple'].in_connections[0].learning_rate=(BoundedNumber(bounds=(0.137,None),generator=
                               							  ExponentialDecay(starting_value = __main__.__dict__.get('SSS_lr',0.3),
                                                          time_fn=offset_tf,time_constant=__main__.__dict__.get('S_tc',3200))))
    
    topo.sim['V1Simple'].in_connections[1].learning_rate=(BoundedNumber(bounds=(0.137,None),generator=
    													  ExponentialDecay(starting_value = __main__.__dict__.get('SSS_lr',0.3)
    													  ,time_fn=offset_tf,time_constant=__main__.__dict__.get('S_tc',3200))))
    topo.sim['V1Complex'].in_connections[0].learning_rate=__main__.__dict__.get('SSC_lr',0.0)
    topo.sim['V1Simple'].in_connections[0].strength=4
    topo.sim['V1Simple'].in_connections[1].strength=4
    randomize_V1Simple_relative_LGN_strength()

