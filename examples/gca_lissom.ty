"""
GCA-LISSOM

Work in progress on an improved version of the LISSOM orientation map
simulation from figure 5.9 of Miikkulainen, Bednar, Choe, and Sirosh
(2005), Computational Maps in the Visual Cortex, Springer.  Important
differences include:

 - Using divisive normalization to the LGN to provide contrast gain control (GC)
   and contrast-invariant tuning
 - Using homeostatic adaptation (A) rather than manual threshold adjustment,
   to avoid the need for most parameter adjustment and to be more robust
 - Using a fixed lateral excitatory radius rather than shrinking it
   (now that homeostatic plasticity allows all neurons to develop robustly) 

$Id$
"""
__version__='$Revision$'


from math import pi, sqrt
import numpy

from topo import learningfn,numbergen,transferfn,param,pattern,projection,responsefn,sheet

import topo.learningfn.optimized
import topo.learningfn.projfn 
import topo.transferfn.optimized 
import topo.pattern.random
import topo.responsefn.optimized 
import topo.sheet.lissom
import topo.sheet.optimized

# ALERT: Need to eliminate these imports by moving them into topo/
from contrib.jacommands import AddGC


# Parameters that can be passed on the command line using -p
from topo.misc.commandline import global_params as p
p.add(

    dataset=param.Enumeration(default='Gaussian',available=
        ['Gaussian','Nature'],doc="""
        Set of input patterns to use::

          :'Gaussian': Two-dimensional Gaussians
          :'Nature':   Shouval's 1999 monochrome 256x256 images"""),

    num_inputs=param.Integer(default=2,bounds=(1,None),doc="""
        How many input patterns to present at each iteration, when using discrete 
        patterns (e.g. Gaussians)."""),

    # ALERT: Not yet respected
    area=param.Number(default=1.0,bounds=(0,None),
        inclusive_bounds=(False,True),doc="""
        Default cortical area to simulate; 1.0 gives a 1.0x1.0 Sheet area in V1."""),

    retina_density=param.Number(default=24.0,bounds=(0,None),
        inclusive_bounds=(False,True),doc="""
        The nominal_density to use for the retina."""),

    lgn_density=param.Number(default=24.0,bounds=(0,None),
        inclusive_bounds=(False,True),doc="""
        The nominal_density to use for the LGN."""),

    cortex_density=param.Number(default=48.0,bounds=(0,None),
        inclusive_bounds=(False,True),doc="""
        The nominal_density to use for V1."""),

    scale=param.Number(default=1.0,inclusive_bounds=(False,True),doc="""
        Brightness of the input patterns"""),

    smoothing=param.Number(default=0.999,bounds=(0.0,1.0),doc="""
        Weighting of previous activity vs. current activity when calculating the
        average for homeostatic plasticity."""),
    
    V1_smoothing=param.Number(default=0.999,bounds=(0.0,1.0),doc="""
        Same as smoothing but specifically for V1."""),

    io_ratio=param.Number(default=3.6,bounds=(0.0,None),doc="""
        The ratio between the average input and output activity."""),

    eta=param.Number(default=0.001,bounds=(0.0,None),doc="""
        Learning rate for homeostatic plasticity."""),


    aff_strength=param.Number(default=25.0,bounds=(0.0,None),doc="""
        Overall strength of the afferent projection to V1."""),

    exc_strength=param.Number(default=2.5,bounds=(0.0,None),doc="""
        Overall strength of the lateral excitatory projection to V1."""),

    inh_strength=param.Number(default=2.5,bounds=(0.0,None),doc="""
        Overall strength of the lateral inhibitory projection to V1."""),


    aff_lr=param.Number(default=2.0,bounds=(0.0,None),doc="""
        Learning rate for the afferent projection to V1."""),

    exc_lr=param.Number(default=0.0,bounds=(0.0,None),doc="""
        Learning rate for the lateral excitatory projection to V1."""),

    inh_lr=param.Number(default=0.5,bounds=(0.0,None),doc="""
        Learning rate for the lateral inhibitory projection to V1."""))


### Specify weight initialization, response function, and learning function
projection.CFProjection.cf_shape=pattern.Disk(smoothing=0.0)
projection.CFProjection.weights_generator=pattern.Constant()
projection.CFProjection.response_fn=responsefn.optimized.CFPRF_DotProduct_opt()
projection.CFProjection.learning_fn=learningfn.optimized.CFPLF_Hebbian_opt()
projection.CFProjection.weights_output_fns=[transferfn.optimized.CFPOF_DivisiveNormalizeL1_opt()]
projection.SharedWeightCFProjection.response_fn=responsefn.optimized.CFPRF_DotProduct_opt()


### Default for tutorial
pattern.Line.scale=0.9
pattern.Gaussian.size=0.08333
pattern.Gaussian.aspect_ratio=4.0


### Input patterns
if p.dataset=="Gaussian":
    input_type=pattern.Gaussian
    inputs=[input_type(x=numbergen.UniformRandom(lbound=-0.75,ubound=0.75,seed=12+i),
                       y=numbergen.UniformRandom(lbound=-0.75,ubound=0.75,seed=35+i),
                       orientation=numbergen.UniformRandom(lbound=-pi,ubound=pi,seed=21+i),
                       size=0.088388, aspect_ratio=4.66667, scale=p.scale)
            for i in xrange(p.num_inputs)]
    
    combined_inputs = pattern.SeparatedComposite(min_separation=0,generators=inputs)
    
elif p.dataset=="Natural":
    input_type=pattern.image.FileImage
    image_filenames=["images/shouval/combined%02d.png"%(i+1) for i in xrange(25)]
    inputs=[input_type(filename=f,
                       size=10.0,  #size_normalization='original',(size=10.0)
                       x=numbergen.UniformRandom(lbound=-0.75,ubound=0.75,seed=12),
                       y=numbergen.UniformRandom(lbound=-0.75,ubound=0.75,seed=36),
                       orientation=numbergen.UniformRandom(lbound=-pi,ubound=pi,seed=65))
        for f in image_filenames]

    combined_inputs =pattern.Selector(generators=inputs)



### Sheets
topo.sim['Retina']=sheet.GeneratorSheet(nominal_density=p.retina_density,
    input_generator=combined_inputs, period=1.0, phase=0.05,
    nominal_bounds=sheet.BoundingBox(radius=0.5+0.25+0.375+0.5))

topo.sim['LGNOn']=sheet.lissom.LISSOM(nominal_density=p.retina_density,
    nominal_bounds=sheet.BoundingBox(radius=0.5+0.25+0.5),
    output_fns=[transferfn.HalfRectify()], measure_maps=False)

topo.sim['LGNOff']=sheet.lissom.LISSOM(nominal_density=p.retina_density,
    nominal_bounds=sheet.BoundingBox(radius=0.5+0.25+0.5),
    output_fns=[transferfn.HalfRectify()], tsettle=0, measure_maps=False)

# Add the lateral connectivity to LGN
AddGC('LGNOn')
AddGC('LGNOff')

AH = transferfn.ActivityHysteresis(time_constant=0.5) 

V1_OF=transferfn.HomeostaticResponse(smoothing=p.V1_smoothing,eta=p.eta,
                                     input_output_ratio=p.io_ratio,t_init=0.15)

topo.sim['V1'] = sheet.lissom.JointScaling(nominal_density=p.cortex_density,
    tsettle=16, plastic=True, apply_scaling=False, smoothing=p.smoothing,
    nominal_bounds=sheet.BoundingBox(radius=0.5),
    output_fns=[AH,V1_OF])

#make sure that activity is reset at the beginning of iteration
topo.sim['V1'].beginning_of_iteration.append(AH.reset)



### Connections

# DoG weights for the LGN
centerg   = pattern.Gaussian(size=0.07385,aspect_ratio=1.0,
                             output_fns=[transferfn.DivisiveNormalizeL1()])
surroundg = pattern.Gaussian(size=0.29540,aspect_ratio=1.0,
                             output_fns=[transferfn.DivisiveNormalizeL1()])
    
on_weights = pattern.Composite(
    generators=[centerg,surroundg],operator=numpy.subtract)

off_weights = pattern.Composite(
    generators=[surroundg,centerg],operator=numpy.subtract)


topo.sim.connect(
    'Retina','LGNOn',delay=0.05,strength=2.33,name='Afferent',
    connection_type=projection.SharedWeightCFProjection,
    nominal_bounds_template=sheet.BoundingBox(radius=0.375),
    weights_generator=on_weights)

topo.sim.connect(
    'Retina','LGNOff',delay=0.05,strength=2.33,name='Afferent',
    connection_type=projection.SharedWeightCFProjection,
    nominal_bounds_template=sheet.BoundingBox(radius=0.375),
    weights_generator=off_weights)

topo.sim.connect(
    'LGNOn','V1',delay=0.05,strength=p.aff_strength,name='LGNOnAfferent',
    dest_port=('Activity','JointNormalize','Afferent'),
    connection_type=projection.CFProjection,learning_rate=p.aff_lr,
    nominal_bounds_template=sheet.BoundingBox(radius=0.27083),
    weights_generator=pattern.random.GaussianCloud(gaussian_size=2*0.27083),
    learning_fn=learningfn.optimized.CFPLF_Scaled_opt())
                     
topo.sim.connect(
    'LGNOff','V1',delay=0.05,strength=p.aff_strength,name='LGNOffAfferent',
    dest_port=('Activity','JointNormalize','Afferent'),
    connection_type=projection.CFProjection,learning_rate=p.aff_lr,
    nominal_bounds_template=sheet.BoundingBox(radius=0.27083),
    weights_generator=pattern.random.GaussianCloud(gaussian_size=2*0.27083),
    learning_fn=learningfn.optimized.CFPLF_Scaled_opt())

topo.sim.connect(
    'V1','V1',delay=0.05,strength=p.exc_strength,name='LateralExcitatory',
    connection_type=projection.CFProjection,learning_rate=p.exc_lr,
    nominal_bounds_template=sheet.BoundingBox(radius=0.104),
    weights_generator=pattern.Gaussian(aspect_ratio=1.0, size=0.05))

topo.sim.connect(
    'V1','V1',delay=0.05,strength=-1.0*p.inh_strength,name='LateralInhibitory',
    connection_type=projection.CFProjection,learning_rate=p.inh_lr,
    nominal_bounds_template=sheet.BoundingBox(radius=0.22917),
    weights_generator=pattern.random.GaussianCloud(gaussian_size=0.15))


### Default locations for model editor
topo.sim.grid_layout([[None,    'V1',     None],
                      ['LGNOn', None,     'LGNOff'],
                      [None,    'Retina', None]], xstart=150)


### Set up appropriate defaults for analysis

import topo.analysis.featureresponses
topo.analysis.featureresponses.FeatureCurveCommand.selectivity_multiplier=1.0
topo.analysis.featureresponses.FeatureCurveCommand.num_orientation=64
topo.analysis.featureresponses.SinusoidalMeasureResponseCommand.num_phase=8
topo.analysis.featureresponses.FeatureCurveCommand.apply_output_fns=True
topo.analysis.featureresponses.FeatureCurveCommand.curve_parameters=[{"contrast":1},{"contrast":10},{"contrast":30},{"contrast":50},{"contrast":100}]
