"""
Implementation of Sullivan & de Sa's model from "A temporal trace and
SOM-based model of complex cell development",  Neurocomputing, Volumes
58-60, June 2004, pages 827-833.

NOT YET TESTED.

Complex cell layer needs subtractive normalisation instead of divisive.

The following parameters aren't specified in the paper:
Sheet sizes(estimated from diagrams),
Learning rates for both Hebbian and Trace functions,
Input line thickness.

$Id$
"""
_version__='$Revision$'


import RandomArray
from math import exp, sqrt, fmod


import topo.patterns.random
import topo.patterns.basic

from topo.sheets.generatorsheet import GeneratorSheet
from topo.base.boundingregion import BoundingBox
from topo.base.cf import CFProjection,CFPOF_Plugin
from topo.base.parameterclasses import DynamicNumber,Number
from topo.sheets.cfsom import CFSOM
from topo.responsefns.optimized import CFPRF_EuclideanDistance_opt,CFPRF_DotProduct_opt
from topo.learningfns.projfns import CFPLF_Trace, CFPLF_Plugin
from topo.learningfns.som import CFPLF_HebbianSOM
from topo.misc.numbergenerators import UniformRandom
from topo.outputfns.basic import DivisiveNormalizeL1
from topo.base.functionfamilies import CoordinateMapperFn

topo.sim.name = "sullivan_nc04"

class XModulo(CoordinateMapperFn):
    """Return the x coordinate of the given coordinate, modulo the specified step distance."""

    grid_element_width = Number(1.0/5.0, doc="Length in Sheet coordinates of one large grid element.")
    
    def __call__(self,x,y):
	xmod=fmod(x+0.4875,self.grid_element_width)
	return x-xmod

class YModulo(CoordinateMapperFn):
    """Return the y coordinate of the given coordinate, modulo the specified step distance."""

    grid_element_width = Number(1.0/5.0, doc="Length in Sheet coordinates of one large grid element.")
    def __call__(self,x,y):
	ymod=fmod(y+0.4875,self.grid_element_width)
	return y-ymod

# input pattern
GeneratorSheet.period = 1.0
GeneratorSheet.phase = 0

##RPHACKALERT Needs altered to fit description in paper
input_pattern = topo.patterns.basic.Line(
    thickness=0.02,
    orientation=DynamicNumber(UniformRandom(lbound=-pi,ubound=pi,seed=12)))

RandomArray.seed(500,500)


topo.sim['Retina'] = GeneratorSheet(input_generator=input_pattern,
                                    period=1.0,phase=0.05,nominal_density=40)

# Note that the learning rates from the original paper must be scaled
# by the number of units in a typical ConnectionField, either 5x5 or 40x40
topo.sim['V1'] = CFSOM(nominal_density=locals().get('default_density',40.0),
                       learning_length=10000,radius_0=0.1,alpha_0=0.5*5*5)

topo.sim['Complex Cell Layer'] = CFSOM(nominal_density=locals().get('default_density',40.0),
                       learning_length=10000,radius_0=0.1,alpha_0=0.5*40*40)

topo.sim.connect('Retina','V1',delay=0.05,connection_type=CFProjection,
                  weights_generator = topo.patterns.basic.Gaussian(),
                  nominal_bounds_template=BoundingBox(radius=0.1),
                  response_fn = CFPRF_DotProduct_opt(),
                  learning_fn=CFPLF_HebbianSOM(),
                  x_coord_mapper=XModulo(),
                  y_coord_mapper=YModulo())


##RPALERT Add subtractive multiplication here once implemented
topo.sim.connect('V1','Complex Cell Layer',delay=0.05,connection_type=CFProjection,
                  weights_generator = topo.patterns.basic.Gaussian(),
                  nominal_bounds_template=BoundingBox(radius=1),
                  response_fn = CFPRF_EuclideanDistance_opt(),
                  weights_output_fn=CFPLF_Plugin(single_cf_fn=DivisiveNormalizeL1()),
                  learning_fn=CFPLF_Trace())
