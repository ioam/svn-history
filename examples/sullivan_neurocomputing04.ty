"""
Implementation of Sullivan & de Sa's model from "A temporal trace and
SOM-based model of complex cell development",  Neurocomputing, Volumes
58-60, June 2004, pages 827-833.

NOT YET TESTED.

The following parameters aren't specified in the paper:
Sheet sizes(estimated from diagrams),
Learning rates for both Hebbian and Trace functions,
Input line thickness.

$Id$
"""
__version__='$Revision$'


import numpy.oldnumeric.random_array as RandomArray
from math import exp, sqrt, fmod, pi, radians,sin,cos

import topo.patterns.random
import topo.patterns.basic

from topo.sheets.generatorsheet import GeneratorSheet
from topo.base.boundingregion import BoundingBox
from topo.base.cf import CFProjection,CFPOF_Plugin
from topo.base.parameterclasses import DynamicNumber,Number
from topo.sheets.cfsom import CFSOM
from topo.responsefns.optimized import CFPRF_EuclideanDistance_opt,CFPRF_DotProduct_opt
from topo.learningfns.projfns import CFPLF_Trace, CFPLF_Plugin,  CFPLF_OutstarHebbian
from topo.learningfns.som import CFPLF_HebbianSOM
from topo.misc.numbergenerators import UniformRandom
from topo.outputfns.basic import DivisiveNormalizeL1, KernelMax
from topo.base.functionfamilies import CoordinateMapperFn
from topo.misc.patternfns import line


from math import pi, sin, cos
from numpy.oldnumeric import around,bitwise_and,sin,add,Float,bitwise_or

from topo.base.parameterclasses import Number, Parameter, Enumeration
from topo.base.parameterclasses import DynamicNumber, ListParameter
from topo.base.functionfamilies import OutputFnParameter
from topo.base.patterngenerator import PatternGenerator

# Imported here so that all PatternGenerators will be in the same package
from topo.base.patterngenerator import Constant

from topo.misc.patternfns import gaussian,gabor,line,disk,ring
from topo.misc.utils import wrap
from topo.misc.numbergenerators import UniformRandom

topo.sim.name = "sullivan_neurocomputing04"

class XModulo(CoordinateMapperFn):
    """Return the x coordinate of the given coordinate, modulo the specified step distance."""
 
    grid_element_width = Number(1.0/5.0, doc="Length in Sheet coordinates of one large grid element.")    
    def __call__(self,x,y):
        xmod=fmod(x+0.4875,self.grid_element_width)
	#0.1 offset to align with center of box, not corner
        return x-xmod+0.1

class YModulo(CoordinateMapperFn):
    """Return the y coordinate of the given coordinate, modulo the specified step distance."""

    grid_element_width = Number(1.0/5.0, doc="Length in Sheet coordinates of one large grid element.")
    def __call__(self,x,y):
        ymod=fmod(y+0.4875,self.grid_element_width)
	#offset to align with center of box, not corner
        return y-ymod+0.08125

class OrientedX(ParameterizedObject):
      """Increments the x position 
      """
      base         = Number(default=0.0,doc="Passed in position.")
      direction	   = Number(default=0.0,doc="Direction line is heading.")
      step_number  = Number(default=0.0,doc="Current Step.")
      orientation  = Number(default=0.0,doc="Orientation of line.")
      angle	   = Number(default=0.0,doc="")
      def __call__(self,**params):
	  base=params.get('base',self.base)
	  orientation=params.get('orientation',self.orientation)
	  if not hasattr(self,'curr_pos'):
	     self.curr_pos=base
	     self.step_number=0
	     self.direction=1
	     self.angle=orientation
	  if (fmod(topo.sim.time(),15)<1): #time starts from 0.05
	       self.curr_pos=base
	       self.step_number=0
	       self.angle=orientation   

	  print "orientation is", self.angle
	  #0.03 as grid is 40 cells wide and line advances 1.2 cells per step
   	  self.curr_pos+=(self.direction*0.03*self.step_number)*cos(radians(self.angle)-pi/2)
	  self.step_number+=1
          return self.curr_pos

class OrientedY(ParameterizedObject):
      """Increments the y position 
      """
      base         = Number(default=0.0,doc="Passed in position.")
      direction	   = Number(default=0.0,doc="Direction line is heading.")
      step_number  = Number(default=0.0,doc="Current Step.")
      orientation  = Number(default=0.0,doc="Orientation of line.")
      angle	   = Number(default=0.0,doc="")
      def __call__(self,**params):
	  base=params.get('base',self.base)
	  orientation=params.get('orientation',self.orientation)
	  if not hasattr(self,'curr_pos'):
	     self.curr_pos=base
	     self.step_number=0
	     self.direction=1
	     self.angle=orientation
	  if (fmod(topo.sim.time(),15)<1): #time starts from 0.05
	       self.curr_pos=base
	       self.step_number=0
	       self.angle=orientation   

	  print "orientation is", self.angle
	  #0.03 as grid is 40 cells wide and line advances 1.2 cells per step
   	  self.curr_pos+=(self.direction*0.03*self.step_number)*sin(radians(self.angle)-pi/2)
	  self.step_number+=1
          return self.curr_pos

class OrientedLine(PatternGenerator):
    """2D line pattern generator."""

    thickness   = Number(default=0.006,bounds=(0.0,None),softbounds=(0.0,1.0),
                         precedence=0.60,
                         doc="Thickness (width) of the solid central part of the line.")
    smoothing = Number(default=0.05,bounds=(0.0,None),softbounds=(0.0,0.5),
                       precedence=0.61,
                       doc="Width of the Gaussian fall-off.")

    def function(self,**params):

	if (fmod(topo.sim.time(),15)<1):
		x=params.get('x',self.x)
		y=params.get('y',self.y)
		orientation=params.get('orientation',self.orientation)
		#RPHACKALERT check values from this are correct
		x=1-sin(radians(180*x))
	   	y=1-cos(radians(180*y))
		print "x is ",x
	#RPHACKALERT Move incrementing code here
        return line(self.pattern_y, 
                    params.get('thickness',self.thickness),
                    params.get('smoothing',self.smoothing))



# Weight seed
RandomArray.seed(500,500)
GeneratorSheet.period = 1.0
GeneratorSheet.phase = 0

line_x=OrientedX(base=DynamicNumber(UniformRandom(lbound=-0.5,ubound=0.5,seed=12)),orientation=DynamicNumber(UniformRandom(lbound=0,ubound=360,seed=22)))
line_y=OrientedY(base=DynamicNumber(UniformRandom(lbound=-0.5,ubound=0.5,seed=22)),orientation=DynamicNumber(UniformRandom(lbound=0,ubound=360,seed=22)))

##RPHACKALERT Change to using line_x and line_y
#input_pattern = OrientedLine(
input_pattern = topo.patterns.basic.Line(
	            x=DynamicNumber(line_x),
		    y=DynamicNumber(line_y),
		    #orientation=orientation
		    orientation=70
		    )

# Sheets, connections, and their parameters
topo.sim['Retina'] = GeneratorSheet(input_generator=input_pattern,
                                    period=1.0,phase=0.05,nominal_density=40)

# Note that the learning rates from the original paper must be scaled
# by the number of units in a typical ConnectionField, either 5x5 or 40x40
topo.sim['V1'] = CFSheet(nominal_density=locals().get('default_density',40.0),
                         #RPHACKALERT Find correct radius value 
                         output_fn = KernelMax(kernel_radius=3.5))

topo.sim.connect('Retina','V1',delay=0.05,connection_type=CFProjection,
                     weights_generator = topo.patterns.basic.Line(orientation=DynamicNumber(UniformRandom(lbound=0.0,ubound=2*pi,seed=30))),
                     nominal_bounds_template=BoundingBox(radius=0.1),
                     response_fn = CFPRF_DotProduct_opt(),
                     x_coord_mapper=XModulo(),
                     y_coord_mapper=YModulo())

topo.sim['Complex Cell Layer'] = CFSOM(nominal_density=locals().get('default_density',5.0),
                       learning_length=10000,radius_0=0.1,alpha_0=0.02*5*5)
                         
topo.sim.connect('V1','Complex Cell Layer',delay=0.05,connection_type=CFProjection,
                  weights_generator = topo.patterns.random.UniformRandom(),
                  nominal_bounds_template=BoundingBox(radius=1),
                  response_fn = CFPRF_DotProduct_opt(),
                  learning_fn=CFPLF_Trace())
