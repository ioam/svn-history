"""
Implementation of Sullivan & de Sa's model from "A temporal trace and
SOM-based model of complex cell development",  Neurocomputing, Volumes
58-60, June 2004, pages 827-833.

NOT YET TESTED.

The following parameters aren't specified in the paper:
Sheet sizes(estimated from diagrams),
Learning rates for both Hebbian and Trace functions,
Input line thickness.

$Id$
"""
_version__='$Revision$'


import RandomArray
from math import exp, sqrt, fmod

import topo.patterns.random
import topo.patterns.basic

from topo.sheets.generatorsheet import GeneratorSheet
from topo.base.boundingregion import BoundingBox
from topo.base.cf import CFProjection,CFPOF_Plugin
from topo.base.parameterclasses import DynamicNumber,Number
from topo.sheets.cfsom import CFSOM
from topo.responsefns.optimized import CFPRF_EuclideanDistance_opt,CFPRF_DotProduct_opt
from topo.learningfns.projfns import CFPLF_Trace, CFPLF_Plugin,  CFPLF_OutstarHebbian
from topo.learningfns.som import CFPLF_HebbianSOM
from topo.misc.numbergenerators import UniformRandom
from topo.outputfns.basic import DivisiveNormalizeL1, KernelMax
from topo.base.functionfamilies import CoordinateMapperFn
from topo.misc.patternfns import line
from topo.base.patterngenerator import PatternGenerator
topo.sim.name = "sullivan_neurocomputing04"

class XModulo(CoordinateMapperFn):
    """Return the x coordinate of the given coordinate, modulo the specified step distance."""
 
    grid_element_width = Number(1.0/5.0, doc="Length in Sheet coordinates of one large grid element.")    
    def __call__(self,x,y):
        xmod=fmod(x+0.4875,self.grid_element_width)
	#0.1 offset to align with center of box, not corner
        return x-xmod+0.1

class YModulo(CoordinateMapperFn):
    """Return the y coordinate of the given coordinate, modulo the specified step distance."""

    grid_element_width = Number(1.0/5.0, doc="Length in Sheet coordinates of one large grid element.")
    def __call__(self,x,y):
        ymod=fmod(y+0.4875,self.grid_element_width)
	#offset to align with center of box, not corner
        return y-ymod+0.08125

class SweepLine(PatternGenerator):
    """Generates random 2D lines which then incrementally move until off the
    edge of the sheet"""

    thickness = Number(default=0.006,bounds=(0.0,None),softbounds=(0.0,1.0),
                         precedence=0.60,
                         doc="Thickness (width) of the solid central part of the line.")
    smoothing = Number(default=0.05,bounds=(0.0,None),softbounds=(0.0,0.5),
                       precedence=0.61,
                       doc="Width of the Gaussian fall-off.")
    x = Number(default=0.0)
    y = Number(default=0.0)
    ###RPHACKALERT need fixed to move x and y correct amounts
    xoffset=Number(0.1)                       
    yoffset=Number(0.1)
    offedge=1 
    def function(self,**params):
	###Only take new random numbers when previous line is off sheet
	if self.offedge==1:
	     x=params.get('x',self.x)
	     y=params.get('y',self.y)
	     self.offedge=0
	###else, increment x and y values appropriate amount. Needs fixed for angle.
	else:
	   x=self.x
	   x+=self.xoffset
	   y=self.y
	   y+=self.yoffset
        if((x<-0.5)|(x>0.5)|(y<-0.5)|(y>0.5)):
		self.offedge=1
		print "offedge"
	else:
		self.x=x	
		self.y=y
	print "x is",x
	print "y is",y
        return line(self.pattern_y, 
                    params.get('thickness',self.thickness),
                    params.get('smoothing',self.smoothing))

# Weight seed
RandomArray.seed(500,500)
GeneratorSheet.period = 1.0
GeneratorSheet.phase = 0

##RPHACKALERT Needs altered to fix movement of line as in paper
input_pattern = SweepLine(
	            x=DynamicNumber(UniformRandom(lbound=-0.5,ubound=0.5,seed=12)),
		    y=DynamicNumber(UniformRandom(lbound=-0.5,ubound=0.5,seed=22)),
		    thickness=0.02)


# Sheets, connections, and their parameters
topo.sim['Retina'] = GeneratorSheet(input_generator=input_pattern,
                                    period=1.0,phase=0.05,nominal_density=40)

# Note that the learning rates from the original paper must be scaled
# by the number of units in a typical ConnectionField, either 5x5 or 40x40
topo.sim['V1'] = CFSheet(nominal_density=locals().get('default_density',40.0),
                         #RPHACKALERT Find correct radius value 
                         output_fn = KernelMax(kernel_radius=3.5))

topo.sim.connect('Retina','V1',delay=0.05,connection_type=CFProjection,
                     weights_generator = topo.patterns.basic.Line(orientation=DynamicNumber(UniformRandom(lbound=0.0,ubound=2*pi,seed=30))),
                     nominal_bounds_template=BoundingBox(radius=0.1),
                     response_fn = CFPRF_DotProduct_opt(),
                     x_coord_mapper=XModulo(),
                     y_coord_mapper=YModulo())

topo.sim['Complex Cell Layer'] = CFSOM(nominal_density=locals().get('default_density',5.0),
                       learning_length=10000,radius_0=0.1,alpha_0=0.02*5*5)
                         
topo.sim.connect('V1','Complex Cell Layer',delay=0.05,connection_type=CFProjection,
                  weights_generator = topo.patterns.random.UniformRandom(),
                  nominal_bounds_template=BoundingBox(radius=1),
                  response_fn = CFPRF_DotProduct_opt(),
                  learning_fn=CFPLF_Trace())
