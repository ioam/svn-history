"""
Implementation of Sullivan & de Sa's model from "A temporal trace and
SOM-based model of complex cell development",  Neurocomputing, Volumes
58-60, June 2004, pages 827-833.

NOT YET TESTED.

The following parameters aren't specified in the paper:
Sheet sizes(estimated from diagrams),
Learning rates for both Hebbian and Trace functions,
Input line thickness.

$Id$
"""
__version__='$Revision$'


import numpy.oldnumeric.random_array as RandomArray
from math import exp, sqrt, fmod, pi, radians,sin,cos

import topo.patterns.random
import topo.patterns.basic

from topo.sheets.generatorsheet import GeneratorSheet
from topo.base.boundingregion import BoundingBox
from topo.base.cf import CFProjection,CFPOF_Plugin
from topo.base.parameterclasses import DynamicNumber,Number
from topo.sheets.cfsom import CFSOM
from topo.responsefns.optimized import CFPRF_EuclideanDistance_opt,CFPRF_DotProduct_opt
from topo.learningfns.projfns import CFPLF_Trace, CFPLF_Plugin,  CFPLF_OutstarHebbian
from topo.learningfns.som import CFPLF_HebbianSOM
from topo.misc.numbergenerators import UniformRandom
from topo.outputfns.basic import DivisiveNormalizeL2, KernelMax
from topo.base.functionfamilies import CoordinateMapperFn
from topo.misc.patternfns import line


from math import pi, sin, cos
from numpy.oldnumeric import around,bitwise_and,sin,add,Float,bitwise_or

from topo.base.parameterclasses import Number, Parameter, Enumeration
from topo.base.parameterclasses import DynamicNumber, ListParameter
from topo.base.functionfamilies import OutputFnParameter
from topo.base.patterngenerator import PatternGenerator

# Imported here so that all PatternGenerators will be in the same package
from topo.base.patterngenerator import Constant

from topo.misc.patternfns import gaussian,gabor,line,disk,ring
from topo.misc.utils import wrap
from topo.misc.numbergenerators import UniformRandom

topo.sim.name = "sullivan_neurocomputing04"


class XYModulo(CoordinateMapperFn):
    """Return the x coordinate of the given coordinate, modulo the specified step distance."""
 
    grid_element_width = Number(1.0/5.0, doc="Length in Sheet coordinates of one large grid element.")
    def __call__(self,x,y):
        #Distance between 8 cells is 0.165, so offset by half that to align with center of box, not corner
        xmod=fmod(x+0.4875,self.grid_element_width)
        ymod=fmod(y+0.4875,self.grid_element_width)
	# x: 0.1 offset to align with center of box, not corner
	# y: offset to align with center of box, not corner
        return x-xmod+0.1,y-ymod+0.08125


class OrientedLine(PatternGenerator):
    """2D line pattern generator, based upon the behaviour of sullivan ."""

    thickness   = Number(default=0.006,bounds=(0.0,None),softbounds=(0.0,1.0),
                         precedence=0.60,
                         doc="Thickness (width) of the solid central part of the line.")
    smoothing = Number(default=0.05,bounds=(0.0,None),softbounds=(0.0,0.5),
                       precedence=0.61,
                       doc="Width of the Gaussian fall-off.")
    offEdge = Number(default=1,doc="1 if previous line has gone off edge of grid, 0 otherwise")
    angle	   = Number(default=0.0,doc="")
    def function(self,**params):
        if (self.offEdge==1):
            angle=params.get('angle',self.angle)           
            if (angle>180):
                angle-=180
                direction=-1
            else:
                direction=1
            delta=0.03 #0.03 as grid is 40 cells wide and line moves 1.2 per step
            if (angle == 0):
                self.deltaX = 0 #1000 * XGRIDEND
                self.deltaY = delta
            elif (angle == 90):
                self.deltaY = 0 #1000 * YGRIDEND
                self.deltaX = delta
            elif (angle< 90):
                self.deltaX = delta / sin(radians(angle))
                self.deltaY = delta / sin(radians(90 - angle))
            else:
                self.deltaY = delta / sin(radians(angle - 90))
                self.deltaX = delta / sin(radians(180 - angle))
            if ((angle >= 0) and ( angle < 90)):
                if (direction == 1):
                    startPointx = -0.5
                    startPointy = -0.5
                else:
                    startPointx = 0.5
                    startPointy = 0.5
                    self.deltaX *= -1
                    self.deltaY *= -1
            elif (direction == 1):
                startPointx = -0.5
                startPointy = 0.5
                self.deltaY *= -1;
            else:
                startPointx = 0.5
                startPointy = -0.5 
                self.deltaX*= -1

            self.x=startPointx
            self.y=startPointy
            self.offEdge=0
            self.orientation=angle
        else:
            self.offEdge=0
            self.x+=self.deltaX
            self.y+=self.deltaY
            if (self.x<-0.5 or self.x>0.5 or self.y<-0.5 or self.y>0.5):
               self.offEdge=1
        return line(self.pattern_y,
                    params.get('thickness',self.thickness),
                    params.get('smoothing',self.smoothing))


# Weight seed
RandomArray.seed(500,500)
GeneratorSheet.period = 1.0
GeneratorSheet.phase = 0

input_pattern = OrientedLine(
    offEdge=1,
    angle=DynamicNumber(UniformRandom(lbound=0,ubound=360,seed=13))
		    )

# Sheets, connections, and their parameters
topo.sim['Retina'] = GeneratorSheet(input_generator=input_pattern,
                                    period=1.0,phase=0.05,nominal_density=40)

# Note that the learning rates from the original paper must be scaled
# by the number of units in a typical ConnectionField, either 5x5 or 40x40
topo.sim['V1'] = CFSheet(nominal_density=locals().get('default_density',40.0),
                         #RPHACKALERT Find correct radius value 
                         output_fn = KernelMax(kernel_radius=3.5))

topo.sim.connect('Retina','V1',delay=0.05,connection_type=CFProjection,
                 weights_generator = topo.patterns.basic.Line(orientation=DynamicNumber(UniformRandom(lbound=0.0,ubound=2*pi,seed=30))),
                 nominal_bounds_template=BoundingBox(radius=0.1),
                 response_fn = CFPRF_DotProduct_opt(),
                 coord_mapper=XYModulo())

topo.sim['Complex Cell Layer'] = CFSOM(nominal_density=locals().get('default_density',5.0),
                       learning_length=12000,radius_0=0.25,alpha_0=0.99)
                         
topo.sim.connect('V1','Complex Cell Layer',delay=0.05,connection_type=CFProjection,
                 weights_generator = topo.patterns.random.UniformRandom(),
                 nominal_bounds_template=BoundingBox(radius=0.1),
                 response_fn = CFPRF_DotProduct_opt(),
                 learning_fn=CFPLF_Trace(trace_strength=0.2))


