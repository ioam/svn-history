"""
Implementation of Sullivan & de Sa's model from "A temporal trace and
SOM-based model of complex cell development",  Neurocomputing, Volumes
58-60, June 2004, pages 827-833.

NOT YET TESTED.

The following parameters aren't specified in the paper:
Sheet sizes(estimated from diagrams),
Learning rates for both Hebbian and Trace functions,
Input line thickness.

$Id$
"""
__version__='$Revision$'


import numpy

from math import exp, sqrt, fmod, pi, radians,sin,cos

from topo import param

import topo.pattern.random
import topo.pattern.basic

from topo.sheet.generator import GeneratorSheet
from topo.base.boundingregion import BoundingBox
from topo.base.cf import CFProjection,CFPOF_Plugin,CFSheet
from topo.sheet.cfsom import CFSOM
from topo.responsefn.optimized import CFPRF_EuclideanDistance_opt,CFPRF_DotProduct_opt
from topo.learningfn.projfns import CFPLF_Trace, CFPLF_Plugin,  CFPLF_OutstarHebbian
from topo.learningfn.som import CFPLF_HebbianSOM
from topo.misc.numbergenerators import UniformRandom
from topo.outputfn.basic import DivisiveNormalizeL2, KernelMax
from topo.base.functionfamilies import CoordinateMapperFn
from topo.misc.patternfns import line


from math import pi, sin, cos
from numpy import sin,add

from topo.base.patterngenerator import PatternGenerator

# Imported here so that all PatternGenerators will be in the same package
from topo.base.patterngenerator import Constant

from topo.misc.patternfns import gaussian,gabor,line,disk,ring
from topo.base.arrayutil import wrap
from topo.misc.numbergenerators import UniformRandom


# CEBALERT: keep old behavior until we investigate why changing
# to time-controlled dynamic parameters alters the results. 
param.Dynamic.time_fn = None


class XYModulo(CoordinateMapperFn):
    """Return the x coordinate of the given coordinate, modulo the specified step distance."""
 
    grid_element_width = param.Number(1.0/5.0, doc="Length in Sheet coordinates of one large grid element.")
    def __call__(self,x,y):
        #Distance between 8 cells is 0.165, so offset by half that to align with center of box, not corner
        xmod=fmod(x+0.4875,self.grid_element_width)
        ymod=fmod(y+0.4875,self.grid_element_width)
	# x: 0.1 offset to align with center of box, not corner
	# y: offset to align with center of box, not corner
        return x-xmod+0.1,y-ymod+0.08125


class OrientedLine(PatternGenerator):
    """2D line pattern generator, based upon the behaviour of sullivan ."""

    thickness   = param.Number(default=0.006,bounds=(0.0,None),softbounds=(0.0,1.0),
                         precedence=0.60,
                         doc="Thickness (width) of the solid central part of the line.")
    smoothing = param.Number(default=0.05,bounds=(0.0,None),softbounds=(0.0,0.5),
                       precedence=0.61,
                       doc="Width of the Gaussian fall-off.")
    offEdge = param.Number(default=1,doc="1 if previous line has gone off edge of grid, 0 otherwise")
    angle	   = param.Number(default=0.0,doc="")
    def function(self,params):
        if (self.offEdge==1):
            angle=params['angle']
            if (angle>180):
                angle-=180
                direction=-1
            else:
                direction=1
            delta=0.03 #0.03 as grid is 40 cells wide and line moves 1.2 per step
            if (angle == 0):
                self.deltaX = 0 #1000 * XGRIDEND
                self.deltaY = delta
            elif (angle == 90):
                self.deltaY = 0 #1000 * YGRIDEND
                self.deltaX = delta
            elif (angle< 90):
                self.deltaX = delta / sin(radians(angle))
                self.deltaY = delta / sin(radians(90 - angle))
            else:
                self.deltaY = delta / sin(radians(angle - 90))
                self.deltaX = delta / sin(radians(180 - angle))
            if ((angle >= 0) and ( angle < 90)):
                if (direction == 1):
                    startPointx = -0.5
                    startPointy = -0.5
                else:
                    startPointx = 0.5
                    startPointy = 0.5
                    self.deltaX *= -1
                    self.deltaY *= -1
            elif (direction == 1):
                startPointx = -0.5
                startPointy = 0.5
                self.deltaY *= -1;
            else:
                startPointx = 0.5
                startPointy = -0.5 
                self.deltaX*= -1

            self.x=startPointx
            self.y=startPointy
            self.offEdge=0
            self.orientation=angle
        else:
            self.offEdge=0
            self.x+=self.deltaX
            self.y+=self.deltaY
            if (self.x<-0.5 or self.x>0.5 or self.y<-0.5 or self.y>0.5):
               self.offEdge=1
        return line(self.pattern_y,params['thickness'],params['smoothing'])


GeneratorSheet.period = 1.0
GeneratorSheet.phase = 0

input_pattern = OrientedLine(
    offEdge=1,
    angle=UniformRandom(lbound=0,ubound=360,seed=13))


# Sheets, connections, and their parameters
topo.sim['Retina'] = GeneratorSheet(input_generator=input_pattern,
                                    period=1.0,phase=0.05,nominal_density=40)

default_density=locals().get('default_density',50.0)

# Note that the learning rates from the original paper must be scaled
# by the number of units in a typical ConnectionField, either 5x5 or 40x40
topo.sim['V1'] = CFSheet(nominal_density=default_density,
                         #RPHACKALERT Find correct radius value 
                         output_fn = KernelMax(density=default_density,kernel_radius=3.5))

topo.sim.connect('Retina','V1',delay=0.05,connection_type=CFProjection,
                 weights_generator = topo.pattern.basic.Line(orientation=UniformRandom(lbound=0.0,ubound=2*pi,seed=30)),
                 nominal_bounds_template=BoundingBox(radius=0.1),
                 response_fn = CFPRF_DotProduct_opt(),
                 coord_mapper=XYModulo())

topo.sim['Complex Cell Layer'] = CFSOM(nominal_density=locals().get('default_density',5.0),
                       learning_length=12000,radius_0=0.25,alpha_0=0.99)
                         
topo.sim.connect('V1','Complex Cell Layer',delay=0.05,connection_type=CFProjection,
                 weights_generator = topo.pattern.random.UniformRandom(),
                 nominal_bounds_template=BoundingBox(radius=0.1),
                 response_fn = CFPRF_DotProduct_opt(),
                 learning_fn=CFPLF_Trace(trace_strength=0.2))


