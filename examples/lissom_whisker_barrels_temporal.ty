"""
Whisker barrel simulation from Stuart Wilson, using inputs calculated
in Matlab attached to a LISSOM cortical sheet.

$Id$
"""
__version__='$Revision$'


###############################################################################

# The following code is needed before loading to set library path for mlabwrap
# export LD_LIBRARY_PATH=${LD_LIBRARY_PATH}:/opt/matlab-7.4/bin/glnx86

from mlabwrap import mlab
mlab.addpath('examples/whiskers')

from topo.base.parameterclasses import Integer, Number
from topo.base.patterngenerator import PatternGenerator
from topo.commands.analysis import PatternPresenter
import topo
from topo.base.functionfamilies import CoordinateMapperFn

class WhiskerArray(PatternGenerator):
    """
    Simulates a 2D array of whiskers using external Matlab programs. 
    """

    # Becasue of quantisation issues, num_whiskers should be an odd number 
    num_whiskers = Integer(default=3,bounds=(1,None),softbounds=(0.0,10.0),
        precedence=0.31,doc="""
        Square root of the number of whiskers to use.  E.g. 3 gives a 3x3 array.""")

    randomise_ganglion = bool(True)
  
    num_ganglion_cells = Integer(default=8,doc="""
        Route Number of Ganglion Cells per Whisker""")

    deflection = Number(default=pi/4,softbounds=(0.0,2*pi),doc="""
        Whisker Deflection Angle in Radians""")

    # This is useful for the lagged model, in the simple case step = 1
    step = Number(default=0,doc="""
        Number of steps at the given speed to move in the sweep direction.
        The distance moved is speed*step.""")

    speed = Number(default=0.09,bounds=(0.0,None),doc="""
        Sweep speed: Distance moved in a time step, also scales the deflection""")

    rectify = Integer(default=1,bounds=(0,1),doc="""
        Whether or not to supress firing in depreseed ganglion. 1 is to rectify, 0 is to not""")

    whisker = Integer(default=(0), doc="""
        Which whiskers are to receive inputs, use 0 for all""")
    
    step_size = Number(default = 0.75,doc="""
      Scaling of the distance, must be fine tuned to geive good results...This needs to be figured out""")

    pipe_size = Integer(default=100,doc="""
      Route elements to define the pipe. A larger size means a more smoothly defined Gaussian drop off""")

    pipe_sigma=Integer(default=20, doc="""
       Sets the sigma of the pipe falloff""")

    pipe_sigma_on=Number(default=0.1, doc="""
       Falloff for the RA ON response""")

    pipe_sigma_off=Number(default=0.9, doc="""
       Falloff for the RA OFF response""")

    pipe_off_strength= Number(default=0, doc="""
       Height of the RA OFF response""") 
    
    single_whisker_plot = Integer(default=2)

    random_seed = Number(default = 310) # was 5489 for all sims in thesis
    

    def __init__(self,**params):
        super(WhiskerArray,self).__init__(**params)
        self.ganglion_cell_positions=mlab.shuffle(self.num_whiskers,self.num_ganglion_cells,self.random_seed)
        self.whisking_pipe=mlab.pipe(self.pipe_size,
                                               self.pipe_sigma_on,
                                               self.pipe_sigma_off,
                                               self.pipe_off_strength,
                                               self.num_whiskers)
        
    def function(self,**params):
        deflection = params.get('deflection',self.deflection)
	#use mlab.sweep for correlated model, mlab.sweep_uncor for uncorrelated model, mlab.sweep_random for the random model, and mlab.sweep_anticor for anticorrelated model reported in the thesis. ***Although these models havent bee tried yet, might randomise for each time sheet which would be inappropriate.         
	self.firing_rates = mlab.sweep(
                                    self.num_whiskers,
				    self.num_ganglion_cells,
				    self.whisking_pipe,
                                    self.step_size,
				    self.rectify, 
				    self.speed, 
				    360*self.deflection/2.0/pi,
				    self.step+1,
                                    self.whisker)
	if self.randomise_ganglion ==True:
            inputs = mlab.generate_barrelettes(self.firing_rates, self.ganglion_cell_positions)
        else:
            inputs =  mlab.generate_barrelettes(self.firing_rates, 0)
        
        return inputs

    
###############################################################################

class TestWhiskerArray(PatternGenerator):
    """
    A second WhiskerArray Class for testing the Map
    """

    # JABALERT: The parameter definitions here are quite arbitrary, e.g.
    # differing over whether they are a square number or a square root.
    # Should be generalized to handle a full range of reasonable values.
    num_whiskers = WhiskerArray.num_whiskers

    randomise_ganglion = WhiskerArray.randomise_ganglion
  
    num_ganglion_cells = WhiskerArray.num_ganglion_cells

    deflection = Number(default=pi/4,softbounds=(0.0,2*pi),doc="""
        Deflection of whisker array motion, in radians from 0 to 2*pi, assuming a stationary surface.""")
   
    speed = Number(1)
    
    rectify = Integer(default=1,bounds=(0,1),doc="""
        Whether or not to supress firing in depreseed ganglion. 1 is to rectify, 0 is to not""")
    
    whisker = Integer(default=0, doc="""
        Which whiskers are to receive inputs, use 0 for all""")
	
    show_matlab_plots = Integer(default=0,doc="""
	Use 1 to display the plots in matlab""")
    

    def __init__(self,**params):
        super(TestWhiskerArray,self).__init__(**params)
        self.ganglion_cell_positions=mlab.shuffle(self.num_whiskers,self.num_ganglion_cells,WhiskerArray.random_seed)
        

    def function(self,**params):
        deflection = params.get('deflection_spatial',self.deflection)
        self.firing_rates = mlab.test_deflections(
                                    WhiskerArray.num_whiskers,
				    WhiskerArray.num_ganglion_cells,
				    WhiskerArray.rectify, 
				    1,
				    360*self.deflection/2.0/pi,
                                    self.whisker)
        if self.randomise_ganglion ==True:
            inputs = mlab.generate_barrelettes(self.firing_rates, self.ganglion_cell_positions)
        else:
            inputs =  mlab.generate_barrelettes(self.firing_rates, 0)
        
        return inputs


###############################################################################


class WhiskerBotData(PatternGenerator):
    """
    A third class for plugging whiskerBot data into the map. Some original whiskerbot sims are left in to give the idea of how this works
    """

    # JABALERT: The parameter definitions here are quite arbitrary, e.g.
    # differing over whether they are a square number or a square root.

    num_whiskers = WhiskerArray.num_whiskers

    randomise_ganglion = WhiskerArray.randomise_ganglion 
	
    whiskerBot_gain = Number(default=3.14,bounds=(0.0,20.0),doc="""
	 Scale the whiskerBot strain data""")
    
    rectify = Integer(default=1,bounds=(0,1),doc="""
        Whether or not to supress firing in depreseed ganglion. 1 is to rectify, 0 is to not""")

    time_step = Integer(default = 1,bounds=(1,50),doc="""
    		Numbered frame from the WhiskerBot simulation""")

    whiskerBot_data = Integer(default = 1,doc="""
		Choose WhiskerBot data to present. Data are stored in examples/whiskers/wbot_object_data:
		1: Concave surface,2:Ball,3:Chequerboard,4:vertical ridges""") 
	
    plot_vectors = Integer(default = 1,bounds=(0,1),doc="""
		Display vector plots from matlab""")
		
    

    def __init__(self,**params):
        super(WhiskerBotData,self).__init__(**params)
        # Should probably specify a fixed seed for the random numbers
        # so that the positions won't change on each run
        self.ganglion_cell_positions=mlab.shuffle(WhiskerArray.num_whiskers,WhiskerArray.num_ganglion_cells,WhiskerArray.random_seed)
	self.wbot_data=mlab.load("wbot_data_new")

	
    def function(self,**params):
	if self.whiskerBot_data==1:
		self.wbot_x=self.wbot_data.back_new_x
		self.wbot_y=self.wbot_data.back_new_y
	elif self.whiskerBot_data==2:
		self.wbot_x=self.wbot_data.diagonal_back_x
		self.wbot_y=self.wbot_data.diagonal_back_y
	elif self.whiskerBot_data==3:
		self.wbot_x=self.wbot_data.vertical_new_x
		self.wbot_y=self.wbot_data.vertical_new_y
	elif self.whiskerBot_data==4:
		self.wbot_d=mlab.load("cheque_data")
		self.wbot_x=self.wbot_d.cheque_final_x
		self.wbot_y=self.wbot_d.cheque_final_y

        self.firing_rates = mlab.whiskerbot_frame(self.wbot_x,
						  self.wbot_y,
						  self.whiskerBot_gain,
						  WhiskerArray.rectify,
						  WhiskerArray.num_ganglion_cells,
						  self.time_step,
						  self.plot_vectors)
        if self.randomise_ganglion ==True:
            inputs = mlab.generate_barrelettes(self.firing_rates, self.ganglion_cell_positions)
        else:
            inputs =  mlab.generate_barrelettes(self.firing_rates, 0)
        
        return inputs


###############################################################################
from topo.base.sheetview import SheetView

def specify_whisker_deflections():
   """
   Ask Matlab for the deflection preference for each input pixel,
   and create a SheetView with that information to be used for
   colorizing plots.
   """
   from mlabwrap import mlab
    
   for sheet in topo.sim.objects(GeneratorSheet).values():
        # get data from matlab, getting deflection pref as a number between 0 and 2 pi
        ganglion_preferences = mlab.ganglion_labels(sheet.input_generator.ganglion_cell_positions,
                                                    WhiskerArray.num_ganglion_cells,
                                                    WhiskerArray.num_whiskers)
	new_view = SheetView((ganglion_preferences,sheet.bounds), sheet.name,sheet.precedence,topo.sim.time())
        sheet.sheet_view_dict['DeflectionPreference']=new_view


#######################################################################################################
# Stuart Wilson: 
# This is the same as measure_or_pref in analysis.py, but edited to measure deflection preferences. 
# Developed for use with the barrel cortex model
 

from topo.plotting.templates import new_pgt

pgt= new_pgt(name='Deflection Preference',category="Preference Maps",
             doc='Measure preference for direction stimulus for a lagged model.',
             command='measure_deflection_pref()')
pgt.add_plot('Deflection Preference',[('Hue','DeflectionPreference')])
pgt.add_plot('Deflection Preference&Selectivity',[('Hue','DeflectionPreference'),
						   ('Confidence','DeflectionSelectivity')])
pgt.add_plot('Deflection Selectivity',[('Strength','DeflectionSelectivity')])
pgt.add_plot('Whisker Preference',[('Strength','WhiskerPreference')])
pgt.add_plot('Whisker Selectivity',[('Strength','WhiskerSelectivity')])
pgt.add_static_image('Color Key','examples/whiskers/key.png')


def measure_deflection_pref(num_deflection=12,
                    scale=0.3,offset=0.0,display=False,weighted_average=False,
                    pattern_presenter=PatternPresenter(pattern_generator=TestWhiskerArray(),apply_output_fn=False,duration=0.175)):
    
    """  
    Measure deflection maps, 
    * This needs to be commented
    Measures maps by collating the responses to a set of input
    patterns controlled by some parameters.  The parameter ranges and
    number of input patterns in each range are determined by the
    num_phase, num_deflection, and frequencies parameters.  24The
    particular pattern used is determined by the pattern_presenter
    argument, which defaults to a WhiskerArray sim presented for a short
    duration.  By convention, most Topographica example files
    are designed to have a suitable activity pattern computed by
    that time, but the duration will need to be changed for other
    models that do not follow that convention.
    * This needs to be commented
    # Could consider having scripts set a variable for the duration,
    # based on their own particular model setup, and to have it read
    # from here.  Instead, assumes a fixed default duration right now...
    """
    if num_deflection <= 0:
        raise ValueError("num_deflection must be greater than 0")

    else:
	 step_deflection=pi/num_deflection
        
    step_whiskers = WhiskerArray.num_whiskers

    feature_values = [Feature(name="whisker",range=(1, WhiskerArray.num_whiskers*WhiskerArray.num_whiskers
),step=1,cyclic=False), Feature(name="deflection",range=(0.0,2*pi),step=step_deflection,cyclic=True)]
        
    param_dict = {"scale":scale,"offset":offset}
    x=FeatureMaps(feature_values)
    x.collect_feature_responses(pattern_presenter,param_dict,display,weighted_average)
        
###############################################################################
"""
Divides the cortical sheet into barrel fields, 1 for each whisker
""" 

class XYModulo(CoordinateMapperFn):
    def __call__(self,x,y):
	xmod=(1.0/WhiskerArray.num_whiskers)*(int((WhiskerArray.num_whiskers*x)+(WhiskerArray.num_whiskers*0.5))-((WhiskerArray.num_whiskers-1)/2))
	ymod=(1.0/WhiskerArray.num_whiskers)*(int((WhiskerArray.num_whiskers*y)+(WhiskerArray.num_whiskers*0.5))-((WhiskerArray.num_whiskers-1)/2))
	return  xmod,ymod

###############################################################################


import fixedpoint
import numpy
import copy

from math import pi, sqrt, fmod
from fixedpoint import FixedPoint

import topo.patterns.basic
import topo.patterns.random

from topo.patterns.basic import Gaussian,Sweeper
from topo.sheets.lissom import LISSOM
from topo.sheets.generatorsheet import GeneratorSheet
from topo.projections.basic import CFProjection
from topo.responsefns.optimized import CFPRF_DotProduct_opt
from topo.base.parameterclasses import DynamicNumber
from topo.base.cf import CFSheet
from topo.base.boundingregion import BoundingBox
from topo.learningfns.optimized import CFPLF_Hebbian_opt
from topo.outputfns.optimized import CFPOF_DivisiveNormalizeL1_opt
from topo.outputfns.basic import PiecewiseLinear, DivisiveNormalizeL1
from topo.misc.numbergenerators import UniformRandom


topo.sim.name = "lissom_whisker_barrels"
	      
num_inputs=WhiskerArray.num_whiskers 
                                 
# Default for tutorial
topo.patterns.basic.Line.scale=0.9
topo.patterns.basic.Gaussian.size=0.08333
topo.patterns.basic.Gaussian.aspect_ratio=4.0

# Specify weight initialization, response function, and learning function
numpy.random.seed((500,500))

#CFProjection.weights_shape = topo.patterns.basic.Disk(smoothing=0.0)
CFProjection.weights_shape = topo.patterns.basic.Constant()
CFProjection.weights_generator = topo.patterns.basic.Constant()
CFProjection.response_fn=CFPRF_DotProduct_opt()
CFProjection.learning_fn=CFPLF_Hebbian_opt()
CFProjection.weights_output_fn=CFPOF_DivisiveNormalizeL1_opt()



###########################################


# build simulation

# Number of separate delay lines from the input surface
num_lags=4
num_whiskers=WhiskerArray.num_whiskers
num_ganglion_cells=WhiskerArray.num_ganglion_cells

for i in xrange(num_lags):
    topo.sim['Ganglia'+str(i)]=GeneratorSheet(nominal_density=num_whiskers*num_ganglion_cells,
                                             input_generator=WhiskerArray(num_whiskers=num_whiskers,num_ganglion_cells=num_ganglion_cells,step=i,
											       deflection=DynamicNumber(UniformRandom(lbound=0,ubound=2*pi,seed=23))),
                                             period=1.0, phase=0.05,
                                             nominal_bounds=BoundingBox(radius=0.5))


topo.sim['S1'] = LISSOM(nominal_density=locals().get('default_density',16*WhiskerArray.num_whiskers),tsettle=9,
                        nominal_bounds=BoundingBox(radius=0.5))


topo.sim['S1'].output_fn.lower_bound=0.083
topo.sim['S1'].output_fn.upper_bound=0.633


for i in xrange(num_lags):

    topo.sim.connect('Ganglia'+str(i),'S1',delay=FixedPoint("0.05"),dest_port=('Activity','JointNormalize', 'Afferent'),
                     connection_type=CFProjection,strength=1.0,name='Afferent'+str(i),
                     weights_generator=topo.patterns.basic.Composite(generators=[Gaussian(aspect_ratio=1.0, size=2*0.27083),
                                                                                 topo.patterns.random.UniformRandom()]), nominal_bounds_template=BoundingBox(radius=0.53/WhiskerArray.num_whiskers),learning_rate=0.85, coord_mapper=XYModulo()) 
                   


topo.sim.connect('S1','S1',delay=FixedPoint("0.05"),name='LateralExcitatory',
                 connection_type=CFProjection,strength=0.9,
                 weights_generator=topo.patterns.basic.Composite(operator=numpy.multiply, 
                                                                 generators=[Gaussian(aspect_ratio=1.0, size=2*0.10417),
                                                                             topo.patterns.random.UniformRandom()]),
                 nominal_bounds_template=BoundingBox(radius=0.10417),learning_rate=2.55528) 
                 
            
topo.sim.connect('S1','S1',delay=FixedPoint("0.05"),name='LateralInhibitory',
                 connection_type=CFProjection,strength=-0.9,
                 weights_generator=topo.patterns.basic.Composite(operator=numpy.multiply, 
                                                                 generators=[Gaussian(aspect_ratio=1.0, size=2*0.22917),
                                                                             topo.patterns.random.UniformRandom()]),
                 nominal_bounds_template=BoundingBox(radius=0.22917),learning_rate=1.80873) 


### Actions scheduled to occur as the simulation proceeds.

topo.sim.startup_commands.append("from topo.base.boundingregion import BoundingBox")

# Convenience variable: timescale
st=1.0/num_inputs

### Lateral excitatory bounds changes
LE='topo.sim["S1"].projections()["LateralExcitatory"]'

topo.sim.schedule_command(  200*st,LE+'.change_bounds(BoundingBox(radius=0.06250))')
topo.sim.schedule_command(  500*st,LE+'.change_bounds(BoundingBox(radius=0.04375))')
topo.sim.schedule_command( 1000*st,LE+'.change_bounds(BoundingBox(radius=0.03500))')
topo.sim.schedule_command( 2000*st,LE+'.change_bounds(BoundingBox(radius=0.02800))')
topo.sim.schedule_command( 3000*st,LE+'.change_bounds(BoundingBox(radius=0.02240))')
topo.sim.schedule_command( 4000*st,LE+'.change_bounds(BoundingBox(radius=0.01344))')
topo.sim.schedule_command( 5000*st,LE+'.change_bounds(BoundingBox(radius=0.00806))')
topo.sim.schedule_command( 6500*st,LE+'.change_bounds(BoundingBox(radius=0.00484))')
topo.sim.schedule_command( 8000*st,LE+'.change_bounds(BoundingBox(radius=0.00290))')
topo.sim.schedule_command(20000*st,LE+'.change_bounds(BoundingBox(radius=0.00174))')

### Lateral excitatory learning rate changes
topo.sim.schedule_command(  200*st,LE+'.learning_rate=0.12168*'+LE+'.n_units()')
topo.sim.schedule_command(  500*st,LE+'.learning_rate=0.06084*'+LE+'.n_units()')
topo.sim.schedule_command( 1000*st,LE+'.learning_rate=0.06084*'+LE+'.n_units()')
topo.sim.schedule_command( 2000*st,LE+'.learning_rate=0.06084*'+LE+'.n_units()')
topo.sim.schedule_command( 3000*st,LE+'.learning_rate=0.06084*'+LE+'.n_units()')
topo.sim.schedule_command( 4000*st,LE+'.learning_rate=0.06084*'+LE+'.n_units()')
topo.sim.schedule_command( 5000*st,LE+'.learning_rate=0.06084*'+LE+'.n_units()')
topo.sim.schedule_command( 6500*st,LE+'.learning_rate=0.06084*'+LE+'.n_units()')
topo.sim.schedule_command( 8000*st,LE+'.learning_rate=0.06084*'+LE+'.n_units()')
topo.sim.schedule_command(20000*st,LE+'.learning_rate=0.06084*'+LE+'.n_units()')

### Afferent learning rate changes
for i in xrange(num_lags):
    AFF ='topo.sim["S1"].projections()["Afferent'+str(i)+'"]'
topo.sim.schedule_command(  500*st,AFF+'.learning_rate=0.6850')
topo.sim.schedule_command( 2000*st,AFF+'.learning_rate=0.5480')
topo.sim.schedule_command( 4000*st,AFF+'.learning_rate=0.4110')
topo.sim.schedule_command(20000*st,AFF+'.learning_rate=0.2055')

### Activation function threshold changes
OF='topo.sim["S1"].output_fn'

topo.sim.schedule_command(  200*st,OF+'.lower_bound=0.093;'+OF+'.upper_bound=0.643')
topo.sim.schedule_command(  500*st,OF+'.lower_bound=0.103;'+OF+'.upper_bound=0.643')
topo.sim.schedule_command( 1000*st,OF+'.lower_bound=0.133;'+OF+'.upper_bound=0.663')
topo.sim.schedule_command( 2000*st,OF+'.lower_bound=0.163;'+OF+'.upper_bound=0.683')
topo.sim.schedule_command( 3000*st,OF+'.lower_bound=0.183;'+OF+'.upper_bound=0.713')
topo.sim.schedule_command( 4000*st,OF+'.lower_bound=0.183;'+OF+'.upper_bound=0.743')
topo.sim.schedule_command( 5000*st,OF+'.lower_bound=0.193;'+OF+'.upper_bound=0.773')
topo.sim.schedule_command( 6500*st,OF+'.lower_bound=0.203;'+OF+'.upper_bound=0.803')
topo.sim.schedule_command( 8000*st,OF+'.lower_bound=0.213;'+OF+'.upper_bound=0.833')
topo.sim.schedule_command(20000*st,OF+'.lower_bound=0.223;'+OF+'.upper_bound=0.863')


### Settling steps changes
topo.sim.schedule_command( 2000*st,'topo.sim["S1"].tsettle=10')
topo.sim.schedule_command( 5000*st,'topo.sim["S1"].tsettle=11')
topo.sim.schedule_command( 6500*st,'topo.sim["S1"].tsettle=12')
topo.sim.schedule_command( 8000*st,'topo.sim["S1"].tsettle=13')

# default locations for model editor
topo.sim.grid_layout([[None, 'S1'],
                      [('Ganglia'+str(i)) for i in xrange(num_lags)]],
                     xstart=150, xstep=150)



