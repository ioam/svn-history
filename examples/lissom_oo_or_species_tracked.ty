""" 

$Id$
"""
__version__='$Revision: 8197 $'

import fixedpoint
import numpy

from math import pi, sqrt
from fixedpoint import FixedPoint

import topo.pattern.basic
import topo.pattern.random

from topo.pattern.basic import Gaussian, Rectangle
from topo.sheet.lissom import JointScaling, LISSOM
from topo.sheet.generator import GeneratorSheet
from topo.projection.basic import CFProjection, SharedWeightCFProjection
from topo.responsefn.optimized import CFPRF_DotProduct_opt
from topo.base.cf import CFSheet, CFPLF_PluginScaled, CFPOF_Plugin
from topo.base.boundingregion import BoundingBox
from topo.learningfns.optimized import CFPLF_Hebbian_opt
from topo.outputfns.optimized import CFPOF_DivisiveNormalizeL1_opt
from topo.outputfns.basic import PiecewiseLinear, DivisiveNormalizeL1, PipelineOF, IdentityOF, ActivityAveragingOF, AttributeTrackingOF 
from topo.outputfns.basic import Sigmoid, HalfRectify, HomeostaticMaxEnt
from topo.misc.numbergenerators import UniformRandom, BoundedNumber, ExponentialDecay, ExponentialRandom
from topo.patterns.image import Image
from topo.coordmapperfns.basic import Jitter, ExpJitter
import contrib.jsldefs
from contrib.jsldefs import species_analysis_function


species=locals().get('species',"mouse")
onoff = locals().get('onoff',False)
jitter=locals().get('jitter',True)
on_probability=locals().get('on_probability', 0.5)
patches=locals().get('patches',3.0) #in model coordinates 1.0 x 1.0 is one 2-photon patch - assume these are approx  330x330um
#########Parameters specific to species#############################

#Representing 1 slice 2-photon imaging of a patch of V1###
if species=="cat":
    topo.sim.name="cat"

    #jitter is in sheet coordinates - need to convert to um or degrees
    jitter_scale=locals().get('jitter_scale',0.0) #jitter scale*2 is max jitter selected from a uniform random distribution
    ret_jitter_scale=locals().get('ret_jitter_scale',0.0) # corresponds to retinal mosaic jitter from grid - 0.01deg, on and off jittered differently by default

    #LGN RF sizes
    #Using magnification factor in um/deg
    mag_factor=locals().get('mag_factor',667)
    #LGN centre size in deg
    centre_size=locals().get('centre_size',0.515)
    #Total Retina size in degrees
    ret_deg_size=patches*330/mag_factor
    #LGN centre size in sheet coordinates
    centre_size_sc=centre_size*mag_factor/330
    

    #retina (average of 10deg from ac) is approx 1.48x1.48 deg 
    #assuming that we are in central 20deg - average X cell diameter = 0.515 deg

    centerg   = Gaussian(size=centre_size_sc,aspect_ratio=1.0,output_fn=DivisiveNormalizeL1())
    surroundg = Gaussian(size=centre_size_sc*4,aspect_ratio=1.0,output_fn=DivisiveNormalizeL1())

    #Receptive field sizes (radii)
    Afferent_size=centre_size_sc*2 #to account for full surround
    LGNAfferent_size=locals().get('LGNAfferent_size',1.5) #500um #990diameter
    Lat_inh_size=locals().get('Lat_inh_size',1.5) #should be 2mm but too big to include - made full extent of V1 area
    Lat_exc_size=locals().get('Lat_exc_size',0.23) #approx 150um diameter

    #Sheet sizes - total of 2 photon patches
    V1_size = patches*1.0/2
    LGN_size = V1_size + LGNAfferent_size +jitter_scale
    Retina_size= LGN_size + Afferent_size + ret_jitter_scale

    #0.3 mm corresponds to about 10 units from 2 photon in V1
    default_density = locals().get('default_density',10)
    #LGN density - from ratio of lgn to V1 size
    default_lgn_density = locals().get('default_lgn_density',4.0) #assuming increased density in lgn
    #Retinal density to ensure smoothness
    default_retinal_density = locals().get('default_retinal_density',20)
    ret_strength=locals().get('ret_strength',10)
    input_bounds=locals().get('input_bounds',Retina_size)
  
    #Type of input
    dataset=locals().get('dataset',"Natural")

    gauss_size=locals().get('gauss_size',centre_size_sc) 
    nat_size=locals().get('nat_size', Retina_size/5)
    aspect_ratio=locals().get('aspect_ratio',4)
    num_inputs=locals().get('num_inputs',2)
    scale= locals().get('scale', 1.0)

    #Type of connection field
    lat_cloud= locals().get('lat_cloud', False)
    aff_cloud= locals().get('aff_cloud', False)

    #frequency and balance between afferent and lateral activity
    #frequency=locals().get('frequency',2)
    mu=locals().get('mu',0.01)
    #balance = locals().get('balance',5.9)
    afferent_target = locals().get('afferent_target',0.059)
    target_lr=locals().get('target_lr',0.04)

if species=="mouse":
    topo.sim.name="mouse"

    #jitter is in sheet coordinates - need to convert to um or degrees
    jitter_scale=locals().get('jitter_scale',0.0) #jitter scale/2 is max jitter selected from a uniform random distribution
    ret_jitter_scale=locals().get('ret_jitter_scale',0.0) # corresponds to retinal mosaic jitter from grid - 0.01deg

    #LGN RF sizes
    #Using magnification factor in um/deg
    mag_factor=locals().get('mag_factor',15.0)
    #LGN centre size in deg
    centre_size=locals().get('centre_size',6.0)
    surround_size=locals().get('surround_size',17.0)
    #Total Retina size in degrees
    ret_deg_size=patches*330/mag_factor
    #LGN centre size in sheet coordinates
    centre_size_sc=centre_size*mag_factor/330
    surround_size_sc=surround_size*mag_factor/330
    
   
    centerg   = Gaussian(size=centre_size_sc,aspect_ratio=1.0,output_fn=DivisiveNormalizeL1())
    surroundg = Gaussian(size=surround_size_sc,aspect_ratio=1.0,output_fn=DivisiveNormalizeL1())

    #Receptive field sizes (radii)
    Afferent_size=surround_size_sc/2.0 #to account for full surround
    LGNAfferent_size=locals().get('LGNAfferent_size',1.52/2) #500um 
    Lat_inh_size=locals().get('Lat_inh_size',1.5) #should be 2mm but too big to include - made full extent of V1 area
    Lat_exc_size=locals().get('Lat_exc_size',0.23) #approx 150um diameter

    #Sheet sizes - total of 2 photon patches
    V1_size = patches*1.0/2.0
    LGN_size = V1_size + LGNAfferent_size +jitter_scale
    Retina_size= LGN_size + Afferent_size + ret_jitter_scale 

    #0.3 mm corresponds to about 10 units from 2 photon in V1
    default_density = locals().get('default_density',10.0)
    #LGN density - from ratio of lgn to V1 size
    default_lgn_density = locals().get('default_lgn_density',10.0)
    #Retinal density to ensure smoothness
    default_retinal_density = locals().get('default_retinal_density',20.0)
    ret_strength=locals().get('ret_strength',5)# increase in this case because lgn activity weak just speeds things up
    input_bounds=locals().get('input_bounds',Retina_size)
  
    #Type of input
    dataset=locals().get('dataset',"Natural")

    gauss_size=locals().get('gauss_size',centre_size_sc) 
    nat_size=locals().get('nat_size', Retina_size/5)
    aspect_ratio=locals().get('aspect_ratio',4)
    num_inputs=locals().get('num_inputs',2)
    scale= locals().get('scale', 1.0)

    #Type of connection field
    lat_cloud= locals().get('lat_cloud', False)
    aff_cloud= locals().get('aff_cloud', False)

    #frequency and balance between afferent and lateral activity
    frequency=locals().get('frequency',2) #2 for 2 gaussians 
    mu=locals().get('mu',0.0025*frequency)
    balance = locals().get('balance',4)
    afferent_target = locals().get('afferent_target',mu*balance)
    target_lr=locals().get('target_lr', 0.04)


###############################################################
####Different input types which can be used for development###
#set the input type by choosing the dataset parameter 

#Set targets based on frequency of occurance of V1 activation

if dataset=="Gaussian":
    input_type=Gaussian
    #in the case where dataset=Gaussian, must also set the number of Gaussians per iteration, default is 2
    inputs=[input_type(x=UniformRandom(lbound=-input_bounds,ubound=input_bounds,seed=12+i),
                       y=UniformRandom(lbound=-input_bounds,ubound=input_bounds,seed=35+i),
                       orientation=UniformRandom(lbound=-pi,ubound=pi,seed=21+i),
                       size=gauss_size, aspect_ratio=aspect_ratio, scale=scale, bounds=BoundingBox(radius=input_bounds))
            #Set the contrast of the gaussian patterns by setting the scale parameter.
            for i in xrange(num_inputs)]
    
    combined_inputs = topo.pattern.basic.SeparatedComposite(min_separation=0,generators=inputs)
    
elif dataset=="Natural":
    
    input_type=topo.pattern.image.Image
    image_filenames=["/group/project/csng/images/mcgill_img/foliage/%02d.png"%(i+1) for i in xrange(98)]
    inputs=[input_type(filename=f,
                       size=nat_size, size_normalization='original',
                       x=UniformRandom(lbound=-0.75,ubound=0.75,seed=12),
                       y=UniformRandom(lbound=-0.75,ubound=0.75,seed=36),
                       orientation=UniformRandom(lbound=-pi,ubound=pi,seed=65))
		for f in image_filenames]

    combined_inputs =topo.pattern.basic.Selector(generators=inputs)

elif dataset=="NoisyDisks":
    disk_scale=locals().get('diskscale',0.35)
    #Set the contrast of the disk pattern by setting the disk_scale parameter, map development also depends on the contrast of the disk edges.
    input_type=topo.pattern.basic.Composite
    inputs=[input_type(operator=numpy.add,
                       generators=[topo.pattern.basic.Disk(x=UniformRandom(lbound=-2.125,ubound=2.125,seed=12),
                                                            y=UniformRandom(lbound=-2.125,ubound=2.125,seed=36),
                                                            size=2.0, aspect_ratio=1.0, scale=disk_scale,
                                                            offset=0.5,
                                                            bounds=BoundingBox(radius=input_bounds), smoothing=0.1),
                                   topo.pattern.random.UniformRandom(offset=locals().get('rand_offset',-0.5), scale=locals().get('rand_scale',1.0))])]
    #Set the scale of the noise by setting the rand_offset and rand_scale parameters, note that the disk/noise signal ratio also depends on the retinal density      
    combined_inputs =topo.pattern.basic.Selector(generators=inputs)

elif dataset=="Disks":
    disk_scale=locals().get('diskscale',0.5)
    input_type=topo.pattern.basic.Disk
    inputs=[input_type(x=UniformRandom(lbound=-2.125,ubound=2.125,seed=12),
                       y=UniformRandom(lbound=-2.125,ubound=2.125,seed=36),
                       size=2.0, aspect_ratio=1.0, scale=disk_scale,
                       offset=0.5,
                       bounds=BoundingBox(radius=input_bounds), smoothing=0.1)]
            
    combined_inputs =topo.pattern.basic.Selector(generators=inputs)

elif dataset=="NoisyDiskstoNatural":
    #This dataset mimics pre and post eye-opening development - scheduled changes must also be set to ensure the input pattern changes at simulated eye opening
    disk_scale=locals().get('diskscale',0.35)
    disks_input_type=topo.pattern.basic.Composite
    disks_inputs=[disks_input_type(operator=numpy.add,
                       generators=[topo.pattern.basic.Disk(x=UniformRandom(lbound=-2.125,ubound=2.125,seed=12),
                                                            y=UniformRandom(lbound=-2.125,ubound=2.125,seed=36),
                                                            size=2.0, aspect_ratio=1.0, scale=disk_scale,
                                                            offset=0.5,
                                                            bounds=BoundingBox(radius=input_bounds), smoothing=0.1),
                                   topo.pattern.random.UniformRandom(offset=locals().get('rand_offset',-0.5), scale=locals().get('rand_scale',1.0))])]

    combined_inputs =topo.pattern.basic.Selector(generators=disks_inputs)      
   
    
    natural_input_type=topo.pattern.image.Image
    image_filenames=["images/shouval/combined%02d.png"%(i+1) for i in xrange(25)]
    natural_inputs=[natural_input_type(filename=f,
                       size=10.0,  #size_normalization='original',(size=10.0)
                       x=UniformRandom(lbound=-0.75,ubound=0.75,seed=12),
                       y=UniformRandom(lbound=-0.75,ubound=0.75,seed=36),
                       orientation=UniformRandom(lbound=-pi,ubound=pi,seed=65))
		for f in image_filenames]

    natural_combined_inputs =topo.pattern.basic.Selector(generators=natural_inputs)

###############################################################################

#Sheet coordinates of units to track for debugging
units=locals().get('units',[(0.0, 0.0)])

#Smoothing value for exponential averaging
smoothing=locals().get('smoothing',0.999)
V1_smoothing=locals().get('V1_smoothing',0.999) # Allows different smoothing for averaging  V1 activity and averaging afferent activity.

#Output functions: Sheets
#LGN
LGN_on_output_fn=HalfRectify()
LGN_off_output_fn=HalfRectify()

#V1
Attrib_Tracker=AttributeTrackingOF(object="topo.sim['V1']", attrib_names=['x_avg', 'sf', 'lr_sf', 'scaled_x_avg'], units=units)
HE=HomeostaticMaxEnt(smoothing=V1_smoothing,
                     eta=locals().get('eta',0.016), mu=mu, step=9)
V1_Tracker=AttributeTrackingOF(object=HE, coordframe="topo.sim['V1']",attrib_names=['a', 'b','y_avg'], units=units, step=9)
V1_OF=PipelineOF(output_fns=[Attrib_Tracker, HE, V1_Tracker])
       
#Output Functions: Projections
#Debugging
#LGNOnAfferent
LGNOn_Avg=ActivityAveragingOF(smoothing=smoothing,step=1)
LGNOn_Tracker=AttributeTrackingOF(object=LGNOn_Avg,coordframe="topo.sim['V1']", attrib_names=['x_avg'], units=units, step=1)
LGNOn_OF = PipelineOF(output_fns=[LGNOn_Avg, LGNOn_Tracker])

#LGNOffAfferent
LGNOff_Avg=ActivityAveragingOF(smoothing=smoothing,step=1)
LGNOff_Tracker=AttributeTrackingOF(object=LGNOff_Avg,coordframe="topo.sim['V1']", attrib_names=['x_avg'], units=units, step=1)
LGNOff_OF = PipelineOF(output_fns=[LGNOff_Avg, LGNOff_Tracker])

#LateralExcitatory
LatEx_Avg=ActivityAveragingOF(initial_average=0.0,smoothing=smoothing,step=1)
LatEx_Tracker=AttributeTrackingOF(object=LatEx_Avg,coordframe="topo.sim['V1']", attrib_names=['x_avg'], units=units, step=1)
LatEx_OF = PipelineOF(output_fns=[LatEx_Avg, LatEx_Tracker])

#LateralInhibitory
LatIn_Avg=ActivityAveragingOF(initial_average=0.0,smoothing=smoothing,step=1)
LatIn_Tracker = AttributeTrackingOF(object=LatIn_Avg,coordframe="topo.sim['V1']", attrib_names=['x_avg'], units=units, step=1)
LatIn_OF = PipelineOF(output_fns=[LatIn_Avg, LatIn_Tracker])

# Specify weight initialization, response function, and learning function
CFProjection.cf_shape = topo.pattern.basic.Disk(smoothing=0.0)
CFProjection.weights_generator = topo.pattern.basic.Constant()
CFProjection.response_fn=CFPRF_DotProduct_opt()
CFProjection.learning_fn=CFPLF_Hebbian_opt()
CFProjection.weights_output_fn=CFPOF_DivisiveNormalizeL1_opt()
SharedWeightCFProjection.response_fn=CFPRF_DotProduct_opt()


# DoG weights for the LGN
    
on_weights = topo.pattern.basic.Composite(
    generators=[centerg,surroundg],operator=numpy.subtract)

off_weights = topo.pattern.basic.Composite(
    generators=[surroundg,centerg],operator=numpy.subtract)

#if jitter==True:
#    if onoff==False:
#        jitterOn = ExpJitter(gen =ExponentialRandom(seed=1023), scale=jitter_scale)
#        jitterOff = ExpJitter(gen =ExponentialRandom(seed=1023), scale=jitter_scale)
#    else:
#        jitterOn = ExpJitter(gen =ExponentialRandom(seed=1023), scale=jitter_scale)
#        jitterOff = ExpJitter(gen =ExponentialRandom(seed=523), scale=jitter_scale)
#
#        
#    ret_jitterOn = ExpJitter(gen =ExponentialRandom(seed=10), scale=ret_jitter_scale)
#    ret_jitterOff = ExpJitter(gen =ExponentialRandom(seed=453), scale=ret_jitter_scale)


if onoff==False:
    jitterOn = Jitter(gen =UniformRandom(seed=1023), scale=jitter_scale)
    jitterOff = Jitter(gen =UniformRandom(seed=1023), scale=jitter_scale)

else:
    jitterOn = Jitter(gen =UniformRandom(seed=1023), scale=jitter_scale)
    jitterOff = Jitter(gen =UniformRandom(seed=523), scale=jitter_scale)
    
    
ret_jitterOn = Jitter(gen =UniformRandom(seed=10), scale=ret_jitter_scale)
ret_jitterOff = Jitter(gen =UniformRandom(seed=453), scale=ret_jitter_scale)

#Function for generating Gaussian random initial weights
def gauss_rand(size):
    return topo.pattern.basic.Composite(operator=numpy.multiply, 
                                         generators=[Gaussian(aspect_ratio=1.0, size=size),
                                                     topo.pattern.random.UniformRandom()])

#Function for generating "cloud" connections

from topo.patterns.basic import Disk
def cloud():
    return topo.patterns.basic.Composite(operator=numpy.multiply, 
                                         generators=[Disk(smoothing=0.0),
                                                     topo.patterns.random.BinaryUniformRandom(on_probability=on_probability)])
#Whether or not to use divisive weights normalization
norm=locals().get('norm',True)

if norm==False:
    pi=topo.base.cf.CFPOF_Plugin(single_cf_fn=topo.outputfn.basic.IdentityOF())
else:
    pi = None


###########################################
# build simulation

topo.sim['Retina']=GeneratorSheet(nominal_density=default_retinal_density,
                                  input_generator=combined_inputs,
                                  period=1.0, phase=0.05,
                                  nominal_bounds=BoundingBox(radius=Retina_size))

topo.sim['LGNOn']=CFSheet(nominal_density=default_lgn_density,
                          nominal_bounds=BoundingBox(radius=LGN_size),
                          output_fn=LGN_on_output_fn,
                          measure_maps=False)

topo.sim['LGNOff']=CFSheet(nominal_density=default_lgn_density,
                           nominal_bounds=BoundingBox(radius=LGN_size),
                           output_fn=LGN_off_output_fn,
                           measure_maps=False)


topo.sim['V1'] = JointScaling(nominal_density=default_density,
                              nominal_bounds=BoundingBox(radius=V1_size),tsettle=9,
                              plastic=True,output_fn=V1_OF,
                              post_initialization_weights_output_fn=pi,
                              target=afferent_target,
                              smoothing=smoothing,
                              target_lr=target_lr)

if jitter==True:
    topo.sim.connect('Retina','LGNOn',delay=FixedPoint("0.05"),
                     connection_type=SharedWeightCFProjection,coord_mapper=ret_jitterOn,strength=ret_strength,
                     nominal_bounds_template=BoundingBox(radius=Afferent_size),name='Afferent',
                     weights_generator=on_weights)
    
    topo.sim.connect('Retina','LGNOff',delay = FixedPoint("0.05"),
                     connection_type=SharedWeightCFProjection,coord_mapper=ret_jitterOff,strength=ret_strength,
                     nominal_bounds_template=BoundingBox(radius=Afferent_size),name='Afferent',
                     weights_generator=off_weights)

    if aff_cloud==True:
        topo.sim.connect('LGNOn','V1',delay=FixedPoint("0.05"), dest_port=('Activity','JointNormalize', 'Afferent'),
                         connection_type=CFProjection,coord_mapper=jitterOn,
                         learning_fn=CFPLF_PluginScaled(),
                         strength=1.0,name='LGNOnAfferent',cf_shape=cloud(),
                         weights_generator=gauss_rand(size=2*LGNAfferent_size),
                         nominal_bounds_template=BoundingBox(radius=LGNAfferent_size),
                         learning_rate=locals().get('aff_lr',0.137*on_probability))
        
        topo.sim.connect('LGNOff','V1',delay=FixedPoint("0.05"), dest_port=('Activity','JointNormalize', 'Afferent'),
                         connection_type=CFProjection,coord_mapper=jitterOff,
                         learning_fn=CFPLF_PluginScaled(),
                         strength=1.0,name='LGNOffAfferent',cf_shape=cloud(),
                         weights_generator=gauss_rand(size=2*LGNAfferent_size),
                         nominal_bounds_template=BoundingBox(radius=LGNAfferent_size),
                         learning_rate=locals().get('aff_lr',0.137*on_probability))
    else:
        topo.sim.connect('LGNOn','V1',delay=FixedPoint("0.05"), dest_port=('Activity','JointNormalize', 'Afferent'),
                         connection_type=CFProjection,coord_mapper=jitterOn,
                         learning_fn=CFPLF_PluginScaled(),
                         strength=1.0,name='LGNOnAfferent',
                         weights_generator=gauss_rand(size=2*LGNAfferent_size),
                         nominal_bounds_template=BoundingBox(radius=LGNAfferent_size),
                         learning_rate=locals().get('aff_lr',0.137))
        

        topo.sim.connect('LGNOff','V1',delay=FixedPoint("0.05"), dest_port=('Activity','JointNormalize', 'Afferent'),
                         connection_type=CFProjection,coord_mapper=jitterOff,
                         learning_fn=CFPLF_PluginScaled(),
                         strength=1.0,name='LGNOffAfferent',
                         weights_generator=gauss_rand(size=2*LGNAfferent_size),
                         nominal_bounds_template=BoundingBox(radius=LGNAfferent_size),
                         learning_rate=locals().get('aff_lr',0.137)) 
    
else:
    topo.sim.connect('Retina','LGNOn',delay=FixedPoint("0.05"),
                     connection_type=SharedWeightCFProjection,strength=ret_strength,
                     nominal_bounds_template=BoundingBox(radius=Afferent_size),name='Afferent',
                     weights_generator=on_weights)
    
    topo.sim.connect('Retina','LGNOff',delay = FixedPoint("0.05"),
                     connection_type=SharedWeightCFProjection,strength=ret_strength,
                     nominal_bounds_template=BoundingBox(radius=Afferent_size),name='Afferent',
                     weights_generator=off_weights)

    if aff_cloud==True:
        topo.sim.connect('LGNOn','V1',delay=FixedPoint("0.05"), dest_port=('Activity','JointNormalize', 'Afferent'),
                         connection_type=CFProjection,
                         learning_fn=CFPLF_PluginScaled(),
                         strength=1.0,name='LGNOnAfferent',cf_shape=cloud(),
                         weights_generator=gauss_rand(size=2*LGNAfferent_size),
                         nominal_bounds_template=BoundingBox(radius=LGNAfferent_size),
                         learning_rate=locals().get('aff_lr',0.137*on_probability))
        
        topo.sim.connect('LGNOff','V1',delay=FixedPoint("0.05"), dest_port=('Activity','JointNormalize', 'Afferent'),
                         connection_type=CFProjection,
                         learning_fn=CFPLF_PluginScaled(),
                         strength=1.0,name='LGNOffAfferent',cf_shape=cloud(),
                         weights_generator=gauss_rand(size=2*LGNAfferent_size),
                         nominal_bounds_template=BoundingBox(radius=LGNAfferent_size),
                         learning_rate=locals().get('aff_lr',0.137*on_probability))
    else:
        topo.sim.connect('LGNOn','V1',delay=FixedPoint("0.05"), dest_port=('Activity','JointNormalize', 'Afferent'),
                         connection_type=CFProjection,
                         learning_fn=CFPLF_PluginScaled(),
                         strength=1.0,name='LGNOnAfferent',
                         weights_generator=gauss_rand(size=2*LGNAfferent_size),
                         nominal_bounds_template=BoundingBox(radius=LGNAfferent_size),
                         learning_rate=locals().get('aff_lr',0.137))
        

        topo.sim.connect('LGNOff','V1',delay=FixedPoint("0.05"), dest_port=('Activity','JointNormalize', 'Afferent'),
                         connection_type=CFProjection,
                         learning_fn=CFPLF_PluginScaled(),
                         strength=1.0,name='LGNOffAfferent',
                         weights_generator=gauss_rand(size=2*LGNAfferent_size),
                         nominal_bounds_template=BoundingBox(radius=LGNAfferent_size),
                         learning_rate=locals().get('aff_lr',0.137))

if lat_cloud==True:
    
    topo.sim.connect('V1','V1',delay=FixedPoint("0.05"),name='LateralExcitatory',
                     connection_type=CFProjection,
                     cf_shape=cloud(),
                     strength=1.0*locals().get('exc_strength',1.0),
                     weights_generator=topo.patterns.basic.Gaussian(aspect_ratio=1.0, size=Lat_exc_size),
                     nominal_bounds_template=BoundingBox(radius=Lat_exc_size),learning_rate=0.0) 
        
    topo.sim.connect('V1','V1',delay=FixedPoint("0.05"),name='LateralInhibitory',
                     connection_type=CFProjection,
                     cf_shape=cloud(),
                     strength=-1.0*locals().get('inh_strength',1.0),
                     #inh_strength should be increased for more distributed datasets i.e. when the frequency parameter is higher?
                     weights_generator=gauss_rand(size=Lat_inh_size),
                     nominal_bounds_template=BoundingBox(radius=Lat_inh_size),learning_rate=locals().get('lat_lr',1.80873))
else:
    topo.sim.connect('V1','V1',delay=FixedPoint("0.05"),name='LateralExcitatory',
                     connection_type=CFProjection,
                     strength=1.0*locals().get('exc_strength',1.0),
                     weights_generator=topo.patterns.basic.Gaussian(aspect_ratio=1.0, size=Lat_exc_size*0.75),
                     nominal_bounds_template=BoundingBox(radius=Lat_exc_size),learning_rate=0.0) 
        
    topo.sim.connect('V1','V1',delay=FixedPoint("0.05"),name='LateralInhibitory',
                     connection_type=CFProjection,
                     strength=-1.0*locals().get('inh_strength',1.0),
                     #inh_strength should be increased for more distributed datasets i.e. when the frequency parameter is higher?
                     weights_generator=gauss_rand(size=Lat_inh_size),
                     nominal_bounds_template=BoundingBox(radius=Lat_inh_size),learning_rate=locals().get('lat_lr',1.80873))


#Output functions for tracking
topo.sim["V1"].projections()["LGNOnAfferent"].output_fn=LGNOn_OF
topo.sim["V1"].projections()["LGNOffAfferent"].output_fn=LGNOff_OF
topo.sim["V1"].projections()["LateralExcitatory"].output_fn=LatEx_OF
topo.sim["V1"].projections()["LateralInhibitory"].output_fn=LatIn_OF


# default locations for model editor
topo.sim.grid_layout([[None,    'V1',     None],
                      ['LGNOn', None,     'LGNOff'],
                      [None,    'Retina', None]], xstart=150)

### Input pattern changes
changetime = locals().get('changetime',6000)# Time at which patterns or strengths are set to change

changetargets = locals().get('changetargets',True) #If false, targets for afferent scaling and output function adjustment are not changed.
if dataset=="NoisyDiskstoNatural":
    if changetargets==True:
        new_frequency = locals().get('new_frequency',5)
        new_balance = locals().get('new_balance',4)
        new_mu=0.0045*new_frequency
        new_afferent_target = new_mu*new_balance
        topo.sim.schedule_command(changetime,'topo.sim["Retina"].set_input_generator(natural_combined_inputs,push_existing=False)')
        topo.sim.schedule_command(changetime,'topo.sim["V1"].target=new_afferent_target')
        if tracking==True:
            topo.sim.schedule_command(changetime,'topo.sim["V1"].output_fn.output_fns[1].mu=new_mu')
        else:
            topo.sim.schedule_command(changetime,'topo.sim["V1"].output_fn.mu=new_mu')
    else:
        topo.sim.schedule_command(changetime,'topo.sim["Retina"].set_input_generator(natural_combined_inputs,push_existing=False)')


#can set strength of retina to lgn projections to change during development  
changestrength = locals().get('changestrength',False)
if changestrength==True:
    new_strength = locals().get('new_strength',2.0)
    topo.sim.schedule_command(changetime,'topo.sim["LGNOn"].projections()["Afferent"].strength=new_strength')
    topo.sim.schedule_command(changetime,'topo.sim["LGNOff"].projections()["Afferent"].strength=new_strength')

if species=="cat":
    
    topo.commands.analysis.plotgroups["Orientation Preference"].update_command="measure_or_pref(frequencies=[0.48],pattern_presenter=PatternPresenter(pattern_generator=SineGrating(),apply_output_fn=False,duration=0.175))"
    topo.commands.analysis.plotgroups["Retinotopy"].update_command="measure_retinotopy(num_phase=18,num_orientation=4,frequencies=[0.48],divisions=4,scale=1.0,offset=0.0,display=False, weighted_average=False, apply_output_fn=True,duration=1.0)"
    

elif species=="mouse":
    topo.commands.analysis.plotgroups["Orientation Preference"].update_command="measure_or_pref(frequencies=[1.83],pattern_presenter=PatternPresenter(pattern_generator=SineGrating(),apply_output_fn=False,duration=0.175))"
    topo.commands.analysis.plotgroups["Retinotopy"].update_command="measure_retinotopy(num_phase=18,num_orientation=4,frequencies=[1.83],divisions=4,scale=1.0,offset=0.0,display=False, weighted_average=False, apply_output_fn=True,duration=1.0)"

