"""
Example of a LISSOM-based color map (with ON/OFF channels).

$Id$
"""
__version__='$Revision: 8562 $'


import numpy
import copy

from math import pi, sqrt

import topo.patterns.basic
import topo.patterns.random

from topo.patterns.basic import Gaussian
from topo.sheets.lissom import LISSOM
from topo.sheets.generatorsheet import GeneratorSheet
from topo.projections.basic import CFProjection, SharedWeightCFProjection
from topo.responsefns.optimized import CFPRF_DotProduct_opt
from topo.base.cf import CFSheet
from topo.base.boundingregion import BoundingBox
from topo.learningfn.optimized import CFPLF_Hebbian_opt
from topo.outputfn.optimized import CFPOF_DivisiveNormalizeL1_opt
from topo.outputfn.basic import PiecewiseLinear, DivisiveNormalizeL1
from topo.misc.numbergenerators import UniformRandom
from topo.patterns.image import Image

# Default for tutorial
topo.patterns.basic.Line.scale=0.9
topo.patterns.basic.Gaussian.size=0.08333
topo.patterns.basic.Gaussian.aspect_ratio=4.0

# Specify weight initialization, response function, and learning function
CFProjection.cf_shape = topo.patterns.basic.Disk(smoothing=0.0)
CFProjection.weights_generator = topo.patterns.basic.Constant()
CFProjection.response_fn=CFPRF_DotProduct_opt()
CFProjection.learning_fn=CFPLF_Hebbian_opt()
CFProjection.weights_output_fn=CFPOF_DivisiveNormalizeL1_opt()
SharedWeightCFProjection.response_fn=CFPRF_DotProduct_opt()


###########################################
# build simulation
eyes=['']
center_polarities=['On','Off']
rg_cone_types=['Red','Green']
rgb_cone_types=['Red','Green','Blue']
opponent_types=['Red-Green','Green-Red','Blue-RedGreen','Luminosity']
lags=['']

ids=4.0
num_inputs=1
input_type=topo.patterns.image.FileImage

for e in eyes:
    for n in lags:
        default_retina_density=locals().get('default_retina_density',48.0)
        scalingfactor=[1.4*0.9,1.4,1.4*0.97] # from Judah's PhD
        for cone in rgb_cone_types:
            image_filenames=["images/colormap/rgb/%02d_%d.pgm"%(i,rgb_cone_types.index(cone)) for i in xrange(1,26)]
            inputs=[input_type(filename=f, size=10.0,
                               x=UniformRandom(lbound=-0.75,ubound=0.75,seed=12),
                               y=UniformRandom(lbound=-0.75,ubound=0.75,seed=34),
                               orientation=UniformRandom(lbound=-pi,ubound=pi,seed=56),
                               scale=         2.0-UniformRandom(lbound=0,ubound=2,seed=78)*scalingfactor[rgb_cone_types.index(cone)] \
                               if e=='Right' else UniformRandom(lbound=0,ubound=2,seed=78)*scalingfactor[rgb_cone_types.index(cone)]) 
                    for f in image_filenames]

            input_composite=topo.patterns.basic.Selector(generators=inputs)

            topo.sim[e+cone+'Retina'+n]=GeneratorSheet(nominal_density=default_retina_density,
                                                       input_generator=input_composite,
                                                       period=1.0, phase=0.05,
                                                       nominal_bounds=BoundingBox(radius=0.5+0.27083+0.375))

        for l in center_polarities:
            for opponent in opponent_types:
                topo.sim[e+opponent+' LGN'+l+n]=CFSheet(nominal_density=24.0,
                                                        nominal_bounds=BoundingBox(radius=0.5+0.27083),
                                                        output_fn=PiecewiseLinear(lower_bound=0.0,upper_bound=1.0),
                                                        measure_maps=False)


topo.sim['V1'] = LISSOM(nominal_density=locals().get('default_density',48.0),tsettle=9,nominal_bounds=BoundingBox(radius=0.5))

topo.sim['V1'].output_fn.lower_bound=0.076
topo.sim['V1'].output_fn.upper_bound=0.626

# DoG weights for the LGN
centerg   = Gaussian(size=0.07385,aspect_ratio=1.0,output_fn=DivisiveNormalizeL1())
surroundg = Gaussian(size=0.29540,aspect_ratio=1.0,output_fn=DivisiveNormalizeL1())

for e in eyes:
    for n in lags:
        for l in center_polarities:
            for cone in rg_cone_types:
                topo.sim.connect(e+cone+'Retina'+n,
                                 e+cone+'-'+rg_cone_types[rg_cone_types.index(cone)-1]+' LGN'+l+n, delay=0.05,
		                 connection_type=SharedWeightCFProjection, strength=4.7*(-1)**center_polarities.index(l),
		                 nominal_bounds_template=BoundingBox(radius=0.375), 
                                 name='AfferentCenter', weights_generator=centerg)

                topo.sim.connect(e+cone+'Retina'+n,
                                 e+rg_cone_types[rg_cone_types.index(cone)-1]+'-'+cone+' LGN'+l+n, delay=0.05,
                                 connection_type=SharedWeightCFProjection, strength=4.7*(-1)**(1+center_polarities.index(l)),
                                 nominal_bounds_template=BoundingBox(radius=0.375),
                                 name='AfferentSurround', weights_generator=surroundg)

                topo.sim.connect(e+cone+'Retina'+n,
                                 e+'Blue-RedGreen'+' LGN'+l+n, delay=0.05,
                                 connection_type=SharedWeightCFProjection, strength=4.7*(-1)**(1+center_polarities.index(l))/2,
                                 nominal_bounds_template=BoundingBox(radius=0.375),
                                 name='AfferentCenter'+cone, weights_generator=centerg)

            topo.sim.connect(e+'Blue'+'Retina'+n,
                             e+'Blue-RedGreen'+' LGN'+l+n, delay=0.05,
                             connection_type=SharedWeightCFProjection, strength=4.7*(-1)**center_polarities.index(l),
                             nominal_bounds_template=BoundingBox(radius=0.375),
                             name='AfferentCenter'+'Blue', weights_generator=centerg)
            
            for cone in rgb_cone_types: 
                topo.sim.connect(e+cone+'Retina'+n,
		                 e+'Luminosity LGN'+l+n, delay=0.05,
		                 connection_type=SharedWeightCFProjection, strength=4.7*(-1)**center_polarities.index(l)/3,
		                 nominal_bounds_template=BoundingBox(radius=0.375),
		                 name='AfferentCenter'+cone, weights_generator=centerg)

                topo.sim.connect(e+cone+'Retina'+n,
		                 e+'Luminosity LGN'+l+n, delay=0.05,
		                 connection_type=SharedWeightCFProjection, strength=4.7*(-1)**(1+center_polarities.index(l))/3,
		                 nominal_bounds_template=BoundingBox(radius=0.375),
		                 name='AfferentSurround'+cone, weights_generator=surroundg)
		                         
            for opponent in opponent_types:
                topo.sim.connect(e+opponent+' LGN'+l+n, 'V1', delay=0.05, dest_port=('Activity', 'JointNormalize', 'Afferent'),
                                 connection_type=CFProjection, strength=1.0, name=e+opponent+' LGN'+l+'Afferent'+n,
                                 weights_generator=topo.patterns.basic.Composite(operator=numpy.multiply, 
                                                   generators=[Gaussian(aspect_ratio=1.0, size=2*0.27083),
                                                   topo.patterns.random.UniformRandom()]),
                                 nominal_bounds_template=BoundingBox(radius=0.27083),
                                 learning_rate=0.9590/len(center_polarities)/len(eyes)/len(lags)/len(opponent_types)/ids)

                        

topo.sim.connect('V1','V1',delay=0.05,name='LateralExcitatory',
                 connection_type=CFProjection,strength=1.2, 
                 weights_generator=topo.patterns.basic.Composite(operator=numpy.multiply, 
                                                                 generators=[Gaussian(aspect_ratio=1.0, size=2*0.10417),
                                                                 topo.patterns.random.UniformRandom()]),
                 nominal_bounds_template=BoundingBox(radius=0.10417),learning_rate=2.55528/ids) 
            
topo.sim.connect('V1','V1',delay=0.05,name='LateralInhibitory',
                 connection_type=CFProjection,strength=-1.75, 
                 weights_generator=topo.patterns.basic.Composite(operator=numpy.multiply, 
                                                                 generators=[Gaussian(aspect_ratio=1.0, size=2*0.22917),
                                                                 topo.patterns.random.UniformRandom()]),
                 nominal_bounds_template=BoundingBox(radius=0.22917),learning_rate=1.80873/ids/5)  


### Actions scheduled to occur as the simulation proceeds.
topo.sim.startup_commands.append("from topo.base.boundingregion import BoundingBox")

# Convenience variable: timescale
st=1.0/2.0

### Lateral excitatory bounds changes
LE='topo.sim["V1"].projections()["LateralExcitatory"]'

topo.sim.schedule_command(  200*st,LE+'.change_bounds(BoundingBox(radius=0.06250))')
topo.sim.schedule_command(  500*st,LE+'.change_bounds(BoundingBox(radius=0.04375))')
topo.sim.schedule_command( 1000*st,LE+'.change_bounds(BoundingBox(radius=0.03500))')
topo.sim.schedule_command( 2000*st,LE+'.change_bounds(BoundingBox(radius=0.02800))')
topo.sim.schedule_command( 3000*st,LE+'.change_bounds(BoundingBox(radius=0.02240))')
topo.sim.schedule_command( 4000*st,LE+'.change_bounds(BoundingBox(radius=0.01344))')
topo.sim.schedule_command( 5000*st,LE+'.change_bounds(BoundingBox(radius=0.00806))')
topo.sim.schedule_command( 6500*st,LE+'.change_bounds(BoundingBox(radius=0.00484))')
topo.sim.schedule_command( 8000*st,LE+'.change_bounds(BoundingBox(radius=0.00290))')
topo.sim.schedule_command(20000*st,LE+'.change_bounds(BoundingBox(radius=0.00174))')

### Lateral excitatory learning rate changes
topo.sim.schedule_command(  200*st,LE+'.learning_rate=0.12168/ids*'+LE+'.n_units()')
topo.sim.schedule_command(  500*st,LE+'.learning_rate=0.06084/ids*'+LE+'.n_units()')
topo.sim.schedule_command( 1000*st,LE+'.learning_rate=0.06084/ids*'+LE+'.n_units()')
topo.sim.schedule_command( 2000*st,LE+'.learning_rate=0.06084/ids*'+LE+'.n_units()')
topo.sim.schedule_command( 3000*st,LE+'.learning_rate=0.06084/ids*'+LE+'.n_units()')
topo.sim.schedule_command( 4000*st,LE+'.learning_rate=0.06084/ids*'+LE+'.n_units()')
topo.sim.schedule_command( 5000*st,LE+'.learning_rate=0.06084/ids*'+LE+'.n_units()')
topo.sim.schedule_command( 6500*st,LE+'.learning_rate=0.06084/ids*'+LE+'.n_units()')
topo.sim.schedule_command( 8000*st,LE+'.learning_rate=0.06084/ids*'+LE+'.n_units()')
topo.sim.schedule_command(20000*st,LE+'.learning_rate=0.06084/ids*'+LE+'.n_units()')

### Lateral inhibitory learning rate and strength changes
LI='topo.sim["V1"].projections()["LateralInhibitory"]'

topo.sim.schedule_command( 1000*st,LI+'.learning_rate=1.80873/ids/5.0*2.0')
topo.sim.schedule_command( 2000*st,LI+'.learning_rate=1.80873/ids/5.0*3.0')
topo.sim.schedule_command( 5000*st,LI+'.learning_rate=1.80873/ids/5.0*5.0')

topo.sim.schedule_command( 1000*st,LI+'.strength=-2.2')
topo.sim.schedule_command( 2000*st,LI+'.strength=-2.6')

### Afferent learning rate changes
for opponent in opponent_types:
    for n in lags:
        for e in eyes:
            for l in center_polarities:
                S ='topo.sim["V1"].projections()["'+e+opponent+' LGN'+l+'Afferent'+n+'"]'
                topo.sim.schedule_command(  500*st,S+'.learning_rate=0.6850/len(center_polarities)/len(eyes)/len(lags)/len(opponent_types)/ids')
                topo.sim.schedule_command( 2000*st,S+'.learning_rate=0.5480/len(center_polarities)/len(eyes)/len(lags)/len(opponent_types)/ids')
                topo.sim.schedule_command( 4000*st,S+'.learning_rate=0.4110/len(center_polarities)/len(eyes)/len(lags)/len(opponent_types)/ids')
                topo.sim.schedule_command(20000*st,S+'.learning_rate=0.2055/len(center_polarities)/len(eyes)/len(lags)/len(opponent_types)/ids')

### Activation function threshold changes
OF='topo.sim["V1"].output_fn'

topo.sim.schedule_command(  200*st,OF+'.lower_bound=0.086;'+OF+'.upper_bound=0.636') 
topo.sim.schedule_command(  500*st,OF+'.lower_bound=0.096;'+OF+'.upper_bound=0.636') 
topo.sim.schedule_command( 1000*st,OF+'.lower_bound=0.126;'+OF+'.upper_bound=0.656') 
topo.sim.schedule_command( 2000*st,OF+'.lower_bound=0.156;'+OF+'.upper_bound=0.676') 
topo.sim.schedule_command( 3000*st,OF+'.lower_bound=0.176;'+OF+'.upper_bound=0.706') 
topo.sim.schedule_command( 4000*st,OF+'.lower_bound=0.176;'+OF+'.upper_bound=0.736') 
topo.sim.schedule_command( 5000*st,OF+'.lower_bound=0.186;'+OF+'.upper_bound=0.766') 
topo.sim.schedule_command( 6500*st,OF+'.lower_bound=0.196;'+OF+'.upper_bound=0.796') 
topo.sim.schedule_command( 8000*st,OF+'.lower_bound=0.206;'+OF+'.upper_bound=0.826') 
topo.sim.schedule_command(20000*st,OF+'.lower_bound=0.216;'+OF+'.upper_bound=0.856') 

### Just to get more progress reports
topo.sim.schedule_command(12000*st,'pass')
topo.sim.schedule_command(16000*st,'pass')

### Settling steps changes
topo.sim.schedule_command( 2000*st,'topo.sim["V1"].tsettle=10')
topo.sim.schedule_command( 5000*st,'topo.sim["V1"].tsettle=11')
topo.sim.schedule_command( 6500*st,'topo.sim["V1"].tsettle=12')
topo.sim.schedule_command( 8000*st,'topo.sim["V1"].tsettle=13')

# default locations for model editor
vs = [None]*(len(opponent_types)*len(center_polarities)*len(eyes)*len(lags)-1) + ['V1'] + \
     [None]*(len(opponent_types)*len(center_polarities)*len(eyes)*len(lags))

ls=[]
for n in lags:
    for e in eyes:
        for opponent in opponent_types:
            for l in center_polarities:            
                ls += [e+opponent+' LGN'+l+n]+[None]
                

es=[]
for n in lags:
   for e in eyes:
        for cone in rgb_cone_types:
            es += [None]*(len(center_polarities)/2) + [e+cone+'Retina'+n,None] + \
                  [None]*(len(center_polarities)/2)

topo.sim.grid_layout([vs,ls,es], xstep=70/len(eyes), ystep=200, item_scale=0.75/len(eyes))
