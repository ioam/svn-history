"""

UNDER DEVELOPMENT

Example of a LISSOM-based orientation map with ON/OFF channels.

with different size LGN connectionfields. To investigate spatial frequency.

the same as lissom_oo_or.ty as of 3.3.06 but with quarter v1 area


"""
__version__='$Revision$'

import random
import RandomArray
import fixedpoint

from math import pi, sqrt
from fixedpoint import FixedPoint

import topo.patterns.basic
import topo.patterns.random

from topo.sheets.lissom import LISSOM
from topo.sheets.generatorsheet import GeneratorSheet
from topo.projections.basic import CFProjection, SharedWeightCFProjection
from topo.responsefns.optimized import CFDotProduct_opt1
from topo.base.parameterclasses import DynamicNumber,RandomWrapper
from topo.base.connectionfield import CFSheet
from topo.base.boundingregion import BoundingBox
from topo.learningfns.optimized import Hebbian_opt1
from topo.outputfns.basic import DivisiveSumNormalize,PiecewiseLinear
from topo.patterns import PatternGeneratorParameter
from topo.base.parameterizedobject import ParameterizedObject
from topo.outputfns.optimized import DivisiveSumNormalizeCFOF_opt1



###########################################
# Set parameters

centre=0.0417*2
surround=0.1667*2
v1size=0.5
retinalgnboxradius=0.375*2
lgnv1boxradius=0.25*2
lgnbuffer=0.25*2
retinabuffer=0.375*2+lgnbuffer
latex=0.2
latinh=0.46

#random.seed(1234)
centres=0.0417*1
surrounds=0.1667*1
v1sizes=0.5
retinalgnboxradiuss=0.375*1
lgnv1boxradiuss=0.25*1
lgnbuffers=0.25*1
retinabuffers=0.375*1+lgnbuffers
latexs=0.1
latinhs=0.23

from topo.base.parameterclasses import Wrapper
from math import floor
from topo.patterns.basic import CompositePatternGenerator


#this one for small receptive fields
#input_pattern = topo.patterns.basic.Gaussian(scale=1.0,size = 1*2*0.0468,aspect_ratio=4.0,
#                                    x=DynamicNumber(RandomWrapper("uniform",-0.5,0.5,seed=12)),
#                                    y=DynamicNumber(RandomWrapper("uniform",-0.5,0.5,seed=34)),
#                                    orientation=DynamicNumber(RandomWrapper("uniform",-pi,pi,seed=56)))
  
#this one for large receptive fields                                  
#input_pattern = topo.patterns.basic.Gaussian(scale=1.0,size = 2*2*0.0468,aspect_ratio=4.0,
#                                    x=DynamicNumber(RandomWrapper("uniform",-1.0,1.0,seed=12)),
#                                    y=DynamicNumber(RandomWrapper("uniform",-1.0,1.0,seed=34)),
#                                    orientation=DynamicNumber(RandomWrapper("uniform",-pi,pi,seed=56)))

#this one is for testing   

#def rando():
#	if (random.uniform(0,1)>0.5):
#		return 0.1  #1*2*0.0468
#	else:
#		return 0.2  #2*2*0.0468
 #          
#input_pattern = topo.patterns.basic.Gaussian(scale=1.0,size = DynamicNumber(rando),aspect_ratio=4.0,
#                                    x=DynamicNumber(RandomWrapper("uniform",(-0.5),(0.5),seed=12)),
#                                    y=DynamicNumber(RandomWrapper("uniform",(-0.5),(0.5),seed=34)),
#                                    orientation=DynamicNumber(RandomWrapper("uniform",-pi,pi,seed=56)))



x=1
x1=DynamicNumber(RandomWrapper("uniform",-0.5,0.5,seed=32))
y1=DynamicNumber(RandomWrapper("uniform",-0.5,0.5,seed=12))
x2=DynamicNumber(RandomWrapper("uniform",-1.0,1.0,seed=33))
y2=DynamicNumber(RandomWrapper("uniform",-1.0,1.0,seed=13))


def swap():
	global x
	global x1
	global y1
	global x2
	global y2	
	if (x==1):
		x=0
		input_pattern.x=x1
		input_pattern.y=y1
		return 1*2*0.0468
	else:
		x=1
		input_pattern.x=x2
		input_pattern.y=y2
		return 2*2*0.0468

           
input_pattern = topo.patterns.basic.Gaussian(scale=1.0,size = DynamicNumber(swap),aspect_ratio=4.0,
                                   orientation=DynamicNumber(RandomWrapper("uniform",-pi,pi,seed=56)))


#########

#def rando():
#   if (random.uniform(0,1)>0.5):
#       sizee=0.5
#       return topo.patterns.basic.Gaussian(scale=1.0,size = 1*2*0.0468,aspect_ratio=4.0,
#                                    x=DynamicNumber(RandomWrapper("uniform",-0.5,0.5,seed=12)),
#                                    y=DynamicNumber(RandomWrapper("uniform",-0.5,0.5,seed=34)),
#                                    orientation=DynamicNumber(RandomWrapper("uniform",-pi,pi,seed=56)))#

#   else:
#   	   sizee=1.0
#   	   return topo.patterns.basic.Gaussian(scale=1.0,size = 2*2*0.0468,aspect_ratio=4.0,
#                                    x=DynamicNumber(RandomWrapper("uniform",-1.0,1.0,seed=12)),
#                                    y=DynamicNumber(RandomWrapper("uniform",-1.0,1.0,seed=34)),
#                                    orientation=DynamicNumber(RandomWrapper("uniform",-pi,pi,seed=56)))
#

#input_pattern = DynamicNumber(rando)


                                                                      
# Specify weight initialization, response function, and learning function
RandomArray.seed(500,500)
CFProjection.weights_generator = topo.patterns.random.UniformRandom()
CFProjection.weights_shape = topo.patterns.basic.Disk(smoothing=0.0)
CFProjection.response_fn=CFDotProduct_opt1()
CFProjection.learning_fn=Hebbian_opt1()

CFProjection.weights_output_fn=DivisiveSumNormalizeCFOF_opt1()

SharedWeightCFProjection.weights_output_fn.single_cf_fn=DivisiveSumNormalize()
###########################################
# build simulation

s = topo.base.simulator.Simulator(name="big and small")

Retina = GeneratorSheet(name='Retina',density=24.0,bounds=BoundingBox(radius=v1size+retinabuffer),input_generator=input_pattern)
                        
#Retina = GeneratorSheet(name='Retina',density=12.0,bounds=BoundingBox(radius=v1size+retinabuffer),input_generator=CompositePatternGenerator([input_pattern,input_pattern,input_pattern,input_pattern]))                        
                        
LGNOn = CFSheet(name='LGNOn',density=12.0,bounds=BoundingBox(radius=v1size+lgnbuffer),
                output_fn=PiecewiseLinear(lower_bound=0.0,upper_bound=1.0),
                measure_maps=False)
LGNOff = CFSheet(name='LGNOff',density=12.0,bounds=BoundingBox(radius=v1size+lgnbuffer),
                 output_fn=PiecewiseLinear(lower_bound=0.0,upper_bound=1.0),
                 measure_maps=False)
V1 = LISSOM(name='V1',density=24.0,bounds=BoundingBox(radius=v1size))
V1.output_fn.lower_bound=0.083
V1.output_fn.upper_bound=0.633


LGNOns = CFSheet(name='LGNOns',density=24.0,bounds=BoundingBox(radius=v1sizes+lgnbuffers),
                output_fn=PiecewiseLinear(lower_bound=0.0,upper_bound=1.0),
                measure_maps=False)
LGNOffs = CFSheet(name='LGNOffs',density=24.0,bounds=BoundingBox(radius=v1sizes+lgnbuffers),
                 output_fn=PiecewiseLinear(lower_bound=0.0,upper_bound=1.0),
                 measure_maps=False)
V1s = LISSOM(name='V1s',density=48.0,bounds=BoundingBox(radius=v1sizes))
V1s.output_fn.lower_bound=0.083
V1s.output_fn.upper_bound=0.633


s.zapdensity=Retina.density,LGNOff.density,LGNOffs.density,LGNOn.density,LGNOns.density,V1.density,V1s.density



# LGN ON channel
#SharedWeightCFProjection.weights_output_fn.single_cf_fn=DivisiveSumNormalize()

SharedWeightCFProjection.learning_fn.output_fn=DivisiveSumNormalize()

LGNOn_center = s.connect(Retina,LGNOn,delay = FixedPoint("0.05"),
                         connection_type=SharedWeightCFProjection,strength=2.33,
                         name='Center',weights_bounds=BoundingBox(radius=retinalgnboxradius),
                         weights_generator=topo.patterns.basic.Gaussian(size=centre,aspect_ratio=1))

LGNOn_surround = s.connect(Retina,LGNOn,delay = FixedPoint("0.05"),
                           connection_type=SharedWeightCFProjection,strength=-2.33,
                           name='Surround',weights_bounds=BoundingBox(radius=retinalgnboxradius),
                           weights_generator=topo.patterns.basic.Gaussian(size=surround,aspect_ratio=1))


# LGN OFF channel
LGNOff_center = s.connect(Retina,LGNOff,delay = FixedPoint("0.05"),
                          connection_type=SharedWeightCFProjection,strength=-2.33,
                          name='Center',weights_bounds=BoundingBox(radius=retinalgnboxradius),
                          weights_generator=topo.patterns.basic.Gaussian(size=centre,aspect_ratio=1))

LGNOff_surround = s.connect(Retina,LGNOff,delay = FixedPoint("0.05"),
                            connection_type=SharedWeightCFProjection,strength=2.33,
                            name='Surround',weights_bounds=BoundingBox(radius=retinalgnboxradius),
                            weights_generator=topo.patterns.basic.Gaussian(size=surround,aspect_ratio=1))
                            
#small fields               
                            
LGNOn_centers = s.connect(Retina,LGNOns,delay = FixedPoint("0.05"),
                         connection_type=SharedWeightCFProjection,strength=2.33,
                         name='Center',weights_bounds=BoundingBox(radius=retinalgnboxradiuss),
                         weights_generator=topo.patterns.basic.Gaussian(size=centres,aspect_ratio=1))

LGNOn_surrounds = s.connect(Retina,LGNOns,delay = FixedPoint("0.05"),
                           connection_type=SharedWeightCFProjection,strength=-2.33,
                           name='Surround',weights_bounds=BoundingBox(radius=retinalgnboxradiuss),
                           weights_generator=topo.patterns.basic.Gaussian(size=surrounds,aspect_ratio=1))


# LGN OFF channel
LGNOff_centers = s.connect(Retina,LGNOffs,delay = FixedPoint("0.05"),
                          connection_type=SharedWeightCFProjection,strength=-2.33,
                          name='Center',weights_bounds=BoundingBox(radius=retinalgnboxradiuss),
                          weights_generator=topo.patterns.basic.Gaussian(size=centres,aspect_ratio=1))

LGNOff_surrounds = s.connect(Retina,LGNOffs,delay = FixedPoint("0.05"),
                            connection_type=SharedWeightCFProjection,strength=2.33,
                            name='Surround',weights_bounds=BoundingBox(radius=retinalgnboxradiuss),
                            weights_generator=topo.patterns.basic.Gaussian(size=surrounds,aspect_ratio=1))                            
                            


s.connect(LGNOn,V1,delay=FixedPoint("0.05"),
          connection_type=CFProjection,strength=0.75,name='LGNOnAfferent',
          weights_bounds=BoundingBox(radius=lgnv1boxradius),learning_rate=0.9590)

s.connect(LGNOff,V1,delay=FixedPoint("0.05"),
          connection_type=CFProjection,strength=0.5,name='LGNOffAfferent',
          weights_bounds=BoundingBox(radius=lgnv1boxradius),learning_rate=0.9590)


s.connect(V1,V1,delay=FixedPoint("0.05"),
          connection_type=CFProjection,strength=0.9,name='LateralExcitatory',
          weights_bounds=BoundingBox(radius=latex),learning_rate=3.2018) 
            
s.connect(V1,V1,delay=FixedPoint("0.05"), 
          connection_type=CFProjection,strength=-0.9,name='LateralInhibitory',
          weights_bounds=BoundingBox(radius=latinh),learning_rate=1.9626)         


RandomArray.seed(500,500) #sets V1s connectionfileds random initial weights seeding.

s.connect(LGNOns,V1s,delay=FixedPoint("0.05"),
          connection_type=CFProjection,strength=0.75,name='LGNOnAfferents',
          weights_bounds=BoundingBox(radius=lgnv1boxradiuss),learning_rate=0.9590)

s.connect(LGNOffs,V1s,delay=FixedPoint("0.05"),
          connection_type=CFProjection,strength=0.5,name='LGNOffAfferents',
          weights_bounds=BoundingBox(radius=lgnv1boxradiuss),learning_rate=0.9590)


s.connect(V1s,V1s,delay=FixedPoint("0.05"),
          connection_type=CFProjection,strength=0.9,name='LateralExcitatorys',
          weights_bounds=BoundingBox(radius=latexs),learning_rate=3.2018) 
            
s.connect(V1s,V1s,delay=FixedPoint("0.05"), 
          connection_type=CFProjection,strength=-0.9,name='LateralInhibitorys',
          weights_bounds=BoundingBox(radius=latinhs),learning_rate=1.9626)   

# CEBHACKALERT: add missing scheduled actions

s.schedule_action(200, V1.projections()['LateralExcitatory'].change_bounds, BoundingBox(radius=0.12))
s.schedule_action(500, V1.projections()['LateralExcitatory'].change_bounds, BoundingBox(radius=0.084))

s.schedule_action(200, V1s.projections()['LateralExcitatorys'].change_bounds, BoundingBox(radius=0.06))
s.schedule_action(500, V1s.projections()['LateralExcitatorys'].change_bounds, BoundingBox(radius=0.042))

# Schedule action requires a function, so we create a temporary one
def set_learning_rate_V1(projection_name, rate):
    """Set the learning rate on the named projection of V1."""
    V1.projections()[projection_name].learning_rate=rate
    
    
def set_learning_rate_V1s(projection_name, rate):
    """Set the learning rate on the named projection of V1.""" 
    V1s.projections()[projection_name].learning_rate=rate

s.schedule_action(  200, set_learning_rate_V1, "LateralExcitatory", 1.2213)
s.schedule_action(  500, set_learning_rate_V1, "LateralExcitatory", 0.3466)

s.schedule_action(  500, set_learning_rate_V1, "LGNOnAfferent", 0.6850)
s.schedule_action( 2000, set_learning_rate_V1, "LGNOnAfferent", 0.5480)
s.schedule_action( 4000, set_learning_rate_V1, "LGNOnAfferent", 0.4110)
s.schedule_action(20000, set_learning_rate_V1, "LGNOnAfferent", 0.2055)

s.schedule_action(  500, set_learning_rate_V1, "LGNOffAfferent", 0.6850)
s.schedule_action( 2000, set_learning_rate_V1, "LGNOffAfferent", 0.5480)
s.schedule_action( 4000, set_learning_rate_V1, "LGNOffAfferent", 0.4110)
s.schedule_action(20000, set_learning_rate_V1, "LGNOffAfferent", 0.2055)



s.schedule_action(  200, set_learning_rate_V1s, "LateralExcitatorys", 1.2213)
s.schedule_action(  500, set_learning_rate_V1s, "LateralExcitatorys", 0.3466)

s.schedule_action(  500, set_learning_rate_V1s, "LGNOnAfferents", 0.6850)
s.schedule_action( 2000, set_learning_rate_V1s, "LGNOnAfferents", 0.5480)
s.schedule_action( 4000, set_learning_rate_V1s, "LGNOnAfferents", 0.4110)
s.schedule_action(20000, set_learning_rate_V1s, "LGNOnAfferents", 0.2055)

s.schedule_action(  500, set_learning_rate_V1s, "LGNOffAfferents", 0.6850)
s.schedule_action( 2000, set_learning_rate_V1s, "LGNOffAfferents", 0.5480)
s.schedule_action( 4000, set_learning_rate_V1s, "LGNOffAfferents", 0.4110)
s.schedule_action(20000, set_learning_rate_V1s, "LGNOffAfferents", 0.2055)

def set_deltabeta(x,y):
    """Set the threshold function limits on V1."""
    V1.output_fn.lower_bound=x
    V1.output_fn.upper_bound=y
    V1s.output_fn.lower_bound=x
    V1s.output_fn.upper_bound=y

s.schedule_action(  200, set_deltabeta,0.093 , 0.643)
s.schedule_action(  500, set_deltabeta,0.103 , 0.653)
s.schedule_action( 1000, set_deltabeta,0.133 , 0.663)
s.schedule_action( 2000, set_deltabeta,0.163 , 0.683)
s.schedule_action( 3000, set_deltabeta,0.183 , 0.713)
s.schedule_action( 4000, set_deltabeta,0.183 , 0.743)
s.schedule_action( 5000, set_deltabeta,0.193 , 0.773)
s.schedule_action( 6500, set_deltabeta,0.203 , 0.803)
s.schedule_action( 8000, set_deltabeta,0.213 , 0.833)
s.schedule_action(20000, set_deltabeta,0.223 , 0.863)


# default locations for model editor
V1.gui_x=306.0;     V1.gui_y=225.0
LGNOn.gui_x=432.0;  LGNOn.gui_y=345.0
LGNOff.gui_x=150.0; LGNOff.gui_y=345.0
Retina.gui_x=400.0; Retina.gui_y=600.0

V1s.gui_x=800.0;     V1s.gui_y=225.0
LGNOns.gui_x=900.0;  LGNOns.gui_y=345.0
LGNOffs.gui_x=700.0; LGNOffs.gui_y=345.0

s.run(0)

from os import system

#def run_batch(train_length=100):
#    print "Running until %d" % (topo.sim._time+train_length)
#    topo.sim.run(train_length)
#    system('free')
#    print " "

#for i in [1,2,20,50,90,100,200,400,500,4000,5000,10000]:
#    run_batch(i)