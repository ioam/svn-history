"""
Example of a LISSOM-based face-selective-area simulation.

Intended to be a close (but approximate) match to the default FSA
simulation (such as figure 10.12) of Miikkulainen, Bednar, Choe, and
Sirosh (2005), Computational Maps in the Visual Cortex, Springer.
Known differences include:

 - The matching is not yet perfect at different densities
 - The lateral inhibitory radius is up to 0.5 matrix units greater
   than in the book, because Topographica enforces good
   circular-shaped CF outlines.
 - Input patterns are evaluated on the entire retina, instead of only up
   to bounds_multiplier=2.5 times the gaussian sigma in the book
 - Initial weight patterns are not smoothed around the edges, unlike
   smooth_circular_outlines=True and smooth_circular_radius_trim=-0.25
   used in the book
 - Inhibitory weight pruning is disabled (not pruning all weights below
   1e-5 as in the book)

There may be other small differences, as this file has not yet been
compared exhaustively to the original simulations.

$Id$
"""
__version__='$Revision$'


from math import pi, sqrt
import numpy

from topo import learningfn,numbergen,outputfn,pattern,projection,responsefn,sheet 

import topo.learningfn.optimized
import topo.learningfn.projfn 
import topo.outputfn.optimized 
import topo.pattern.random
import topo.responsefn.optimized 
import topo.sheet.lissom
import topo.sheet.optimized

### Specify weight initialization, response function, and learning function
projection.CFProjection.cf_shape=pattern.Disk(smoothing=0.0)
projection.CFProjection.weights_generator=pattern.Constant()
projection.CFProjection.response_fn=responsefn.optimized.CFPRF_DotProduct_opt()
projection.CFProjection.learning_fn=learningfn.optimized.CFPLF_Hebbian_opt()
projection.CFProjection.weights_output_fn=outputfn.optimized.CFPOF_DivisiveNormalizeL1_opt()
projection.SharedWeightCFProjection.response_fn=responsefn.optimized.CFPRF_DotProduct_opt()
sheet.GeneratorSheet.nominal_density = 48.0


### Input patterns
num_inputs=3
lefteye =  pattern.Gaussian(aspect_ratio = 1.0, x = 1/24.0, y = 2.5/24.0,
                            size = 2.0 * 1.21/24.0 / 1.7, scale = 0.5, offset = 0.5059)
righteye = pattern.Gaussian(aspect_ratio = 1.0, x = 1/24.0, y = -2.5/24.0,
                            size = 2.0 * 1.21/24.0 / 1.7, scale = 0.5, offset = 0.5059)
mouth   =  pattern.Gaussian(aspect_ratio = 1.0, x = -5/24.0, y = 0.0/24.0,
                            size = 2.0 * 1.21/24.0 / 1.7, scale = 0.5, offset = 0.5059)

inputs=[pattern.Composite(generators = [lefteye, righteye, mouth],
                  operator = numpy.maximum, size = 1.7,
                  orientation=numbergen.UniformRandom(lbound=17.0/36.0*pi,ubound=19.0/36.0*pi,seed=56+i),
                  x=numbergen.UniformRandom(lbound=-85.0/48.0,ubound=85.0/48.0, seed=12+i),
                  y=numbergen.UniformRandom(lbound=-85.0/48.0,ubound=85.0/48.0, seed=34+i))
        for i in xrange(num_inputs)]

combined_inputs = pattern.SeparatedComposite(min_separation=1.722972972972973,generators=inputs)



### Sheets
topo.sim['Retina']=sheet.GeneratorSheet(
    nominal_density=locals().get('default_retina_density',48.0),
    nominal_bounds=sheet.BoundingBox(radius=1.77),
    input_generator=combined_inputs,period=1.0,phase=0.05)

topo.sim['LGNOn']=sheet.CFSheet(
    nominal_density=locals().get('default_lgn_density',24.0),    
    nominal_bounds=sheet.BoundingBox(radius=1.542),
    output_fn=outputfn.PiecewiseLinear(lower_bound=0.0,upper_bound=1.0))

topo.sim['LGNOff']=sheet.CFSheet(
    nominal_density=locals().get('default_lgn_density',24.0),    
    nominal_bounds=sheet.BoundingBox(radius=1.542),
    output_fn=outputfn.PiecewiseLinear(lower_bound=0.0,upper_bound=1.0))

topo.sim['FSA'] = sheet.lissom.LISSOM(
    nominal_density=locals().get('default_density',24.0),tsettle=9,
    nominal_bounds=sheet.BoundingBox(radius=0.5),
    output_fn=outputfn.PiecewiseLinear(lower_bound=0.1,upper_bound=0.65))



### Connections

# DoG weights for the LGN
centerg   = pattern.Gaussian(size=0.11079,aspect_ratio=1.0,output_fn=outputfn.DivisiveNormalizeL1(norm_value=2.33))
surroundg = pattern.Gaussian(size=0.17725,aspect_ratio=1.0,output_fn=outputfn.DivisiveNormalizeL1(norm_value=2.33))

on_weights = pattern.Composite(
    generators=[centerg,surroundg],operator=numpy.subtract)

off_weights = pattern.Composite(
    generators=[surroundg,centerg],operator=numpy.subtract)


topo.sim.connect('Retina','LGNOn',delay=0.05,
                 connection_type=projection.SharedWeightCFProjection,strength=10.199999999999999,
                 nominal_bounds_template=sheet.BoundingBox(radius=0.235),name='RetinaToLGNOn',
                 weights_generator=on_weights)

topo.sim.connect('Retina','LGNOff',delay=0.05,
                 connection_type=projection.SharedWeightCFProjection,strength=10.199999999999999,
                 nominal_bounds_template=sheet.BoundingBox(radius=0.235),name='RetinaToLGNOff',
                 weights_generator=off_weights)

topo.sim.connect('LGNOn','FSA',delay=0.05, dest_port=('Activity','JointNormalize', 'Afferent'),
                 connection_type=projection.CFProjection,strength=1.0700000000000001,name='LGNOnAfferent',
                 # JABALERT: Should probably simplify this by making a function for it.
                 weights_generator=pattern.Gaussian(aspect_ratio=1.0, size=0.4167),
                 nominal_bounds_template=sheet.BoundingBox(radius=1.0625),learning_rate=9.533)

topo.sim.connect('LGNOff','FSA',delay=0.05, dest_port=('Activity','JointNormalize', 'Afferent'),
                 connection_type=projection.CFProjection,strength=1.07,name='LGNOffAfferent',
                 weights_generator=pattern.Gaussian(aspect_ratio=1.0, size=0.4167),
                 nominal_bounds_template=sheet.BoundingBox(radius=1.0625),learning_rate=9.533,)

topo.sim.connect('FSA','FSA',delay=0.05,name='LateralExcitatory',
                 connection_type=projection.CFProjection,strength=0.9,
                 weights_generator=pattern.Gaussian(aspect_ratio=1.0, size=0.4167),
                 nominal_bounds_template=sheet.BoundingBox(radius=0.166666666667),learning_rate=3.1856)

topo.sim.connect('FSA','FSA',delay=0.05,name='LateralInhibitory',
                 connection_type=projection.CFProjection,strength=-0.9,
                 weights_generator=pattern.Gaussian(aspect_ratio=1.0, size=0.4167),
                 nominal_bounds_template=sheet.BoundingBox(radius=0.416666666667),learning_rate=2.3627)



### Actions scheduled to occur as the simulation proceeds.#
topo.sim.startup_commands.append("from topo import sheet")

# Convenience variable: timescale
st=1.0/2.0

### Lateral excitatory bounds changes
LE='topo.sim["FSA"].projections()["LateralExcitatory"]'

topo.sim.schedule_command( 200*st, LE+'.change_bounds(sheet.BoundingBox(radius=0.1,min_radius=0.0625))')
topo.sim.schedule_command( 500*st, LE+'.change_bounds(sheet.BoundingBox(radius=0.1167,min_radius=0.0625))')
topo.sim.schedule_command(1000*st, LE+'.change_bounds(sheet.BoundingBox(radius=0.1333,min_radius=0.0625))')
topo.sim.schedule_command(2000*st, LE+'.change_bounds(sheet.BoundingBox(radius=0.1333,min_radius=0.0625))')
topo.sim.schedule_command(3000*st, LE+'.change_bounds(sheet.BoundingBox(radius=0.1333,min_radius=0.0625))')
topo.sim.schedule_command(4000*st, LE+'.change_bounds(sheet.BoundingBox(radius=0.1,min_radius=0.0625))')
topo.sim.schedule_command(5000*st, LE+'.change_bounds(sheet.BoundingBox(radius=0.1,min_radius=0.0625))')
topo.sim.schedule_command(6500*st, LE+'.change_bounds(sheet.BoundingBox(radius=0.1,min_radius=0.0625))')
topo.sim.schedule_command(10000*st,LE+'.change_bounds(sheet.BoundingBox(radius=0.1,min_radius=0.0625))')
topo.sim.schedule_command(20000*st,LE+'.change_bounds(sheet.BoundingBox(radius=0.1,min_radius=0.0625))')


### Lateral excitatory learning rate changes
topo.sim.schedule_command( 200*st, LE+'.learning_rate=0.063375*'+LE+'.n_units()')
topo.sim.schedule_command( 500*st, LE+'.learning_rate=0.0316875*'+LE+'.n_units()')


### Afferent learning rate changes
ON ='topo.sim["FSA"].projections()["LGNOnAfferent"]'
OFF='topo.sim["FSA"].projections()["LGNOffAfferent"]'


topo.sim.schedule_command( 200*st, ON+'.learning_rate=0.004667*'+ON+'.n_units()')
topo.sim.schedule_command( 500*st, ON+'.learning_rate=0.003333*'+ON+'.n_units()')
topo.sim.schedule_command(1000*st, ON+'.learning_rate=0.003333*'+ON+'.n_units()')
topo.sim.schedule_command(2000*st, ON+'.learning_rate=0.002667*'+ON+'.n_units()')
topo.sim.schedule_command(3000*st, ON+'.learning_rate=0.002667*'+ON+'.n_units()')
topo.sim.schedule_command(4000*st, ON+'.learning_rate=0.002*'+ON+'.n_units()')
topo.sim.schedule_command(5000*st, ON+'.learning_rate=0.002*'+ON+'.n_units()')
topo.sim.schedule_command(6500*st, ON+'.learning_rate=0.002*'+ON+'.n_units()')
topo.sim.schedule_command(10000*st,ON+'.learning_rate=0.002*'+ON+'.n_units()')
topo.sim.schedule_command(20000*st,ON+'.learning_rate=0.001*'+ON+'.n_units()')

topo.sim.schedule_command( 200*st, OFF+'.learning_rate=0.004667*'+OFF+'.n_units()')
topo.sim.schedule_command( 500*st, OFF+'.learning_rate=0.003333*'+OFF+'.n_units()')
topo.sim.schedule_command(1000*st, OFF+'.learning_rate=0.003333*'+OFF+'.n_units()')
topo.sim.schedule_command(2000*st, OFF+'.learning_rate=0.002667*'+OFF+'.n_units()')
topo.sim.schedule_command(3000*st, OFF+'.learning_rate=0.002667*'+OFF+'.n_units()')
topo.sim.schedule_command(4000*st, OFF+'.learning_rate=0.002*'+OFF+'.n_units()')
topo.sim.schedule_command(5000*st, OFF+'.learning_rate=0.002*'+OFF+'.n_units()')
topo.sim.schedule_command(6500*st, OFF+'.learning_rate=0.002*'+OFF+'.n_units()')
topo.sim.schedule_command(10000*st,OFF+'.learning_rate=0.002*'+OFF+'.n_units()')
topo.sim.schedule_command(20000*st,OFF+'.learning_rate=0.001*'+OFF+'.n_units()')


### Activation function threshold changes
OF='topo.sim["FSA"].output_fn'

topo.sim.schedule_command( 200*st, OF+'.lower_bound=0.093;'+OF+'.upper_bound=0.643')
topo.sim.schedule_command( 500*st, OF+'.lower_bound=0.103;'+OF+'.upper_bound=0.653')
topo.sim.schedule_command(1000*st, OF+'.lower_bound=0.133;'+OF+'.upper_bound=0.663')
topo.sim.schedule_command(2000*st, OF+'.lower_bound=0.163;'+OF+'.upper_bound=0.683')
topo.sim.schedule_command(3000*st, OF+'.lower_bound=0.183;'+OF+'.upper_bound=0.713')
topo.sim.schedule_command(4000*st, OF+'.lower_bound=0.183;'+OF+'.upper_bound=0.743')
topo.sim.schedule_command(5000*st, OF+'.lower_bound=0.193;'+OF+'.upper_bound=0.773')
topo.sim.schedule_command(6500*st, OF+'.lower_bound=0.203;'+OF+'.upper_bound=0.803')
topo.sim.schedule_command(10000*st,OF+'.lower_bound=0.213;'+OF+'.upper_bound=0.833')
topo.sim.schedule_command(20000*st,OF+'.lower_bound=0.223;'+OF+'.upper_bound=0.863')


### Settling steps changes
topo.sim.schedule_command( 200*st, 'topo.sim["FSA"].tsettle=9')
topo.sim.schedule_command( 500*st, 'topo.sim["FSA"].tsettle=9')
topo.sim.schedule_command(1000*st, 'topo.sim["FSA"].tsettle=9')
topo.sim.schedule_command(2000*st, 'topo.sim["FSA"].tsettle=10')
topo.sim.schedule_command(3000*st, 'topo.sim["FSA"].tsettle=10')
topo.sim.schedule_command(4000*st, 'topo.sim["FSA"].tsettle=10')
topo.sim.schedule_command(5000*st, 'topo.sim["FSA"].tsettle=11')
topo.sim.schedule_command(6500*st, 'topo.sim["FSA"].tsettle=12')
topo.sim.schedule_command(10000*st,'topo.sim["FSA"].tsettle=13')
topo.sim.schedule_command(20000*st,'topo.sim["FSA"].tsettle=13')


# default locations for model editor
topo.sim['FSA'   ].layout_location=(306,225)
topo.sim['LGNOn' ].layout_location=(432,345)
topo.sim['LGNOff'].layout_location=(150,345)
topo.sim['Retina'].layout_location=(279,500)
