"""
Example of a LISSOM-based orientation map (with ON/OFF channels).

Is based on topo/tests/reference/lissom_or_reference.ty which matches the
orientation map simulation from figure 6.4 (Reduced) of
Miikkulainen, Bednar, Choe, and Sirosh (2005), Computational Maps in
the Visual Cortex, Springer, except:

 - The default_density is smaller for practicality (142 in the book).
   The matching is not yet perfect at different densities
 - The lateral inhibitory radius is 0.5 matrix units greater than in the 
   book, becauseTopographica enforces good circular-shaped CF outlines.
 - Input patterns are evaluated on the entire retina, instead of only up
   to bounds_multiplier=2.5 times the gaussian sigma in the book
 - Weight patterns are not smoothed around the edges, unlike
   smooth_circular_outlines=True and smooth_circular_radius_trim=-0.25
   used in the book
 - Initial weight patterns are all random within a gaussian envelope
   rather than random afferent and Gaussian sigma preset_sigma_exc=11.076
   preset_sigma_inh=71.76 lateral weights used in the book.
 - Inhibitory weight pruning is disabled (not pruning all weights below
   1e-5 as in the book)


$Id$
"""
__version__='$$'


import numpy.oldnumeric.random_array as RandomArray
import fixedpoint
import numpy.oldnumeric as Numeric
import numpy

from math import pi, sqrt
from fixedpoint import FixedPoint

import topo.patterns.basic
import topo.patterns.random

from topo.sheets.lissom import LISSOM
from topo.sheets.generatorsheet import GeneratorSheet
from topo.projections.basic import CFProjection, SharedWeightCFProjection
from topo.responsefns.optimized import CFPRF_DotProduct_opt
from topo.base.parameterclasses import DynamicNumber
from topo.base.cf import CFSheet
from topo.base.boundingregion import BoundingBox
from topo.learningfns.optimized import CFPLF_Hebbian_opt
from topo.outputfns.optimized import CFPOF_DivisiveNormalizeL1_opt
from topo.outputfns.basic import PiecewiseLinear, DivisiveNormalizeL1
from topo.misc.numbergenerators import UniformRandom
from topo.outputfns.homeostatic import HomeostaticMaxEnt

topo.sim.name = "lissom_oo_or_homeomaxent"

num_inputs=2
input_type=topo.patterns.basic.Gaussian
inputs=[input_type(x=DynamicNumber(UniformRandom(lbound=-0.75,ubound=0.75,seed=12+i)),
                   y=DynamicNumber(UniformRandom(lbound=-0.75,ubound=0.75,seed=34+i)),
                   orientation=DynamicNumber(UniformRandom(lbound=-pi,ubound=pi,seed=56+i)),
                   size=0.088388, aspect_ratio=4.66667, scale=1.0,
                   bounds=BoundingBox(radius=0.8))
                for i in xrange(num_inputs)]

combined_inputs = topo.patterns.basic.SeparatedComposite(min_separation=2.2*0.27083,generators=inputs)
                                 
# Specify weight initialization, response function, and learning function
RandomArray.seed(500,500)
CFProjection.weights_shape = topo.patterns.basic.Disk(smoothing=0.0)
CFProjection.weights_generator = topo.patterns.basic.Constant()
CFProjection.response_fn=CFPRF_DotProduct_opt()
CFProjection.learning_fn=CFPLF_Hebbian_opt()
CFProjection.weights_output_fn=CFPOF_DivisiveNormalizeL1_opt()
SharedWeightCFProjection.response_fn=CFPRF_DotProduct_opt()

###########################################
# build simulation

topo.sim['Retina']=GeneratorSheet(nominal_density=24.0,
                                  input_generator=combined_inputs,
                                  period=1.0, phase=0.05,
                                  nominal_bounds=BoundingBox(radius=0.5+0.25+0.375))

topo.sim['LGNOn']=CFSheet(nominal_density=24.0,
                          nominal_bounds=BoundingBox(radius=0.5+0.25),
                          output_fn=PiecewiseLinear(lower_bound=0.0,upper_bound=1.0),
                          measure_maps=False)

topo.sim['LGNOff']=CFSheet(nominal_density=24.0,
                           nominal_bounds=BoundingBox(radius=0.5+0.25),
                           output_fn=PiecewiseLinear(lower_bound=0.0,upper_bound=1.0),
                           measure_maps=False)

topo.sim['V1'] = LISSOM(nominal_density=locals().get('default_density',48.0),tsettle=9, output_fn=HomeostaticMaxEnt())


# DoG weights for the LGN
centerg = topo.patterns.basic.Gaussian(
    size=0.07385,aspect_ratio=1.0,output_fn=DivisiveNormalizeL1())

surroundg = topo.patterns.basic.Gaussian(
    size=0.2954, aspect_ratio=1.0,output_fn=DivisiveNormalizeL1())

on_weights = topo.patterns.basic.Composite(
    generators=[centerg,surroundg],operator=numpy.subtract)

off_weights = topo.patterns.basic.Composite(
    generators=[surroundg,centerg],operator=numpy.subtract)



topo.sim.connect('Retina','LGNOn',delay=FixedPoint("0.05"),
                 connection_type=SharedWeightCFProjection,strength=2.33,
                 nominal_bounds_template=BoundingBox(radius=0.375),name='Afferent',
                 weights_generator=on_weights)

topo.sim.connect('Retina','LGNOff',delay = FixedPoint("0.05"),
                 connection_type=SharedWeightCFProjection,strength=2.33,
                 nominal_bounds_template=BoundingBox(radius=0.375),name='Afferent',
                 weights_generator=off_weights)

topo.sim.connect('LGNOn','V1',delay=FixedPoint("0.05"), dest_port=('Activity','JointNormalize', 'Afferent'),
                 connection_type=CFProjection,strength=1.0,name='LGNOnAfferent',
                 weights_generator=topo.patterns.basic.Composite(operator=numpy.multiply, 
                                                                 generators=[Gaussian(aspect_ratio=1.0, size=2*0.27083),
                                                                             topo.patterns.random.UniformRandom()]),
                 nominal_bounds_template=BoundingBox(radius=0.27083),learning_rate=0.9590/2)

topo.sim.connect('LGNOff','V1',delay=FixedPoint("0.05"), dest_port=('Activity','JointNormalize', 'Afferent'),
                 connection_type=CFProjection,strength=1.0,name='LGNOffAfferent',
                 weights_generator=topo.patterns.basic.Composite(operator=numpy.multiply, 
                                                                 generators=[Gaussian(aspect_ratio=1.0, size=2*0.27083),
                                                                             topo.patterns.random.UniformRandom()]),
                 nominal_bounds_template=BoundingBox(radius=0.27083),learning_rate=0.9590/2)

topo.sim.connect('V1','V1',delay=FixedPoint("0.05"),name='LateralExcitatory',
                 connection_type=CFProjection,strength=0.9,
                 weights_generator=topo.patterns.basic.Composite(operator=numpy.multiply, 
                                                                 generators=[Gaussian(aspect_ratio=1.0, size=2*0.10417),
                                                                             topo.patterns.random.UniformRandom()]),
                 nominal_bounds_template=BoundingBox(radius=0.10417),learning_rate=2.55528) 
            
topo.sim.connect('V1','V1',delay=FixedPoint("0.05"),name='LateralInhibitory',
                 connection_type=CFProjection,strength=-0.9,
                 weights_generator=topo.patterns.basic.Composite(operator=numpy.multiply, 
                                                                 generators=[Gaussian(aspect_ratio=1.0, size=2*0.22917),
                                                                             topo.patterns.random.UniformRandom()]),
                 nominal_bounds_template=BoundingBox(radius=0.22917),learning_rate=1.80873)  


### Actions scheduled to occur as the simulation proceeds.#
topo.sim.startup_commands.append("from topo.base.boundingregion import BoundingBox")

def n_units(x):
    """Same technique as in cf.py for counting the number of units."""
    density=topo.sim["V1"].nominal_density
    center_unit=(int(density/2),int(density/2))
    return len(Numeric.nonzero(Numeric.ravel(x.cf(*center_unit).mask)))

# Convenience variable: timescale
st=1.0/num_inputs

### Lateral excitatory bounds changes
topo.sim.schedule_command(  200*st,'topo.sim["V1"].projections()["LateralExcitatory"].change_bounds(BoundingBox(radius=0.0625))')
topo.sim.schedule_command(  500*st,'topo.sim["V1"].projections()["LateralExcitatory"].change_bounds(BoundingBox(radius=0.04375))')
topo.sim.schedule_command( 1000*st,'topo.sim["V1"].projections()["LateralExcitatory"].change_bounds(BoundingBox(radius=0.035))')
topo.sim.schedule_command( 2000*st,'topo.sim["V1"].projections()["LateralExcitatory"].change_bounds(BoundingBox(radius=0.02800))')
topo.sim.schedule_command( 3000*st,'topo.sim["V1"].projections()["LateralExcitatory"].change_bounds(BoundingBox(radius=0.02240))')
topo.sim.schedule_command( 4000*st,'topo.sim["V1"].projections()["LateralExcitatory"].change_bounds(BoundingBox(radius=0.01344))')
topo.sim.schedule_command( 5000*st,'topo.sim["V1"].projections()["LateralExcitatory"].change_bounds(BoundingBox(radius=0.00806))')
topo.sim.schedule_command( 6500*st,'topo.sim["V1"].projections()["LateralExcitatory"].change_bounds(BoundingBox(radius=0.00484))')
topo.sim.schedule_command( 8000*st,'topo.sim["V1"].projections()["LateralExcitatory"].change_bounds(BoundingBox(radius=0.00290))')
topo.sim.schedule_command(20000*st,'topo.sim["V1"].projections()["LateralExcitatory"].change_bounds(BoundingBox(radius=0.00174))')

### Lateral excitatory learning rate changes
LE=topo.sim["V1"].projections()["LateralExcitatory"]

topo.sim.schedule_command(  200*st,'topo.sim["V1"].projections()["LateralExcitatory"].learning_rate=0.12168*n_units(LE)')
topo.sim.schedule_command(  500*st,'topo.sim["V1"].projections()["LateralExcitatory"].learning_rate=0.06084*n_units(LE)')
topo.sim.schedule_command( 1000*st,'topo.sim["V1"].projections()["LateralExcitatory"].learning_rate=0.06084*n_units(LE)')
topo.sim.schedule_command( 2000*st,'topo.sim["V1"].projections()["LateralExcitatory"].learning_rate=0.06084*n_units(LE)')
topo.sim.schedule_command( 3000*st,'topo.sim["V1"].projections()["LateralExcitatory"].learning_rate=0.06084*n_units(LE)')
topo.sim.schedule_command( 4000*st,'topo.sim["V1"].projections()["LateralExcitatory"].learning_rate=0.06084*n_units(LE)')
topo.sim.schedule_command( 5000*st,'topo.sim["V1"].projections()["LateralExcitatory"].learning_rate=0.06084*n_units(LE)')
topo.sim.schedule_command( 6500*st,'topo.sim["V1"].projections()["LateralExcitatory"].learning_rate=0.06084*n_units(LE)')
topo.sim.schedule_command( 8000*st,'topo.sim["V1"].projections()["LateralExcitatory"].learning_rate=0.06084*n_units(LE)')
topo.sim.schedule_command(20000*st,'topo.sim["V1"].projections()["LateralExcitatory"].learning_rate=0.06084*n_units(LE)')

### Afferent learning rate changes
topo.sim.schedule_command(  500*st,'topo.sim["V1"].projections()["LGNOnAfferent"].learning_rate=0.685/2;topo.sim["V1"].projections()["LGNOffAfferent"].learning_rate=0.6850/2')
topo.sim.schedule_command( 2000*st,'topo.sim["V1"].projections()["LGNOnAfferent"].learning_rate=0.5480/2;topo.sim["V1"].projections()["LGNOffAfferent"].learning_rate=0.5480/2')
topo.sim.schedule_command( 4000*st,'topo.sim["V1"].projections()["LGNOnAfferent"].learning_rate=0.4110/2;topo.sim["V1"].projections()["LGNOffAfferent"].learning_rate=0.4110/2')
topo.sim.schedule_command(20000*st,'topo.sim["V1"].projections()["LGNOnAfferent"].learning_rate=0.2055/2;topo.sim["V1"].projections()["LGNOffAfferent"].learning_rate=0.2055/2')


# default locations for model editor
topo.sim['V1'    ].gui_x=306.0;  topo.sim['V1'    ].gui_y=225.0
topo.sim['LGNOn' ].gui_x=432.0;  topo.sim['LGNOn' ].gui_y=345.0
topo.sim['LGNOff'].gui_x=150.0;  topo.sim['LGNOff'].gui_y=345.0
topo.sim['Retina'].gui_x=279.0;  topo.sim['Retina'].gui_y=500.0


topo.sim.run(0)

## import hotshot,hotshot.stats
## prof = hotshot.Profile("abc")
## prof.runctx('topo.sim.run(199)',globals(),locals())
## prof.close()
## p = hotshot.stats.load("abc")
## p.strip_dirs().sort_stats('cumulative','time').print_stats()
