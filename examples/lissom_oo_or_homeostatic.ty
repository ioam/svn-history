"""
Simulation for development of stable orientation maps based on lissom_oo_or_noshrinking.ty
(see Chapman et. al, J. Neurosci 16(20):6443, 1996). The development is also robust
to changes in the input (e.g., number of Gaussians in the retinal input or brightness of each Gaussian).
Afferent projection activities for individual units are scaled based
on maintaining a target average afferent activity. The learning rate (and
rate of learning rate decrease) for afferent projections are also scaled in
order to maintain the overall rate of learning despite changes in LGN activity.
The sigmoidal output function for V1 is regulated using the Triesch rule
(Jochen Triesch,ICANN 2005, LNCS 3696 pp.65-70) which maintains stable activity
in V1 given a target average activity. The current script is set up as a debug version
for plotting sheet and projection attributes throughout development.
If the statistics of the input (but not the contrast) are changed then the afferent_target
and the average V1 activity need to be changed in order to maintain similar responses in V1. 
"""
__version__=''


import fixedpoint
import numpy

from math import pi, sqrt
from fixedpoint import FixedPoint

import topo.patterns.basic
import topo.patterns.random

from topo.patterns.basic import Gaussian
from topo.sheets.lissom import JointScaling
from topo.sheets.generatorsheet import GeneratorSheet
from topo.projections.basic import CFProjection, SharedWeightCFProjection
from topo.responsefns.optimized import CFPRF_DotProduct_opt
from topo.base.cf import CFSheet, CFPLF_PluginScaled
from topo.base.boundingregion import BoundingBox
from topo.learningfns.optimized import CFPLF_Hebbian_opt
from topo.outputfns.optimized import CFPOF_DivisiveNormalizeL1_opt
from topo.outputfns.basic import PiecewiseLinear, DivisiveNormalizeL1, PipelineOF, IdentityOF, ActivityAveragingOF, AttributeTrackingOF, Sigmoid, SheetAttributeTrackingOF
from topo.misc.numbergenerators import UniformRandom
from topo.outputfns.homeostatic import HomeostaticMaxEnt
from topo.misc.numbergenerators import UniformRandom, BoundedNumber, ExponentialDecay
from topo.patterns.image import Image

####Input type###
type_input=locals().get('ti',"Gaussian")
scale = locals().get('scale', 1.0)

rand_seedx = locals().get('seedx', 12) #For running differently seeded simulations
rand_seedy = locals().get('seedy', 36)
rand_seedo = locals().get('seedo', 54)
rand_weights=locals().get('seedweights', 500)

if type_input=="Gaussian":
    input_type=Gaussian
    num_inputs=locals().get('ni',2)
    inputs=[input_type(x=UniformRandom(lbound=-0.75,ubound=0.75,seed=rand_seedx+i),
                       y=UniformRandom(lbound=-0.75,ubound=0.75,seed=rand_seedy+i),
                       orientation=UniformRandom(lbound=-pi,ubound=pi,seed=rand_seedo+i),
                       size=0.088388, aspect_ratio=4.66667, scale=scale, bounds=BoundingBox(radius=0.8))
            for i in xrange(num_inputs)]
    
    combined_inputs = topo.patterns.basic.SeparatedComposite(min_separation=0,generators=inputs)
    
elif type_input=="Natural":
    
    input_type=topo.patterns.image.Image
    inputs=[input_type(filename="images/shouval/"+f,
                       size=10.0,  #size_normalization='original',(size=10.0)
                       x=UniformRandom(lbound=-0.75,ubound=0.75,seed=rand_seedx),
                       y=UniformRandom(lbound=-0.75,ubound=0.75,seed=rand_seedy),
                   
                       orientation=UniformRandom(lbound=-pi,ubound=pi,seed=rand_seedo))
            for f in ["base06.png", "base11.png", "base13.png", "base14.png", "base15.png",
                      "base16.png", "base17.png", "base18.png", "base19.png", "base20.png", "base21.png",
                      "base22.png", "base24.png", "new_images01.png", "new_images02.png", "new_images03.png",
                      "new_images04.png", "new_images05.png", "new_images06.png", "new_images07.png",
                      "new_images08.png", "new_images09.png", "new_images10.png", "new_images11.png",
                      "new_images12.png"]]

    combined_inputs =topo.patterns.basic.Selector(generators=inputs)

elif type_input=="NoisyDisks":
    
    input_type=topo.patterns.basic.Composite
    inputs=[input_type(operator=numpy.multiply,
                       generators=[topo.patterns.basic.Disk(x=UniformRandom(lbound=-0.75,ubound=0.75,seed=rand_seedx),
                                                            y=UniformRandom(lbound=-0.75,ubound=0.75,seed=rand_seedy),
                                                            size=2.0, aspect_ratio=1.0, scale=1.0,
                                                            offset=0.5,
                                                            bounds=BoundingBox(radius=0.8), smoothing=0.1),
                                   topo.patterns.random.UniformRandom()])]
            
    combined_inputs =topo.patterns.basic.Selector(generators=inputs)


#Units to track for debugging
V1_units=[(0, 47), (12, 36),(24, 24), (36, 12),(47, 0)]
LGN_units=[(0,23), (6,18), (12,12), (18,6), (23,0)]

#Smoothing value for exponential averaging
smoothing=locals().get('smoothing',0.999)

#Output functions: Sheets
#LGN
LGN_on_output_fn=PiecewiseLinear(lower_bound=0.0,upper_bound=1.0)
LGN_off_output_fn=PiecewiseLinear(lower_bound=0.0,upper_bound=1.0)

#V1
triesch=locals().get('triesch', True)
if triesch==True:
    Attrib_Tracker=SheetAttributeTrackingOF(sheet = "V1", attrib_names=['x_avg', 'sf', 'scaled_x_avg'], units=V1_units)
    HE=HomeostaticMaxEnt(smoothing=smoothing, eta=locals().get('eta',0.002), a_init=locals().get('a_init',14.5),
                         b_init=locals().get('b_init',-5.5), mu=locals().get('mu',0.01))
    V1_Tracker=AttributeTrackingOF(function=HE, attrib_names=['a', 'b','y_avg'], units=V1_units, step=1)
    V1_OF=PipelineOF(output_fns=[Attrib_Tracker, HE, V1_Tracker])
else:
    Attrib_Tracker=SheetAttributeTrackingOF(sheet = "V1", attrib_names=['x_avg', 'sf','scaled_x_avg'], units=V1_units)
    HE=Sigmoid(r=locals().get('a_init',12),k=locals().get('b_init',-5.5))
    AV=ActivityAveragingOF(smoothing=smoothing,step=1)
    V1_Tracker=AttributeTrackingOF(function=AV, attrib_names=['x_avg'], units=V1_units, step=1)
    V1_OF=PipelineOF(output_fns=[Attrib_Tracker, HE, AV, V1_Tracker])
    
#Output Functions: Projections

#Debugging
#LGNOnAfferent
LGNOn_Avg=ActivityAveragingOF(smoothing=smoothing,step=1)
LGNOn_Tracker=AttributeTrackingOF(function=LGNOn_Avg, attrib_names=['x_avg'], units=V1_units, step=1)
LGNOn_OF = PipelineOF(output_fns=[LGNOn_Avg, LGNOn_Tracker])

#LGNOffAfferent
LGNOff_Avg=ActivityAveragingOF(smoothing=smoothing,step=1)
LGNOff_Tracker=AttributeTrackingOF(function=LGNOff_Avg, attrib_names=['x_avg'], units=V1_units, step=1)
LGNOff_OF = PipelineOF(output_fns=[LGNOff_Avg, LGNOff_Tracker])

#LateralExcitatory
LatEx_Avg=ActivityAveragingOF(initial_average=0.0,smoothing=smoothing,step=1)
LatEx_Tracker=AttributeTrackingOF(function=LatEx_Avg, attrib_names=['x_avg'], units=V1_units, step=1)
LatEx_OF = PipelineOF(output_fns=[LatEx_Avg, LatEx_Tracker])

#LateralInhibitory
LatIn_Avg=ActivityAveragingOF(initial_average=0.0,smoothing=smoothing,step=1)
LatIn_Tracker = AttributeTrackingOF(function=LatIn_Avg, attrib_names=['x_avg'], units=V1_units, step=1)
LatIn_OF = PipelineOF(output_fns=[LatIn_Avg, LatIn_Tracker])


# Specify weight initialization, response function, and learning function
numpy.random.seed((rand_weights,rand_weights))

CFProjection.weights_shape = topo.patterns.basic.Disk(smoothing=0.0)
CFProjection.weights_generator = topo.patterns.basic.Constant()
CFProjection.response_fn=CFPRF_DotProduct_opt()
CFProjection.learning_fn=CFPLF_Hebbian_opt()
CFProjection.weights_output_fn=CFPOF_DivisiveNormalizeL1_opt()
SharedWeightCFProjection.response_fn=CFPRF_DotProduct_opt()

# DoG weights for the LGN
centerg   = Gaussian(size=0.07385,aspect_ratio=1.0,output_fn=DivisiveNormalizeL1())
surroundg = Gaussian(size=0.29540,aspect_ratio=1.0,output_fn=DivisiveNormalizeL1())

on_weights = topo.patterns.basic.Composite(
    generators=[centerg,surroundg],operator=numpy.subtract)

off_weights = topo.patterns.basic.Composite(
    generators=[surroundg,centerg],operator=numpy.subtract)

#Function for generating Gaussian random initial weights
def gauss_rand(size):
    return topo.patterns.basic.Composite(operator=numpy.multiply, 
                                         generators=[Gaussian(aspect_ratio=1.0, size=size),
                                                     topo.patterns.random.UniformRandom()])

#Whether or not to use divisive weights normalization
norm=locals().get('norm',True)

if norm==False:
    pi=topo.base.cf.CFPOF_Plugin(single_cf_fn=topo.outputfns.basic.IdentityOF())
else:
    pi = None


#Target for average total afferent projection activity 
afferent_target = locals().get('afferent_target',0.045)

###########################################
# build simulation

topo.sim['Retina']=GeneratorSheet(nominal_density=locals().get('default_retina_density',24.0),
                                  input_generator=combined_inputs,
                                  period=1.0, phase=0.05,
                                  nominal_bounds=BoundingBox(radius=0.5+0.25+0.375))

topo.sim['LGNOn']=CFSheet(nominal_density=24.0,
                          nominal_bounds=BoundingBox(radius=0.5+0.25),
                          output_fn=LGN_on_output_fn,
                          measure_maps=False)

topo.sim['LGNOff']=CFSheet(nominal_density=24.0,
                           nominal_bounds=BoundingBox(radius=0.5+0.25),
                           output_fn=LGN_off_output_fn,
                           measure_maps=False)

topo.sim['V1'] = JointScaling(nominal_density=locals().get('default_density',48.0),
                              nominal_bounds=BoundingBox(radius=0.5),tsettle=9,
                              learning=True,output_fn=V1_OF,
                              post_initialization_weights_output_fn=pi,
                              target=afferent_target, smoothing=smoothing, rate_only=locals().get('rate_only',False))




    
topo.sim.connect('Retina','LGNOn',delay=FixedPoint("0.05"),
                 connection_type=SharedWeightCFProjection,strength=2.33,
                 nominal_bounds_template=BoundingBox(radius=0.375),name='Afferent',
                 weights_generator=on_weights)

topo.sim.connect('Retina','LGNOff',delay = FixedPoint("0.05"),
                 connection_type=SharedWeightCFProjection,strength=2.33,
                 nominal_bounds_template=BoundingBox(radius=0.375),name='Afferent',
                 weights_generator=off_weights)

topo.sim.connect('LGNOn','V1',delay=FixedPoint("0.05"), dest_port=('Activity','JointNormalize', 'Afferent'),
                 connection_type=CFProjection,
                 output_fn=LGNOn_OF,
                 learning_fn=CFPLF_PluginScaled(),
                 strength=1.0,name='LGNOnAfferent',
                 weights_generator=gauss_rand(size=2*0.27083),
                 nominal_bounds_template=BoundingBox(radius=0.27083),
		 learning_rate=BoundedNumber(bounds=(0.137,None),generator=
							    ExponentialDecay(starting_value = 0.959,
                                                                             time_constant=72/afferent_target)))
		 
topo.sim.connect('LGNOff','V1',delay=FixedPoint("0.05"), dest_port=('Activity','JointNormalize', 'Afferent'),
		 connection_type=CFProjection,
                 output_fn=LGNOff_OF,
                 learning_fn=CFPLF_PluginScaled(),
                 strength=1.0,name='LGNOffAfferent',
                 weights_generator=gauss_rand(size=2*0.27083),
                 nominal_bounds_template=BoundingBox(radius=0.27083),
		 learning_rate=BoundedNumber(bounds=(0.137,None),generator=
							    ExponentialDecay(starting_value=0.959,
                                                                             time_constant=72/afferent_target)))

topo.sim.connect('V1','V1',delay=FixedPoint("0.05"),name='LateralExcitatory',
                 connection_type=CFProjection,
                 output_fn=LatEx_OF,
                 strength=1.0,
                 weights_generator=topo.patterns.basic.Gaussian(aspect_ratio=1.0, size=0.04),
                 nominal_bounds_template=BoundingBox(radius=0.03),learning_rate=0.0) 

topo.sim.connect('V1','V1',delay=FixedPoint("0.05"),name='LateralInhibitory',
                 connection_type=CFProjection,
                 output_fn=LatIn_OF,
                 strength=-1.0,
                 weights_generator=gauss_rand(size=2*0.22917),
                 nominal_bounds_template=BoundingBox(radius=0.22917),learning_rate=1.80873)


# default locations for model editor
topo.sim.grid_layout([[None,    'V1',     None],
                      ['LGNOn', None,     'LGNOff'],
                      [None,    'Retina', None]], xstart=150)


