"""
SOM-based orientation map based on Obermayer et al., PNAS 87, pp. 8345-8349, 1990.

Contains a Retina (2D Gaussian generator) and a V1 (CFSOM) sheet.
Each V1 neuron receives input from the entire Retina.

Known differences from the reference simulation:

  - The reference simulation uses periodic boundary conditions, so the
    borders of our simulation will have edge effects not present in the
    original.

  - Currently only isotropic Gaussian neighborhood functions are supported.

  - Not tested. :-)

$Id$
"""
__version__='$Revision$'

import RandomArray
from math import sqrt, pi

from topo.sheets.generatorsheet import GeneratorSheet
from topo.base.patterngenerator import BoundingBox
from topo.base.cf import CFProjection
from topo.responsefns.optimized import CFPDotProduct_opt1
from topo.base.parameterclasses import Number,DynamicNumber
from topo.sheets.cfsom import CFSOM
import topo.patterns.random
import topo.patterns.basic
from topo.learningfns.som import HebbianSOMLF
from topo.outputfns.basic import DivisiveSumNormalize
from topo.misc.numbergenerators import RandomWrapper

topo.sim.name = "obermayer_pnas90"


class ObermayerSOM(CFSOM):
    """A variant of CFSOM that uses linear decay functions for alpha and radius."""

    # These values have been adjusted to convert from Obermayer's
    # per-unit learning rates to Topographica's per-CF learning rates,
    # assuming a 30x30 ConnectionField.
    alpha_0 = Number(0.09)
    alpha_f = Number(0.02)

    radius_0 = Number(240.0/256.0)  # Value at the beginning of learning
    radius_m = Number(60.0/256.0)   # Value at the midpoint of learning
    radius_f = Number(2.0/256.0)    # Value at the end of learning
    midpoint = 15000
    
    def alpha(self):
        return self.alpha_0 + (self.alpha_f-self.alpha_0)/self.learning_length*float(self.simulation.time())
    
    def radius(self):
       """Two-part piecewise-linear decay function."""
       if self.simulation.time() < self.midpoint:
         return self.radius_0 + (self.radius_m-self.radius_0)/self.midpoint*float(self.simulation.time())
       else:
         return self.radius_m + (self.radius_f-self.radius_m)/(self.learning_length-self.midpoint)*float(self.simulation.time()-self.midpoint)



###########################################
# Set parameters

# input patterns
GeneratorSheet.period = 1.0
GeneratorSheet.density = 30


gaussian_width = 0.23/sqrt(2)
gaussian_height = 0.09/sqrt(2)

input_pattern = topo.patterns.basic.Gaussian(
    x=DynamicNumber(RandomWrapper("uniform",-0.5,0.5,seed=12)),
    y=DynamicNumber(RandomWrapper("uniform",-0.5,0.5,seed=34)),
    orientation=DynamicNumber(RandomWrapper("uniform",-pi,pi,seed=56)),
    size=2*gaussian_height,aspect_ratio=gaussian_width/gaussian_height,
    bounds=BoundingBox(radius=0.5))

# cortical sheet
ObermayerSOM.density = 25 #6
ObermayerSOM.learning_length = 30000

RandomArray.seed(500,500)
CFProjection.weights_generator = topo.patterns.random.UniformRandom()
CFProjection.nominal_bounds_template = BoundingBox(radius=1.0)
CFProjection.response_fn = CFPDotProduct_opt1()
CFProjection.learning_fn=HebbianSOMLF()

# Weights should be initialized to sum to unity: (Will this work?)
# CEBHACKALERT: they will be made to sum to 1 after every learning iteration.
# I guess that isn't what was intended?
CFProjection.weights_output_fn.single_cf_fn=DivisiveSumNormalize()


topo.sim['Retina'] = GeneratorSheet(input_generator=input_pattern)
topo.sim['V1'] = ObermayerSOM()
topo.sim.connect('Retina','V1',delay=0.5,connection_type=CFProjection)

topo.sim.run(0)
