"""
SOM-based orientation map based on Obermayer et al., PNAS 87, pp. 8345-8349, 1990.

Contains a Retina (2D Gaussian generator) and a V1 (SOM) sheet.
Each V1 neuron receives input from the entire Retina.

Known differences from the reference simulation:

  - The reference simulation uses periodic boundary conditions, so the
    borders of our simulation will have edge effects not present in the
    original.

  - Currently only isotropic Gaussian neighborhood functions are implemented.

  - Not tested. :-)

$Id$
"""
__version__='$Revision$'

import numpy

from math import sqrt, pi

import topo

from topo.base.boundingregion import BoundingBox
from topo.base.cf import CFSheet,CFProjection
from topo.base.parameterclasses import DynamicNumber,Number
from topo.learningfns.projfns import CFPLF_EuclideanHebbian
from topo.misc.numbergenerators import UniformRandom,BoundedNumber
from topo.outputfns.basic import DivisiveNormalizeL1
from topo.outputfns.basic import KernelMax
from topo.responsefns.optimized import CFPRF_DotProduct_opt
from topo.sheets.generatorsheet import GeneratorSheet
from topo.base.parameterizedobject import ParameterizedObject

import topo.patterns.basic
import topo.patterns.random

topo.sim.name = "obermayer_pnas90"

class LinearDecay(ParameterizedObject):
    """Linear function decreasing from the starting_value to the ending_value."""
    starting_value = Number(0.09,doc="""Value at the beginning of learning.""")
    ending_value = Number(0.02,doc="""Value at the end of learning.""")
    duration = Number(30000,doc="""Time for the ending_value.""")
    time_fn = topo.sim.time
    
    def __call__(self):
        return self.starting_value + (self.ending_value-self.starting_value)/self.duration*float(self.time_fn())


class PiecewiseLinearDecay(ParameterizedObject):
    """Two-part piecewise-linear decay function."""

    starting_value = Number(240.0/256.0,doc="""Value at the beginning of learning.""")
    middle_value = Number(60.0/256.0,doc="""Value at the midpoint of learning.""")
    ending_value = Number(2.0/256.0,doc="""Value at the end of learning.""")
    midpoint = Number(15000,doc="""Time for the middle_value.""")
    duration = Number(30000,doc="""Time for the ending_value.""")
    time_fn = topo.sim.time

    def __call__(self):
       if self.time_fn() < self.midpoint:
         return self.starting_value + (self.middle_value-self.starting_value)/self.midpoint*float(self.time_fn())
       else:
         return self.middle_value + (self.ending_value-self.middle_value)/(self.duration-self.midpoint)*float(self.time_fn()-self.midpoint)



###########################################
# Set parameters

# input patterns
GeneratorSheet.period = 1.0
GeneratorSheet.phase = 0.05
GeneratorSheet.nominal_density = 30

gaussian_width = 0.23/sqrt(2)
gaussian_height = 0.09/sqrt(2)

input_pattern = topo.patterns.basic.Gaussian(
    x=DynamicNumber(UniformRandom(lbound=-0.5,ubound=0.5,seed=12)),
    y=DynamicNumber(UniformRandom(lbound=-0.5,ubound=0.5,seed=34)),
    orientation=DynamicNumber(UniformRandom(lbound=-pi,ubound=pi,seed=56)),
    size=2*gaussian_height,aspect_ratio=gaussian_width/gaussian_height,
    bounds=BoundingBox(radius=0.5))

# cortical sheet (original network had a density of 256, but that is too large for normal use)
numpy.random.seed((500,500))

topo.sim['Retina'] = GeneratorSheet(input_generator=input_pattern)

default_density=locals().get('default_density',25) #256

KernelMax.kernel_radius=DynamicNumber(PiecewiseLinearDecay())

topo.sim['V1'] = CFSheet(
    nominal_density = default_density,
    output_fn = KernelMax(density=default_density))

from topo.misc.numbergenerators import ExponentialDecay
CFProjection.learning_rate=DynamicNumber(LinearDecay())
topo.sim.connect('Retina','V1',delay=0.10,connection_type=CFProjection,
                 response_fn = CFPRF_DotProduct_opt(),
                 learning_fn = CFPLF_EuclideanHebbian(),
                 nominal_bounds_template = BoundingBox(radius=1.0),
                 weights_generator = topo.patterns.random.UniformRandom())

# Initialize weight values once; should verify that it does this ok
from topo.outputfns.basic import IdentityOF
topo.sim.schedule_command(0,'topo.sim["V1"].weights_output_fn=IdentityOF()')
