"""
SOM-based orientation map based on Obermayer et al., PNAS 87, pp. 8345-8349, 1990.

Contains a Retina (2D Gaussian generator) and a V1 (CFSOM) sheet.
Each V1 neuron receives input from the entire Retina.

Known differences from the reference simulation:

  - The reference simulation uses periodic boundary conditions, so the
    borders of our simulation will have edge effects not present in the
    original.

  - Currently only isotropic Gaussian neighborhood functions are supported.

  - Not tested. :-)

$Id$
"""
__version__='$Revision$'

import random
import RandomArray
from math import sqrt

from topo.sheets.generatorsheet import GeneratorSheet
from topo.base.patterngenerator import BoundingBox
from topo.base.connectionfield import CFProjection
from topo.responsefns.optimized import CFDotProduct
from topo.base.parameter import Number,DynamicNumber
from topo.sheets.cfsom import CFSOM
import topo.patterns.random
import topo.patterns.basic
from topo.base.simulator import Simulator
from topo.learningfns.basic import HebbianSOMLF
from topo.patterns import PatternGeneratorParameter
from topo.outputfns.basic import DivisiveSumNormalize


class ObermayerSOM(CFSOM):
    """A variant of CFSOM that uses linear decay functions for alpha and radius."""

    # These values have been adjusted to convert from Obermayer's per-unit learning rates
    # to Topographica's per-CF learning rates, assuming a 30x30 ConnectionField.
    alpha_0 = Number(0.09*(30*30))
    alpha_f = Number(0.02*(30*30))

    radius_0 = Number(240.0/256.0)  # Value at the beginning of learning
    radius_m = Number(60.0/256.0)   # Value at the midpoint of learning
    radius_f = Number(2.0/256.0)    # Value at the end of learning
    midpoint = 15000
    
    def alpha(self):
        return self.alpha_0 + (self.alpha_f-self.alpha_0)/self.learning_length*float(self.simulator.time())
    
    def radius(self):
       """Two-part piecewise-linear decay function."""
       if self.simulator.time() < self.midpoint:
         return self.radius_0 + (self.radius_m-self.radius_0)/self.midpoint*float(self.simulator.time())
       else:
         return self.radius_m + (self.radius_f-self.radius_m)/(self.learning_length-self.midpoint)*float(self.simulator.time()-self.midpoint)



###########################################
# Set parameters

# input patterns
GeneratorSheet.period = 1.0
GeneratorSheet.density = 30

random.seed(1234)
topo.patterns.basic.Gaussian.x = DynamicNumber(lambda : random.uniform(-0.5,0.5),softbounds=(-1.0,1.0))
topo.patterns.basic.Gaussian.y = DynamicNumber(lambda : random.uniform(-0.5,0.5),softbounds=(-1.0,1.0))
topo.patterns.basic.Gaussian.orientation = DynamicNumber(lambda :random.uniform(-pi,pi),softbounds=(0,2*pi))

gaussian_width = 0.23/sqrt(2)
gaussian_height = 0.09/sqrt(2)
topo.patterns.basic.Gaussian.size  = gaussian_height
topo.patterns.basic.Gaussian.aspect_ratio = gaussian_width/gaussian_height
topo.patterns.basic.Gaussian.bounds = BoundingBox(points=((-0.5,-0.5),(0.5,0.5)))

# CEBHACKALERT: something isn't working about using e.g.
# PatternGeneratorParameter(default=X) in various places in the code
# so I've temporarily commented out this line.
# PatternGeneratorParameter.default=topo.patterns.basic.Gaussian()


# cortical sheet
ObermayerSOM.density = 25 #6
ObermayerSOM.learning_length = 30000

RandomArray.seed(500,500)
CFProjection.weights_generator = topo.patterns.random.UniformRandom()
CFProjection.weights_bounds = BoundingBox(points=((-1.0,-1.0),(1.0,1.0)))
CFProjection.response_fn = CFDotProduct()
CFProjection.learning_fn=HebbianSOMLF()

# Weights should be initialized to sum to unity: (Will this work?)
CFProjection.learning_fn.output_fn=DivisiveSumNormalize()

###########################################
# build simulation

s = Simulator()

Retina = GeneratorSheet(input_generator=topo.patterns.basic.Gaussian(),name='Retina')
V1 = ObermayerSOM(name='V1')
s.connect(Retina,V1,delay=0.5,connection_type=CFProjection,connection_params={'name':'RtoV1'})

s.run(0)
#s.run(30000)

# import profile,pstats
#
# p = profile.Profile()
# p.runctx('s.run(10)',locals(),globals())
