"""
SOM-based orientation map based on Obermayer et al., PNAS 87, pp. 8345-8349, 1990.

Contains a Retina (2D Gaussian generator) and a V1 (CFSOM) sheet.
Each V1 neuron receives input from the entire Retina.

Known differences from the reference simulation:

  - The reference simulation uses periodic boundary conditions, so the
    borders of our simulation will have edge effects not present in the
    original.

  - Currently only isotropic Gaussian neighborhood functions are supported.

  - Not tested. :-)

$Id$
"""
__version__='$Revision$'

import random
import RandomArray
from math import sqrt

from topo.sheets.generatorsheet import GeneratorSheet
from topo.base.patterngenerator import BoundingBox
from topo.base.connectionfield import CFProjection
from topo.responsefns.basic import CFDotProduct
from topo.base.parameter import Number,DynamicNumber
from topo.sheets.cfsom import CFSOM
import topo.patterns.random
import topo.patterns.basic
from topo.base.simulator import Simulator
from topo.learningfns.basic import HebbianSOMLF
from topo.patterns import PatternGeneratorParameter


class ObermayerSOM(CFSOM):
    """A variant of CFSOM that uses linear decay functions for alpha and radius."""

    alpha_f = Number(0.01)
    radius_f = Number(0.1)
    
    def alpha(self):
        return self.alpha_0 + (self.alpha_f-self.alpha_0)/self.learning_length*float(self.simulator.time())

    def radius(self):
	### JCALERT! Necessary to make the simulation match the 
	### new changes in learning rate handling (i.E. division by 900)
        return self.radius_0 + (self.alpha_f/900-self.alpha_0/900)/self.learning_length*float(self.simulator.time())



###########################################
# Set parameters

# input patterns
GeneratorSheet.period = 1.0
GeneratorSheet.density = 30

random.seed(1234)
topo.patterns.basic.Gaussian.x = DynamicNumber(lambda : random.uniform(-0.5,0.5),softbounds=(-1.0,1.0))
topo.patterns.basic.Gaussian.y = DynamicNumber(lambda : random.uniform(-0.5,0.5),softbounds=(-1.0,1.0))
topo.patterns.basic.Gaussian.orientation = DynamicNumber(lambda :random.uniform(-pi,pi),softbounds=(0,2*pi))

gaussian_width = 0.23/sqrt(2)
gaussian_height = 0.09/sqrt(2)
topo.patterns.basic.Gaussian.size  = gaussian_height
topo.patterns.basic.Gaussian.aspect_ratio = gaussian_width/gaussian_height
topo.patterns.basic.Gaussian.bounds = BoundingBox(points=((-0.5,-0.5),(0.5,0.5)))

# CEBHACKALERT: something isn't working about using e.g.
# PatternGeneratorParameter(default=X) in various places in the code
# so I've temporarily commented out this line.
# PatternGeneratorParameter.default=topo.patterns.basic.Gaussian()


# cortical sheet
ObermayerSOM.density = 25 #6
ObermayerSOM.learning_length = 30000
ObermayerSOM.radius_0 = (240.0/256.0)**2
radius_at_15000 = (60.0/256.0)**2 # Used until 15000 ; see set_radius_f below for after 15000
ObermayerSOM.radius_f = 30000/15000 * radius_at_15000 - ObermayerSOM.radius_0

### JCALERT! We multiply by 30: number of unit in the weight matrix.
### It has been tested for 25 density but should not change for 256...
ObermayerSOM.alpha_0  = 0.09*900
ObermayerSOM.alpha_f  = 0.02*900

RandomArray.seed(500,500)
CFProjection.weights_generator = topo.patterns.random.UniformRandom()
CFProjection.weights_bounds = BoundingBox(points=((-1.0,-1.0),(1.0,1.0)))
CFProjection.response_fn = CFDotProduct()
CFProjection.learning_fn=HebbianSOMLF()
# Weights should be initialized to sum to unity: (Will this work?)
#CFProjection.learning_fn.output_fn=DivisiveSumNormalize()

###########################################
# build simulation

s = Simulator()

Retina = GeneratorSheet(input_generator=topo.patterns.basic.Gaussian(),name='Retina')
V1 = ObermayerSOM(name='V1')
s.connect(Retina,V1,delay=0.5,connection_type=CFProjection,connection_params={'name':'RtoV1'})

def set_radius_f(val): V1.radius_f=val
s.schedule_action(15000, set_radius_f, (2.0/256.0)**2) # Used after 15000

s.run(1)
#s.run(30000)

# import profile,pstats
#
# p = profile.Profile()
# p.runctx('s.run(10)',locals(),globals())
