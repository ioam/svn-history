"""
Implementation of synaptic scaling model from T.J. Sullivan & V.R. de Sa,
"Homeostatic Synaptic Scaling in Self-Organizing Maps", Neural
Networks (2006), 19(6-7):734-43.

NOT YET TESTED.

Original version was a one-dimensional ring to eliminate edge effects.
This one is implemented as a thin two-dimensional area that includes
a row of units (which should be equivalent to a string topology).
Topographica does not yet include support for torus configurations, so
connecting the ends of the string is not yet possible.  In any case,
this configuration is suitable for generalizing to 2D just by changing
the bounding boxes to be square instead of a narrow rectangle.

$Id$
"""
__version__='$Revision$'


import numpy.oldnumeric.random_array as RandomArray
import fixedpoint
import copy
import numpy.oldnumeric as Numeric

from math import pi, sqrt
from fixedpoint import FixedPoint
from numpy.oldnumeric import sum,ones,exp

import topo.patterns.random
import topo.patterns.basic

from topo.base.arrayutils import clip_in_place,array_argmax
from topo.base.boundingregion import BoundingBox
from topo.base.cf import CFProjection
from topo.base.functionfamilies import OutputFn
from topo.base.parameterclasses import DynamicNumber, Number
from topo.learningfns.basic import Hebbian
from topo.learningfns.projfns import HomeoSynaptic
from topo.learningfns.som import CFPLF_HebbianSOM
from topo.misc.numbergenerators import UniformRandom
from topo.outputfns.homeostatic import PiecewiseLinear_debug2
from topo.patterns.basic import Rectangle
from topo.sheets.cfsom import CFSOM
from topo.sheets.generatorsheet import GeneratorSheet
from topo.commands.basic import pattern_present


topo.sim.name = "sullivan_nn06.ty"


# JABALERT: Needs a better name.  Completely untested.  Should this be a SharedWeightCFProjection?
# If so, derive from LISSOM and set tsettle to 1
class Hacked_CFSOM(CFSOM):
    """
    Modified CFSOM that convolves the input projection's output with a
    set of lateral weights (a DoG by default) to produce the final
    activity values.
    """
    
    neighborhood_kernel_generator = PatternGeneratorParameter(
        default=topo.patterns.basic.Composite(
        generators=[topo.patterns.basic.Gaussian(size=0.25, aspect_ratio=1.0,output_fn=DivisiveNormalizeL1()),
                    topo.patterns.basic.Gaussian(size=0.50, aspect_ratio=1.0,output_fn=DivisiveNormalizeL1())],
        operator=numpy.subtract),
        doc="Function to set up the lateral weight patterns")

    def __init__(self,**params):
        super(Hacked_CFSOM,self).__init__(**params)

        neighborhoods=array(activity.shape)
        rows,cols = activity.shape
        bb = BoundingBox(points=((0,0), (rows,cols))) # Check if bb is upper exclusive
        for wr in enumerate(rows):
            for wc in enumerate(cols):
                neighborhoods[wr,wc]=self.neighborhood_kernel_generator(bounds=bb,xdensity=1,ydensity=1,x=wc,y=wr)


    def activate(self):
        # Only supports one input projection
        assert(len(self.in_connections)==1)
        
        # Apply lateral weights to the proj.activity
        self.activity *= 0.0
        self.activity += matrixmultiply(neighborhoods,proj.activity)
        
        if self.apply_output_fn:
            self.output_fn(self.activity)

        self.send_output(src_port='Activity',data=self.activity)




#weight initialization, response 
RandomArray.seed(500,500)
CFProjection.weights_generator=topo.patterns.random.UniformRandom()


# Input pattern
input_pattern = topo.patterns.basic.Gaussian(
			scale=1, size=0.1, aspect_ratio=1.0,
			x=DynamicNumber(UniformRandom(lbound=-0.5,ubound=0.5,seed=12)),
			y=0,orientation=0)
		
	
  	  
# Sheets, connections, and their parameters


topo.sim['Retina'] = GeneratorSheet(input_generator=input_pattern,
                                    period=1.0,phase=0.05,nominal_density=150,
                                    nominal_bounds=BoundingBox(points=((-0.5,-0.5/150.0),(0.5,0.5/150.0))))



# Note that the learning rates from the original paper must be scaled
# by the number of units in a typical ConnectionField, i.e. 150 in this case
topo.sim['V1'] = Hacked_CFSOM(nominal_density=locals().get('default_density',15),
                       radius_0=0.1,alpha_0=0.00083*150,learning_length=150000,
                       nominal_bounds=BoundingBox(points=((-0.5,-0.5/15.0),(0.5,0.5/15.0))),
                       output_fn=PiecewiseLinear_debug2())


topo.sim.connect('Retina','V1',delay=FixedPoint("0.10"),
                  connection_type=CFProjection,strength=1.0,name='Afferent',
                  nominal_bounds_template=BoundingBox(radius=1.0),
                  response_fn = CFPRF_DotProduct_opt(),
                  learning_fn=HomeoSynaptic(beta_n=0.00033,beta_c=0.000033))


##topo.sim.schedule_command(150000,'measure_topography()')
##uncomenting will print the firing rate of a central neuron
##topo.sim.schedule_command(150000,'vectorplot (topo.sim["V1"].projections()["Afferent"].learning_fn.ave_hist[0:150000])')

##uncomenting will print the sum of absolute weights of this neuron, to see if the weights change stabilises to something useful
#topo.sim.schedule_command(150000,'vectorplot (topo.sim["V1"].projections()["Afferent"].learning_fn.temp_hist[0:150000])')


def measure_topography():
    """
    Map the topographic organization by presenting rectangular inputs.

    Turns on each pixel one by one, keeping track of the maximally activated
    output node, and then plots and prints the result.
    """
    winners = []
    for i in xrange(0,150): # Need to handle sheet coordinates...
        pattern_present({'Retina':Rectangle(size=1.0/150.0,x=i/150.0-0.5+0.5/150)})
        #import topo ; topo.guimain.auto_refresh() # To visualize each pattern as it is drawn
        winners.append(array_argmax(topo.sim['V1'].activity))
    col = [c for r,c in winners]
    vectorplot(col[0:150])


