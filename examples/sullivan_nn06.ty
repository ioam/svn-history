"""
Implementation of synaptic scaling model from T.J. Sullivan & V.R. de Sa,
"Homeostatic Synaptic Scaling in Self-Organizing Maps", Neural
Networks (2006), 19(6-7):734-43.

NOT YET TESTED.

Original version was a one-dimensional ring to eliminate edge effects.
This one is implemented as a thin two-dimensional area that includes
a row of units (which should be equivalent to a string topology).
Topographica does not yet include support for torus configurations, so
connecting the ends of the string is not yet possible.  In any case,
this configuration is suitable for generalizing to 2D just by changing
the bounding boxes to be square instead of a narrow rectangle.

$Id$
"""
__version__='$Revision$'


import fixedpoint
import copy

from math import pi, sqrt
from fixedpoint import FixedPoint
from numpy import array
import numpy

import topo.patterns.random
import topo.patterns.basic

from topo.base.arrayutils import clip_in_place,array_argmax
from topo.base.boundingregion import BoundingBox
from topo.base.cf import CFSheet 
from topo.projections.basic import CFProjection, SharedWeightCFProjection
from topo.base.functionfamilies import OutputFn
from topo.base.parameterclasses import DynamicNumber, Number
from topo.base.patterngenerator import PatternGeneratorParameter
from topo.learningfns.basic import Hebbian
from topo.learningfns.projfns import HomeoSynaptic
from topo.learningfns.som import CFPLF_HebbianSOM
from topo.misc.numbergenerators import UniformRandom
from topo.outputfns.basic import PiecewiseLinear
from topo.outputfns.basic import DivisiveNormalizeL1
from topo.patterns.basic import Rectangle
from topo.sheets.cfsom import CFSOM
from topo.sheets.generatorsheet import GeneratorSheet
from topo.commands.basic import pattern_present
from topo.responsefns.optimized import CFPRF_DotProduct_opt


### JABHACKALERT: Missing the lateral projection; should be
### a SharedWeightCFProjection


#weight initialization, response 
numpy.random.seed((500,500))
CFProjection.weights_generator=topo.patterns.random.UniformRandom()


# Input pattern
input_pattern = topo.patterns.basic.Gaussian(
			scale=1, size=0.1, aspect_ratio=1.0,
			x=DynamicNumber(UniformRandom(lbound=-0.5,ubound=0.5,seed=12)),
			y=0,orientation=0)
		
	
  	  
# Sheets, connections, and their parameters


topo.sim['Retina'] = GeneratorSheet(input_generator=input_pattern,
                                    period=1.0,phase=0.05,nominal_density=150,
                                    nominal_bounds=BoundingBox(points=((-0.5,-0.5/150.0),(0.5,0.5/150.0))))



# Note that the learning rates from the original paper must be scaled
# by the number of units in a typical ConnectionField, i.e. 150 in this case
topo.sim['V1'] = CFSOM(nominal_density=locals().get('default_density',15),
                       radius_0=0.1,alpha_0=0.00083*150,learning_length=150000,
                       nominal_bounds=BoundingBox(points=((-0.5,-0.5/15.0),(0.5,0.5/15.0))),
                       output_fn=PiecewiseLinear())


topo.sim.connect('Retina','V1',delay=FixedPoint("0.10"),
                  connection_type=CFProjection,strength=1.0,name='Afferent',
                  nominal_bounds_template=BoundingBox(radius=1.0),
                  response_fn = CFPRF_DotProduct_opt(),
                  learning_fn=HomeoSynaptic(beta_n=0.00033,beta_c=0.000033))


##topo.sim.schedule_command(150000,'measure_topography()')
##uncomenting will print the firing rate of a central neuron
##topo.sim.schedule_command(150000,'vectorplot (topo.sim["V1"].projections()["Afferent"].learning_fn.ave_hist[0:150000])')

##uncomenting will print the sum of absolute weights of this neuron, to see if the weights change stabilises to something useful
#topo.sim.schedule_command(150000,'vectorplot (topo.sim["V1"].projections()["Afferent"].learning_fn.temp_hist[0:150000])')


def measure_topography():
    """
    Map the topographic organization by presenting rectangular inputs.

    Turns on each pixel one by one, keeping track of the maximally activated
    output node, and then plots and prints the result.
    """
    winners = []
    for i in xrange(0,150): # Need to handle sheet coordinates...
        pattern_present({'Retina':Rectangle(size=1.0/150.0,x=i/150.0-0.5+0.5/150)})
        #import topo ; topo.guimain.auto_refresh() # To visualize each pattern as it is drawn
        winners.append(array_argmax(topo.sim['V1'].activity))
    col = [c for r,c in winners]
    vectorplot(col[0:150])


