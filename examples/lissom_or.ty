"""
Example of a LISSOM-based orientation map.

$Id$
"""
__version__='$Revision$'

import random
import RandomArray
import fixedpoint

from math import pi, sqrt
### JCALERT: Unused parameter
#from itertools import chain
from fixedpoint import FixedPoint

from topo.sheets.lissom import LISSOM
from topo.sheets.generatorsheet import GeneratorSheet
from topo.projections.basic import CFProjection
from topo.responsefns.basic import CFDotProduct
import topo.patterns.basic
import topo.patterns.random
from topo.base.sheet import BoundingBox
from topo.base.parameter import DynamicNumber
from topo.learningfns.optimized import DivisiveHebbian
from topo.patterns import PatternGeneratorParameter

###########################################
# Set parameters

input_bounds = BoundingBox(points=((-0.6791666666666667,-0.6791666666666667),
				   ( 0.6791666666666667, 0.6791666666666667)))

GeneratorSheet.density = 24.0 
GeneratorSheet.period = 1
GeneratorSheet.bounds = input_bounds


random.seed(1234)
topo.patterns.basic.Gaussian.scale = 1.0    
topo.patterns.basic.Gaussian.x = DynamicNumber(lambda : random.uniform(-0.5,0.5),softbounds=(-1.0,1.0))
topo.patterns.basic.Gaussian.y = DynamicNumber(lambda : random.uniform(-0.5,0.5),softbounds=(-1.0,1.0))
topo.patterns.basic.Gaussian.orientation = DynamicNumber(lambda :random.uniform(-pi,pi),softbounds=(0,2*pi))

# Corrects for differences between C++ and Topographica definition of Gaussian.
topo.patterns.basic.Gaussian.size = 0.06625/sqrt(2)  
topo.patterns.basic.Gaussian.aspect_ratio = 4.0      
topo.patterns.basic.Gaussian.bounds = input_bounds

# LISSOM parameters
LISSOM.density = 48.0    #BaseN

# Connection parameters

afferent_weight_bounds   = BoundingBox(points=((-0.22083333333333333,-0.22083333333333333),(0.22083333333333333,0.22083333333333333)))
excitatory_weight_bounds = BoundingBox(points=((-0.1,-0.1),(0.1,0.1)))
inhibitory_weight_bounds = BoundingBox(points=((-11.0/48.0,-11.0/48.0),(11.0/48.0,11.0/48.0)))


# Specify weight initialization
RandomArray.seed(500,500)
CFProjection.weights_generator = topo.patterns.random.UniformRandom()

# Specify the response function
# inlinec.optimized should make this unnecessary.
CFProjection.response_fn=CFDotProduct()

# Specify learning function
CFProjection.learning_fn=DivisiveHebbian()

###########################################
# build simulation

s = topo.base.simulator.Simulator()


Retina = GeneratorSheet(input_generator=topo.patterns.basic.Gaussian(),
                        name='Retina')
V1 = LISSOM(name='V1')


input_learning_rate = 1.2739676041295835
s.connect(Retina,V1, delay = FixedPoint("0.05"),
          connection_type=CFProjection,
          connection_params = dict(strength = 1.0, name='Afferent0',
                                   weights_bounds = afferent_weight_bounds,
                                   learning_rate=input_learning_rate))  


### JCALERT: Decide between both.
#exc_learning_rate = 2.6736328125000002
exc_learning_rate = 0.002*81*19.5*19.5/4.8/4.8
s.connect(V1,V1, delay = FixedPoint("0.05"), dest_port="exc",
          connection_type=CFProjection,
          connection_params = dict(strength = 0.9, name='LateralExcitatory',
                                   weights_bounds = excitatory_weight_bounds,
                                   learning_rate=exc_learning_rate))             

inh_learning_rate = 2.4660253099173555
s.connect(V1,V1, delay = FixedPoint("0.05"), dest_port="inh",
          connection_type=CFProjection,
          connection_params = dict(strength = -0.9, name='LateralInhibitory',
                                   weights_bounds = inhibitory_weight_bounds,
                                   learning_rate=inh_learning_rate))         


s.schedule_action(200, V1.projections()['LateralExcitatory'].change_bounds, BoundingBox(points=((-0.06,-0.06),(0.06,0.06))))
s.schedule_action(500, V1.projections()['LateralExcitatory'].change_bounds, BoundingBox(points=((-0.042,-0.042),(0.042,0.042))))
s.schedule_action(1000,V1.projections()['LateralExcitatory'].change_bounds, BoundingBox(points=((-0.0336,-0.0336),(0.0336,0.0336))))
s.schedule_action(2000,V1.projections()['LateralExcitatory'].change_bounds, BoundingBox(points=((-1.0/48.0,-1.0/48.0),(1.0/48.0,1.0/48.0))))


# Schedule action requires a function, so we create a temporary one
def set_learning_rate(projection_name, rate):
    """Set the learning rate on the named projection of V1."""
    V1.projections()[projection_name].learning_rate=rate



s.schedule_action(  200, set_learning_rate, "LateralExcitatory", exc_learning_rate*25.0*7.0/(81.0*4.0))
s.schedule_action(  500, set_learning_rate, "LateralExcitatory", exc_learning_rate*25.0/(81.0*4.0))
s.schedule_action(  1000, set_learning_rate, "LateralExcitatory", exc_learning_rate/(9.0*2.0))


s.schedule_action(  500, set_learning_rate, "Afferent0", input_learning_rate*0.005/0.007)
s.schedule_action( 2000, set_learning_rate, "Afferent0", input_learning_rate*0.004/0.007)
s.schedule_action( 4000, set_learning_rate, "Afferent0", input_learning_rate*0.003/007)
s.schedule_action(20000, set_learning_rate, "Afferent0", input_learning_rate*0.0015/0.007)


def set_deltabeta(x,y):
    """Set the threshold function limits on V1."""
    V1.output_fn.lower_bound=x
    V1.output_fn.upper_bound=y

s.schedule_action(  200, set_deltabeta, 0.11, 0.66)
s.schedule_action(  500, set_deltabeta, 0.12, 0.67)
s.schedule_action( 1000, set_deltabeta, 0.15, 0.68)
s.schedule_action( 2000, set_deltabeta, 0.18, 0.70)
s.schedule_action( 3000, set_deltabeta, 0.20, 0.73)
s.schedule_action( 4000, set_deltabeta, 0.20, 0.76)
s.schedule_action( 5000, set_deltabeta, 0.21, 0.79)
s.schedule_action( 6500, set_deltabeta, 0.22, 0.82)
s.schedule_action( 8000, set_deltabeta, 0.23, 0.85)
s.schedule_action(20000, set_deltabeta, 0.24, 0.88)

# can either pass a number or FixedPoint object to s.run()
s.run(1)
#s.run(FixedPoint(1))
