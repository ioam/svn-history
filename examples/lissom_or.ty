"""
Example of a LISSOM-based orientation map.

$Id$
"""
__version__='$Revision$'

import random
import RandomArray
import fixedpoint

from math import pi, sqrt
from fixedpoint import FixedPoint

import topo.patterns.basic
import topo.patterns.random

from topo.sheets.lissom import LISSOM
from topo.sheets.generatorsheet import GeneratorSheet
from topo.projections.basic import CFProjection
from topo.responsefns.optimized import CFDotProduct
from topo.base.sheet import BoundingBox
from topo.base.parameter import DynamicNumber
from topo.learningfns.optimized import DivisiveHebbian
from topo.patterns import PatternGeneratorParameter

###########################################
# Set parameters

# CEBHACKALERT: ##C lines to replace nearby equivalents
# when code verified with circular connection fields.
input_bounds = BoundingBox(points=((-0.6792,-0.6792),
          			   ( 0.6792, 0.6792))) 

##C input_bounds = BoundingBox(points=((-0.7917,-0.7917),
##C   				       ( 0.7917, 0.7917))) 

GeneratorSheet.density = 24.0 
GeneratorSheet.period = 1
GeneratorSheet.bounds = input_bounds

random.seed(1234)
topo.patterns.basic.Gaussian.scale = 1.0    
topo.patterns.basic.Gaussian.x = DynamicNumber(lambda : random.uniform(-0.5,0.5),softbounds=(-1.0,1.0))
topo.patterns.basic.Gaussian.y = DynamicNumber(lambda : random.uniform(-0.5,0.5),softbounds=(-1.0,1.0))
topo.patterns.basic.Gaussian.orientation = DynamicNumber(lambda :random.uniform(-pi,pi),softbounds=(0,2*pi))

topo.patterns.basic.Gaussian.size = 2*0.0468      
topo.patterns.basic.Gaussian.aspect_ratio = 4.0      
topo.patterns.basic.Gaussian.bounds = input_bounds

# LISSOM parameters
LISSOM.density = 48.0    

# Connection parameters

afferent_weight_bounds   = BoundingBox(points=((-0.22,-0.22),(0.22,0.22)))
##C afferent_weight_bounds   = BoundingBox(points=((-0.25,-0.25),(0.25,0.25)))
excitatory_weight_bounds = BoundingBox(points=((-0.10,-0.10),(0.10,0.10)))
inhibitory_weight_bounds = BoundingBox(points=((-0.23,-0.23),(0.23,0.23))) 


# Specify weight initialization, response function, and learning function
RandomArray.seed(500,500)
CFProjection.weights_generator = topo.patterns.random.UniformRandom()
##C CFProjection.weights_shape = topo.patterns.basic.Disk()
CFProjection.response_fn=CFDotProduct()
CFProjection.learning_fn=DivisiveHebbian()


###########################################
# build simulation

s = topo.base.simulator.Simulator()
Retina = GeneratorSheet(input_generator=topo.patterns.basic.Gaussian(), name='Retina')
V1 = LISSOM(name='V1')

s.connect(Retina,V1, delay = FixedPoint("0.05"),
          connection_type=CFProjection,strength=1.0,name='Afferent0',
          weights_bounds=afferent_weight_bounds,learning_rate=1.274)

s.connect(V1,V1, delay = FixedPoint("0.05"), dest_port="exc",
          connection_type=CFProjection,strength = 0.9, name='LateralExcitatory',
          weights_bounds = excitatory_weight_bounds,learning_rate=2.674)
            
s.connect(V1,V1, delay = FixedPoint("0.05"), dest_port="inh",
          connection_type=CFProjection,strength = -0.9, name='LateralInhibitory',
          weights_bounds = inhibitory_weight_bounds,learning_rate=2.466)         


s.schedule_action(200, V1.projections()['LateralExcitatory'].change_bounds, BoundingBox(points=((-0.06,-0.06),(0.06,0.06))))
s.schedule_action(500, V1.projections()['LateralExcitatory'].change_bounds, BoundingBox(points=((-0.042,-0.042),(0.042,0.042))))
s.schedule_action(1000,V1.projections()['LateralExcitatory'].change_bounds, BoundingBox(points=((-0.0336,-0.0336),(0.0336,0.0336))))
s.schedule_action(2000,V1.projections()['LateralExcitatory'].change_bounds, BoundingBox(points=((-0.021,-0.021),(0.021,0.021))))


# Schedule action requires a function, so we create a temporary one
def set_learning_rate(projection_name, rate):
    """Set the learning rate on the named projection of V1."""
    V1.projections()[projection_name].learning_rate=rate


s.schedule_action(  200, set_learning_rate, "LateralExcitatory", 1.445)
s.schedule_action(  500, set_learning_rate, "LateralExcitatory", 0.205)
s.schedule_action( 1000, set_learning_rate, "LateralExcitatory", 0.149) 


s.schedule_action(  500, set_learning_rate, "Afferent0", 0.911)
s.schedule_action( 2000, set_learning_rate, "Afferent0", 0.729)
s.schedule_action( 4000, set_learning_rate, "Afferent0", 0.545)
s.schedule_action(20000, set_learning_rate, "Afferent0", 0.273)


def set_deltabeta(x,y):
    """Set the threshold function limits on V1."""
    V1.output_fn.lower_bound=x
    V1.output_fn.upper_bound=y

s.schedule_action(  200, set_deltabeta, 0.11, 0.66)
s.schedule_action(  500, set_deltabeta, 0.12, 0.67)
s.schedule_action( 1000, set_deltabeta, 0.15, 0.68)
s.schedule_action( 2000, set_deltabeta, 0.18, 0.70)
s.schedule_action( 3000, set_deltabeta, 0.20, 0.73)
s.schedule_action( 4000, set_deltabeta, 0.20, 0.76)
s.schedule_action( 5000, set_deltabeta, 0.21, 0.79)
s.schedule_action( 6500, set_deltabeta, 0.22, 0.82)
s.schedule_action( 8000, set_deltabeta, 0.23, 0.85)
s.schedule_action(20000, set_deltabeta, 0.24, 0.88)

s.run(0)
