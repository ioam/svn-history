"""
Example of a LISSOM-based orientation map.

This file is much more complex than necessary, because it is set up to
match the C++ version of the LISSOM simulator as closely as possible.
Most of the variables below are just temporary variables designed to
match those in the other simulator.  Eventually, this file will be
simplified to have only the variables needed for Topographica.

$Id$
"""
__version__='$Revision$'

# To use a faster but more complex implementation (using memory
# pointers to access data structures instead of the Python/C API),
# change all instances of "LISSOM" to "LISSOMPointer", and
# "KernelProjection" to "KernelPointerProjection" in this file.

import random
import fixedpoint
#import pdb # debugger

from math import pi, sqrt
from itertools import chain
from fixedpoint import FixedPoint

from topo.sheets.lissom import LISSOM
from topo.sheets.generatorsheet import GeneratorSheet
from topo.projections.kernelprojection import KernelProjection
from topo.patterns.basic import GaussianGenerator, ConstantGenerator
from topo.base.sheet import BoundingBox
from topo.base.parameter import DynamicNumber


###########################################
# Temporary variables designed to match the C++ version of LISSOM

BaseN=72.0
BaseRN=24.0
area_scale=1.0
num_eyes=1
rf_radius=BaseRN/5.0+0.5
inh_rad=max(2.0,(BaseN/4.0-1.5)+0.5)
exc_rad=max(2.0,(BaseN/10.0-0.5)+0.5)
default_afferent_size_scale=BaseN/BaseRN
gammaexc=0.9
gammainh=0.9
#min_exc_rad=max(1,BaseN/44+0.5)

rf_radius_scale=5.0/rf_radius
#retina_area_scale=(BaseRN*area_scale/24.0*rf_radius_scale)*(BaseRN*area_scale/24.0*rf_radius_scale)
#inputs_pereye=max(retina_area_scale,1)
#uncorrelation=0.0 
xsigma=6.0/rf_radius_scale
ysigma=1.5/rf_radius_scale

scale_input=1.0
retina_edge_buffer=0*(rf_radius+(BaseRN*area_scale/2))
RN=BaseRN*area_scale+2*retina_edge_buffer

acs=6.5*6.5/rf_radius/rf_radius
ecs=19.5*19.5/exc_rad/exc_rad
ics=47.5*47.5/inh_rad/inh_rad

alpha_input=0.007*acs
alpha_exc=0.002*ecs
alpha_inh=0.00025*ics


###########################################
# Set parameters

# Number of decimal places for simulator time
fixedpoint.DEFAULT_PRECISION=3

# input generation params
GeneratorSheet.density = RN
GeneratorSheet.period = 1

GaussianGenerator.scale = scale_input
GaussianGenerator.x = DynamicNumber(lambda : random.uniform(-0.5,0.5),softbounds=(-1.0,1.0))
GaussianGenerator.y = DynamicNumber(lambda : random.uniform(-0.5,0.5),softbounds=(-1.0,1.0))
GaussianGenerator.orientation = DynamicNumber(lambda :random.uniform(-pi,pi),softbounds=(0,2*pi))

# Corrects for differences between C++ and Topographica definition of Gaussian.
GaussianGenerator.width = xsigma/RN/sqrt(2)
GaussianGenerator.height = ysigma/RN/sqrt(2)
GaussianGenerator.bounds = BoundingBox(points=((-0.5,-0.5),(0.5,0.5)))


# LISSOM parameters
LISSOM.density = BaseN

# Connection parameters
afferent_weight_bounds   = BoundingBox(points=((-rf_radius/RN,-rf_radius/RN),(rf_radius/RN,rf_radius/RN)))
excitatory_weight_bounds = BoundingBox(points=((-exc_rad/BaseN,-exc_rad/BaseN),(exc_rad/BaseN,exc_rad/BaseN)))
inhibitory_weight_bounds = BoundingBox(points=((-inh_rad/BaseN,-inh_rad/BaseN),(inh_rad/BaseN,inh_rad/BaseN)))

# Specify weight initialization
#KernelProjection.weights_generator = UniformRandomGenerator(bounds=BoundingBox(points=((-0.1,-0.1),(0.1,0.1))))
#KernelProjection.weights_generator = ConstantGenerator()


###########################################
# build simulation

s = topo.base.simulator.Simulator()

Retina = GeneratorSheet(input_generator=GaussianGenerator(),name='Retina')
V1 = LISSOM(name='V1')

s.connect(Retina,V1, delay = FixedPoint("0.05"),
          connection_type=KernelProjection,
          connection_params = dict(strength = 1.0, name='Afferent0',
                                   weights_bounds = afferent_weight_bounds, normalize = True, learning_rate=alpha_input))


s.connect(V1,V1, delay = FixedPoint("0.05"), dest_port="exc",
          connection_type=KernelProjection,
          connection_params = dict(strength = gammaexc, name='LateralExcitatory',
                                   weights_bounds = excitatory_weight_bounds, normalize = True, learning_rate=alpha_exc))

s.connect(V1,V1, delay = FixedPoint("0.05"), dest_port="inh",
          connection_type=KernelProjection,
          connection_params = dict(strength = -gammainh, name='LateralInhibitory',
                                   weights_bounds = inhibitory_weight_bounds, normalize = True, learning_rate=alpha_inh))
        

s.schedule_action(200, V1.projections()['LateralExcitatory'].change_bounds, BoundingBox(points=((-exc_rad*0.6/BaseN,-exc_rad*0.6/BaseN),(exc_rad*0.6/BaseN,exc_rad*0.6/BaseN))))

s.schedule_action(500, V1.projections()['LateralExcitatory'].change_bounds, BoundingBox(points=((-exc_rad*0.42/BaseN,-exc_rad*0.42/BaseN),(exc_rad*0.42/BaseN,exc_rad*0.42/BaseN))))

s.schedule_action(1000,V1.projections()['LateralExcitatory'].change_bounds, BoundingBox(points=((-exc_rad*0.336/BaseN,-exc_rad*0.336/BaseN),(exc_rad*0.336/BaseN,exc_rad*0.336/BaseN))))

s.schedule_action(2000,V1.projections()['LateralExcitatory'].change_bounds, BoundingBox(points=((-2.0/BaseN,-2.0/BaseN),(2.0/BaseN,2.0/BaseN))))


# Schedule action requires a function, so we create a temporary one
def set_learning_rate(projection_name, rate):
    """Set the learning rate on the named projection of V1."""
    V1.projections()[projection_name].learning_rate=rate


s.schedule_action(  500, set_learning_rate, "LateralExcitatory", 0.001*ecs)
s.schedule_action(  500, set_learning_rate, "Afferent0", 0.005*acs)
s.schedule_action( 2000, set_learning_rate, "Afferent0", 0.004*acs)
s.schedule_action( 4000, set_learning_rate, "Afferent0", 0.003*acs)
s.schedule_action(20000, set_learning_rate, "Afferent0", 0.0015*acs)


def set_deltabeta(x,y):
    """Set the threshold function limits on V1."""
    V1.output_fn.lower_bound=x
    V1.output_fn.upper_bound=y

s.schedule_action(  200, set_deltabeta, 0.11, 0.66)
s.schedule_action(  500, set_deltabeta, 0.12, 0.67)
s.schedule_action( 1000, set_deltabeta, 0.15, 0.68)
s.schedule_action( 2000, set_deltabeta, 0.18, 0.70)
s.schedule_action( 3000, set_deltabeta, 0.20, 0.73)
s.schedule_action( 4000, set_deltabeta, 0.20, 0.76)
s.schedule_action( 5000, set_deltabeta, 0.21, 0.79)
s.schedule_action( 6500, set_deltabeta, 0.22, 0.82)
s.schedule_action( 8000, set_deltabeta, 0.23, 0.85)
s.schedule_action(20000, set_deltabeta, 0.24, 0.88)

# can either pass a number or FixedPoint object to s.run()
s.run(1)
#s.run(FixedPoint(1))


# Set up performance profiling
#import hotshot,hotshot.stats
#prof = hotshot.Profile("abc")
#prof.runctx('s.run(10000)',globals(),locals())
#prof.close()
#
#p = hotshot.stats.load("abc")
#p.strip_dirs().sort_stats('cumulative','time').print_stats()
#
#import profile,pstats
#profile.runctx('s.run(10000)',globals(),locals(),"abc")
#p = pstats.Stats('abc')
#p.strip_dirs().sort_stats('cumulative').print_stats()
