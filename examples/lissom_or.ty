"""
Example of a LISSOM-based orientation map (without ON/OFF channels).

Intended to be a close (but approximate) match to the orientation
mapsimulation from figure 6.4 (Reduced) of Miikkulainen, Bednar, Choe,
and Sirosh (2005), Computational Maps in the Visual Cortex, Springer,
except:

 - The default_density is smaller for practicality (142 in the book).
 - The matching is not yet perfect at different densities
 - The lateral inhibitory radius is 0.5 matrix units greater than in the 
   book, becauseTopographica enforces good circular-shaped CF outlines.
 - Input patterns are evaluated on the entire retina, instead of only up
   to bounds_multiplier=2.5 times the gaussian sigma in the book
 - Weight patterns are not smoothed around the edges, unlike
   smooth_circular_outlines=True and smooth_circular_radius_trim=-0.25
   used in the book
 - Initial weight patterns are all random within a gaussian envelope
   rather than random afferent and Gaussian sigma preset_sigma_exc=11.076
   preset_sigma_inh=71.76 lateral weights used in the book.
 - Inhibitory weight pruning is disabled (not pruning all weights below
   1e-5 as in the book)

$Id$
"""
__version__='$Revision$'


from math import pi, sqrt
import numpy

from topo import learningfn,numbergen,outputfn,pattern,projection,responsefn,sheet 

import topo.learningfn.optimized
import topo.learningfn.projfn 
import topo.outputfn.optimized 
import topo.pattern.random
import topo.responsefn.optimized 
import topo.sheet.lissom
import topo.sheet.optimized


num_inputs=2
input_type=pattern.Gaussian
inputs=[input_type(x=numbergen.UniformRandom(lbound=-0.75,ubound=0.75,seed=12+i),
                   y=numbergen.UniformRandom(lbound=-0.75,ubound=0.75,seed=34+i),
                   orientation=numbergen.UniformRandom(lbound=-pi,ubound=pi,seed=56+i),
                   size=0.088388, aspect_ratio=4.66667, scale=1.0,
                   bounds=sheet.BoundingBox(radius=0.8)) # JABALERT: What does this bounds do?
        for i in xrange(num_inputs)]

combined_inputs = pattern.SeparatedComposite(min_separation=2.2*0.27083,generators=inputs)
                                 
# Default for tutorial
pattern.Line.scale=0.7

# Specify weight initialization, response function, and learning function
projection.CFProjection.cf_shape=pattern.Disk(smoothing=0.0)
projection.CFProjection.weights_generator=pattern.Constant()
projection.CFProjection.response_fn=responsefn.optimized.CFPRF_DotProduct_opt()
projection.CFProjection.learning_fn=learningfn.optimized.CFPLF_Hebbian_opt()
projection.CFProjection.weights_output_fn=outputfn.optimized.CFPOF_DivisiveNormalizeL1_opt()


###########################################
# build simulation


topo.sim['Retina']=sheet.GeneratorSheet(nominal_density=locals().get('default_retina_density',24.0),
                                  input_generator=combined_inputs,
                                  period=1.0, phase=0.05,
                                  nominal_bounds=sheet.BoundingBox(radius=0.5+0.25))


topo.sim['V1'] = sheet.lissom.LISSOM(nominal_density=locals().get('default_density',48.0),tsettle=9)

topo.sim['V1'].output_fn.lower_bound=0.1
topo.sim['V1'].output_fn.upper_bound=0.65


topo.sim.connect('Retina','V1',delay=0.10,
                 connection_type=projection.CFProjection,strength=1.0,name='Afferent',
                 weights_generator=pattern.random.GaussianCloud(gaussian_size=2*0.27083),
                 nominal_bounds_template=sheet.BoundingBox(radius=0.27083),learning_rate=0.9590)

topo.sim.connect('V1','V1',delay=0.05,name='LateralExcitatory',
                 connection_type=projection.CFProjection,strength=0.9,
                 weights_generator=pattern.random.GaussianCloud(gaussian_size=2*0.10417),
                 nominal_bounds_template=sheet.BoundingBox(radius=0.10417),learning_rate=2.55528) 
            
topo.sim.connect('V1','V1',delay=0.05,name='LateralInhibitory',
                 connection_type=projection.CFProjection,strength=-0.9,
                 weights_generator=pattern.random.GaussianCloud(gaussian_size=2*0.22917),
                 nominal_bounds_template=sheet.BoundingBox(radius=0.22917),learning_rate=1.80873)  



### Actions scheduled to occur as the simulation proceeds.
topo.sim.startup_commands.append("import topo.sheet")

# Convenience variable: timescale (s_t)
st=1.0/num_inputs

### Lateral excitatory bounds changes
LE="topo.sim['V1'].projections()['LateralExcitatory']"

topo.sim.schedule_command(  200*st,LE+'.change_bounds(sheet.BoundingBox(radius=0.06250))')
topo.sim.schedule_command(  500*st,LE+'.change_bounds(sheet.BoundingBox(radius=0.04375))')
topo.sim.schedule_command( 1000*st,LE+'.change_bounds(sheet.BoundingBox(radius=0.03500))')
topo.sim.schedule_command( 2000*st,LE+'.change_bounds(sheet.BoundingBox(radius=0.02800))')
topo.sim.schedule_command( 3000*st,LE+'.change_bounds(sheet.BoundingBox(radius=0.02240))')
topo.sim.schedule_command( 4000*st,LE+'.change_bounds(sheet.BoundingBox(radius=0.01344))')
topo.sim.schedule_command( 5000*st,LE+'.change_bounds(sheet.BoundingBox(radius=0.00806))')
topo.sim.schedule_command( 6500*st,LE+'.change_bounds(sheet.BoundingBox(radius=0.00484))')
topo.sim.schedule_command( 8000*st,LE+'.change_bounds(sheet.BoundingBox(radius=0.00290))')
topo.sim.schedule_command(20000*st,LE+'.change_bounds(sheet.BoundingBox(radius=0.00174))')

### Lateral excitatory learning rate changes
topo.sim.schedule_command(  200*st,LE+'.learning_rate=0.12168*'+LE+'.n_units()')
topo.sim.schedule_command(  500*st,LE+'.learning_rate=0.06084*'+LE+'.n_units()')
topo.sim.schedule_command( 1000*st,LE+'.learning_rate=0.06084*'+LE+'.n_units()')
topo.sim.schedule_command( 2000*st,LE+'.learning_rate=0.06084*'+LE+'.n_units()')
topo.sim.schedule_command( 3000*st,LE+'.learning_rate=0.06084*'+LE+'.n_units()')
topo.sim.schedule_command( 4000*st,LE+'.learning_rate=0.06084*'+LE+'.n_units()')
topo.sim.schedule_command( 5000*st,LE+'.learning_rate=0.06084*'+LE+'.n_units()')
topo.sim.schedule_command( 6500*st,LE+'.learning_rate=0.06084*'+LE+'.n_units()')
topo.sim.schedule_command( 8000*st,LE+'.learning_rate=0.06084*'+LE+'.n_units()')
topo.sim.schedule_command(20000*st,LE+'.learning_rate=0.06084*'+LE+'.n_units()')


### Afferent learning rate changes
AFF="topo.sim['V1'].projections()['Afferent']"

topo.sim.schedule_command(  500*st,AFF+'.learning_rate=0.6850')
topo.sim.schedule_command( 2000*st,AFF+'.learning_rate=0.5480')
topo.sim.schedule_command( 4000*st,AFF+'.learning_rate=0.4110')
topo.sim.schedule_command(20000*st,AFF+'.learning_rate=0.2055')

### Schedule LISSOM output function threshold changes
OF="topo.sim['V1'].output_fn"

topo.sim.schedule_command(  200*st,OF+'.lower_bound=0.11;'+OF+'.upper_bound=0.66')
topo.sim.schedule_command(  500*st,OF+'.lower_bound=0.12;'+OF+'.upper_bound=0.67')
topo.sim.schedule_command( 1000*st,OF+'.lower_bound=0.15;'+OF+'.upper_bound=0.68')
topo.sim.schedule_command( 2000*st,OF+'.lower_bound=0.18;'+OF+'.upper_bound=0.70')
topo.sim.schedule_command( 3000*st,OF+'.lower_bound=0.20;'+OF+'.upper_bound=0.73')
topo.sim.schedule_command( 4000*st,OF+'.lower_bound=0.20;'+OF+'.upper_bound=0.76')
topo.sim.schedule_command( 5000*st,OF+'.lower_bound=0.21;'+OF+'.upper_bound=0.79')
topo.sim.schedule_command( 6500*st,OF+'.lower_bound=0.22;'+OF+'.upper_bound=0.82')
topo.sim.schedule_command( 8000*st,OF+'.lower_bound=0.23;'+OF+'.upper_bound=0.85')
topo.sim.schedule_command(20000*st,OF+'.lower_bound=0.24;'+OF+'.upper_bound=0.88')

#tsettle changes
topo.sim.schedule_command( 2000*st,"topo.sim['V1'].tsettle=10")
topo.sim.schedule_command( 5000*st,"topo.sim['V1'].tsettle=11")
topo.sim.schedule_command( 6500*st,"topo.sim['V1'].tsettle=12")
topo.sim.schedule_command( 8000*st,"topo.sim['V1'].tsettle=13")
