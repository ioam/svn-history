"""
LISSOM-based orientation map with ON/OFF channels using natural images training pattern & 
homeostatic intrinsic plasticity

$Id$
"""
__version__='$Revision$'

import RandomArray
import fixedpoint
import copy

from math import pi, sqrt
from fixedpoint import FixedPoint
from Numeric import sum,ones,exp

import topo.patterns.basic
import topo.patterns.random
import Numeric

from topo.sheets.lissom import LISSOM
from topo.sheets.generatorsheet import GeneratorSheet
from topo.projections.basic import CFProjection, SharedWeightCFProjection
from topo.responsefns.optimized import CFPRF_DotProduct_opt, CFPRF_SharedWeightDotProduct_opt
from topo.base.parameterclasses import DynamicNumber, Number
from topo.base.cf import CFSheet
from topo.base.boundingregion import BoundingBox
from topo.learningfns.optimized import CFPLF_Hebbian_opt
from topo.outputfns.optimized import CFPOF_DivisiveNormalizeL1_opt
from topo.outputfns.basic import PiecewiseLinear, DivisiveNormalizeL1
from topo.misc.numbergenerators import UniformRandom
from topo.base.functionfamilies import OutputFn
from topo.base.arrayutils import clip_in_place

from topo.patterns.image import edge_average
from os import listdir
from random import randrange, uniform
import Image as pImage
import ImageOps
from Numeric import array, Float, ravel
from topo.base.patterngenerator import PatternGenerator
from topo.base.parameterclasses import Filename, Number, Parameter, Enumeration
from topo.base.projection import OutputFnParameter
from topo.outputfns.basic import DivisiveNormalizeLinf,IdentityOF
from topo.patterns.basic import PatternSampler


topo.sim.name = "homeo_lissom_oo_or_image"

#input_pattern = topo.patterns.basic.Gaussian(
#          scale=1.0, size=2*0.0468, aspect_ratio=4.0,
#          x=DynamicNumber(UniformRandom(lbound=-0.5,ubound=0.5,seed=12)),
#          y=DynamicNumber(UniformRandom(lbound=-0.5,ubound=0.5,seed=34)),
#          orientation=DynamicNumber(UniformRandom(lbound=-pi,ubound=pi,seed=56)))


# -----------------------------------------------------------------------
# Present random sequence of images 
class ImageSeq(PatternGenerator):
    """
    Given a path where set of images are stored, 
    it  present each image as input pattern in random order

    """

    output_fn = OutputFnParameter(default=IdentityOF())
    
    aspect_ratio  = Number(default=1.0,bounds=(0.0,None),
        softbounds=(0.0,2.0),precedence=0.31,doc=
        "Ratio of width to height; size*aspect_ratio gives the width.")

    size  = Number(default=1.0,bounds=(0.0,None),softbounds=(0.0,2.0),
                   precedence=0.30,doc="Height of the image.")
       
    size_normalization = Enumeration(default='fit_shortest',
        available=['fit_shortest','fit_longest','stretch_to_fit','original'],
        precedence=0.95,doc=
        "How to scale the initial image size relative to the default area of 1.0.")

    whole_image_output_fn = OutputFnParameter(default=DivisiveNormalizeLinf(),
        precedence=0.96,doc=
        "Function applied to the whole, original image array (before any cropping).")

    # Path to directory where sequence of training images are stored
    imagepath = 'examples/images/'


    def __init__(self, **params):
        """
        """
        super(ImageSeq,self).__init__(**params)
	self.firstcall = True


    def __setup_pattern_sampler(self, imagepath, whole_image_output_fn):
        """
        """
	if self.firstcall:
	    self.firstcall = False
	    image_filenames = listdir (self.imagepath)
	    self.patterns = []
	    for fname in image_filenames:
	    	print fname
            	image = ImageOps.grayscale(pImage.open(self.imagepath + fname))
            	image_array = array(image.getdata(),Float)
            	image_array.shape = (image.size[::-1]) # getdata() returns transposed image?
            	self.patterns.append (PatternSampler(image_array,whole_image_output_fn,edge_average))

	    self.number_of_patterns = len(self.patterns)


    def function(self,**params):
        xdensity = params.get('xdensity', self.xdensity)
        ydensity = params.get('ydensity', self.ydensity)
        x        = params.get('pattern_x',self.pattern_x)
        y        = params.get('pattern_y',self.pattern_y)
        size_normalization = params.get('scaling',self.size_normalization)
        whole_image_output_fn = params.get('whole_image_output_fn',self.whole_image_output_fn)

        height = params.get('size',self.size)
        width = (params.get('aspect_ratio',self.aspect_ratio))*height
	
	#imagepath = params.get('imagepath', self.imagepath)

        self.__setup_pattern_sampler(self.imagepath,whole_image_output_fn)
	
	self.x = uniform (-5.5,5.5)
	self.y = uniform (-5.5,5.5)
	index = randrange(0,self.number_of_patterns)
	print index, ' - ', self.x, ' - ', self.y
	return self.patterns[index](x,y,float(xdensity),float(ydensity),size_normalization,float(width),float(height))



input_pattern = ImageSeq(scale=1.1, aspect_ratio=1.0, size_normalization='original', size=2.5)

                                 
# Specify weight initialization, response function, and learning function
RandomArray.seed(500,500)
CFProjection.weights_generator=topo.patterns.random.UniformRandom()
CFProjection.weights_shape=topo.patterns.basic.Disk(smoothing=0.0)
CFProjection.response_fn=CFPRF_DotProduct_opt()
CFProjection.learning_fn=CFPLF_Hebbian_opt()
CFProjection.weights_output_fn=CFPOF_DivisiveNormalizeL1_opt()
SharedWeightCFProjection.response_fn=CFPRF_SharedWeightDotProduct_opt()

SharedWeightCFProjection.weights_output_fn.single_cf_fn=DivisiveNormalizeL1()


class HomeostaticMaxEnt(OutputFn):
    """
    Implementation of intrinsic excitability equations from Triesch, ICANN 2005, LNCS 3696 pp. 65-70.
    """
    lstep = Number(default=8,doc="")
    a_init = Number(default=13,doc="Multiplicative parameter controlling the exponential.")
    b_init = Number(default=-3,doc="Additive parameter controlling the exponential.")
    eta = Number(default=0.0002,doc="Learning rate for homeostatic plasticity.")
    mu = Number(default=0.05,doc="Average firing rate target.")

    def __init__(self,**params):
        super(HomeostaticMaxEnt,self).__init__(**params)

	self.first_call = True
	self.y_avg_count = 0 # Not required for the algorithm, but useful for debugging
	self.n_step = 0
	self.beta = 0.0003
	self.ncall = 0

    def __call__(self,x):
	
	if self.first_call:
	    self.first_call = False
	    self.a = Numeric.ones(x.shape, x.typecode()) * self.a_init
	    self.b = Numeric.ones(x.shape, x.typecode()) * self.b_init
	    self.y_avg = Numeric.zeros(x.shape, x.typecode())

	    self.x_avg = zeros(x.shape,x.typecode())
	    self.x_hist = []

	# Apply sigmoid function to x, resulting in what Triesch calls y
        x_orig = copy.copy(x)
        x *= 0.0
	x += 1.0 / (1.0 + exp(-(self.a*x_orig + self.b)))

	self.n_step += 1
	
	if self.n_step == self.lstep:
	    self.n_step = 0
	
	    # Compute average of all previous y (firing rate), for debugging
	    self.y_avg = (self.y_avg * self.y_avg_count + x) / (self.y_avg_count+1)
	    self.y_avg_count += 1

	    if self.ncall <= 500:
	        self.x_avg = ((self.x_avg*self.ncall) + x) / (self.ncall+1)
	        self.ncall += 1
	    else:
	        self.x_avg = self.beta*x + (1.0-self.beta)*self.x_avg	        

	    self.x_hist.append (self.x_avg)
	    
	    print self.x_avg[23][23], ' - ', self.x_avg[12][12], ' - ', self.x_avg[0][0], self.x_avg[5][5]


	# Update a and b
	self.a += self.eta * (1.0/self.a + x_orig - (2.0 + 1.0/self.mu)*x_orig*x + x_orig*x*x/self.mu)
	self.b += self.eta * (1.0 - (2.0 + 1.0/self.mu)*x + x*x/self.mu)



class TestFn(OutputFn):
    """ 
    Piecewise-linear output function with lower and upper thresholds
    as constructor parameters.
    """
    lower_bound = Number(default=0.0,softbounds=(0.0,1.0))
    upper_bound = Number(default=1.0,softbounds=(0.0,1.0))
    learn_step = Number(default=8,doc="Number of step before learning take place")

    def __init__(self,**params):
        super(TestFn,self).__init__(**params)

	self.first_call = True
	self.n_step = 0
	self.beta = 0.0003
	self.ncall = 0

    def __call__(self,x):

        fact = 1.0/(self.upper_bound-self.lower_bound)        
        x -= self.lower_bound
        x *= fact
        clip_in_place(x,0.0,1.0)

	if self.first_call:
	    self.first_call = False
	    #self.x_avg = self.beta * copy.copy(x)
	    #self.x_avg[12][12] = 0.01
	    self.x_avg = zeros(x.shape,x.typecode())
	    self.x_hist = []

	if self.ncall <= 500:
	    self.x_avg = ((self.x_avg*self.ncall) + x) / (self.ncall+1)
	    self.ncall += 1
	else:	    
	    self.x_avg = self.beta*x + (1.0-self.beta)*self.x_avg


	self.n_step += 1
	if self.n_step == self.learn_step:

	    self.n_step = 0
	    #self.x_hist.append (self.x_avg)

	    print self.x_avg[23][23], ' ', self.x_avg[11][11], ' ', self.x_avg[0][0], ' ', self.x_avg[47][47]


###########################################
# build simulation

topo.sim['Retina']=GeneratorSheet(nominal_density=48.0,
                                  input_generator=input_pattern,
                                  period=1.0, phase=0.05,
                                  nominal_bounds=BoundingBox(radius=0.5+0.25+0.375))

topo.sim['LGNOn']=CFSheet(nominal_density=24.0,
                          nominal_bounds=BoundingBox(radius=0.5+0.25),
                          output_fn=PiecewiseLinear(lower_bound=0.0,upper_bound=1.0),
                          measure_maps=False)

topo.sim['LGNOff']=CFSheet(nominal_density=24.0,
                           nominal_bounds=BoundingBox(radius=0.5+0.25),
                           output_fn=PiecewiseLinear(lower_bound=0.0,upper_bound=1.0),
                           measure_maps=False)

topo.sim['V1'] = LISSOM(nominal_density=locals().get('default_density',48.0),
                        nominal_bounds=BoundingBox(radius=0.5), output_fn=HomeostaticMaxEnt())

#output_fn=TestFn())

#thr = 0.007
#topo.sim['V1'].output_fn.lower_bound=0.083-thr
#topo.sim['V1'].output_fn.upper_bound=0.633-thr


# LGN ON channel
topo.sim.connect('Retina','LGNOn',delay=FixedPoint("0.05"),
                  connection_type=SharedWeightCFProjection,strength=4.7,
                  nominal_bounds_template=BoundingBox(radius=0.375),name='Center',
                  weights_generator=topo.patterns.basic.Gaussian(size=0.0417,
                                                                 aspect_ratio=1))

topo.sim.connect('Retina','LGNOn',delay = FixedPoint("0.05"),
                  connection_type=SharedWeightCFProjection,strength=-4.7,
                  name='Surround',nominal_bounds_template=BoundingBox(radius=0.375),
                  weights_generator=topo.patterns.basic.Gaussian(size=0.1667,
                                                                 aspect_ratio=1))

# LGN OFF channel
topo.sim.connect('Retina','LGNOff',delay = FixedPoint("0.05"),
                  connection_type=SharedWeightCFProjection,strength=-4.7,
                  name='Center',nominal_bounds_template=BoundingBox(radius=0.375),
                  weights_generator=topo.patterns.basic.Gaussian(size=0.0417,
                                                                 aspect_ratio=1))

topo.sim.connect('Retina','LGNOff',delay = FixedPoint("0.05"),
                  connection_type=SharedWeightCFProjection,strength=4.7,
                  name='Surround',nominal_bounds_template=BoundingBox(radius=0.375),
                  weights_generator=topo.patterns.basic.Gaussian(size=0.1667,
                                                                 aspect_ratio=1))


topo.sim.connect('LGNOn','V1',delay=FixedPoint("0.05"),
                  connection_type=CFProjection,strength=0.5,name='LGNOnAfferent',
                  nominal_bounds_template=BoundingBox(radius=0.25),learning_rate=0.9590)

topo.sim.connect('LGNOff','V1',delay=FixedPoint("0.05"),
                  connection_type=CFProjection,strength=0.5,name='LGNOffAfferent',
                  nominal_bounds_template=BoundingBox(radius=0.25),learning_rate=0.9590)

'''
topo.sim.connect('V1','V1',delay=FixedPoint("0.05"),name='LateralExcitatory',
                  connection_type=CFProjection,strength=0.9,
                  nominal_bounds_template=BoundingBox(radius=0.10),learning_rate=3.2018) 
            
topo.sim.connect('V1','V1',delay=FixedPoint("0.05"),name='LateralInhibitory',
                  connection_type=CFProjection,strength=-1.3,
                  nominal_bounds_template=BoundingBox(radius=0.23),learning_rate=1.9626)  
'''

topo.sim.connect('V1','V1',delay=FixedPoint("0.05"),name='LateralExcitatory',
                  connection_type=CFProjection,strength=0.9,
                  nominal_bounds_template=BoundingBox(radius=0.10),learning_rate=3.2018) 
            
topo.sim.connect('V1','V1',delay=FixedPoint("0.05"),name='LateralInhibitory',
                  connection_type=CFProjection,strength=-1.75,
                  nominal_bounds_template=BoundingBox(radius=0.23),learning_rate=0.0081)  

topo.sim.schedule_command(500,'topo.sim["V1"].projections()["LateralInhibitory"].strength=-2.2; topo.sim["V1"].projections()["LateralInhibitory"].learning_rate=0.0162;')
topo.sim.schedule_command(1000,'topo.sim["V1"].projections()["LateralInhibitory"].strength=-2.6; topo.sim["V1"].projections()["LateralInhibitory"].learning_rate=0.0243;')
topo.sim.schedule_command(2500,'topo.sim["V1"].projections()["LateralInhibitory"].learning_rate=0.04054;')


### Actions scheduled to occur as the simulation proceeds.
#
# CEBHACKALERT: add missing scheduled actions from c++ lissom
# (i.e. ones relevant to all bounds and densities, not just for
#  the particular ones set in this file right now).

topo.sim.startup_commands.append("from topo.base.boundingregion import BoundingBox")

### Lateral excitatory bounds changes
topo.sim.schedule_command(200,'topo.sim["V1"].projections()["LateralExcitatory"].change_bounds(BoundingBox(radius=0.06))')
topo.sim.schedule_command(500,'topo.sim["V1"].projections()["LateralExcitatory"].change_bounds(BoundingBox(radius=0.042))')

### Lateral excitatory learning rate changes
topo.sim.schedule_command(200,'topo.sim["V1"].projections()["LateralExcitatory"].learning_rate=1.2213')
topo.sim.schedule_command(500,'topo.sim["V1"].projections()["LateralExcitatory"].learning_rate=0.3466')

### Afferent learning rate changes
topo.sim.schedule_command(  500,'topo.sim["V1"].projections()["LGNOnAfferent"].learning_rate=0.6850;topo.sim["V1"].projections()["LGNOffAfferent"].learning_rate=0.6850')
topo.sim.schedule_command( 2000,'topo.sim["V1"].projections()["LGNOnAfferent"].learning_rate=0.5480;topo.sim["V1"].projections()["LGNOffAfferent"].learning_rate=0.5480')
topo.sim.schedule_command( 4000,'topo.sim["V1"].projections()["LGNOnAfferent"].learning_rate=0.4110;topo.sim["V1"].projections()["LGNOffAfferent"].learning_rate=0.4110')
topo.sim.schedule_command(20000,'topo.sim["V1"].projections()["LGNOnAfferent"].learning_rate=0.2055;topo.sim["V1"].projections()["LGNOffAfferent"].learning_rate=0.2055')

### LISSOM output function bounds changes
'''
topo.sim.schedule_command(  200,'topo.sim["V1"].output_fn.lower_bound=0.093-thr;topo.sim["V1"].output_fn.upper_bound=0.643-thr')
topo.sim.schedule_command(  500,'topo.sim["V1"].output_fn.lower_bound=0.103-thr;topo.sim["V1"].output_fn.upper_bound=0.643-thr')
topo.sim.schedule_command( 1000,'topo.sim["V1"].output_fn.lower_bound=0.133-thr;topo.sim["V1"].output_fn.upper_bound=0.663-thr')
topo.sim.schedule_command( 2000,'topo.sim["V1"].output_fn.lower_bound=0.163-thr;topo.sim["V1"].output_fn.upper_bound=0.683-thr')
topo.sim.schedule_command( 3000,'topo.sim["V1"].output_fn.lower_bound=0.183-thr;topo.sim["V1"].output_fn.upper_bound=0.713-thr')
topo.sim.schedule_command( 4000,'topo.sim["V1"].output_fn.lower_bound=0.183-thr;topo.sim["V1"].output_fn.upper_bound=0.743-thr')
topo.sim.schedule_command( 5000,'topo.sim["V1"].output_fn.lower_bound=0.193-thr;topo.sim["V1"].output_fn.upper_bound=0.773-thr')
topo.sim.schedule_command( 6500,'topo.sim["V1"].output_fn.lower_bound=0.203-thr;topo.sim["V1"].output_fn.upper_bound=0.803-thr')
topo.sim.schedule_command( 8000,'topo.sim["V1"].output_fn.lower_bound=0.213-thr;topo.sim["V1"].output_fn.upper_bound=0.833-thr')
topo.sim.schedule_command(20000,'topo.sim["V1"].output_fn.lower_bound=0.223-thr;topo.sim["V1"].output_fn.upper_bound=0.863-thr')
'''

# default locations for model editor
topo.sim['V1'].gui_x=306.0;      topo.sim['V1'].gui_y=225.0
topo.sim['LGNOn'].gui_x=432.0;   topo.sim['LGNOn'].gui_y=345.0
topo.sim['LGNOff'].gui_x=150.0;  topo.sim['LGNOff'].gui_y=345.0
topo.sim['Retina'].gui_x=279.0;  topo.sim['Retina'].gui_y=500.0



# Uncomment to allow profiling
## import hotshot,hotshot.stats
## prof = hotshot.Profile("abc")
## prof.runctx('topo.sim.run(199)',globals(),locals())
## prof.close()
## p = hotshot.stats.load("abc")
## p.strip_dirs().sort_stats('cumulative','time').print_stats()
