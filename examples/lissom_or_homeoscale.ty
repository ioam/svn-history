"""
 LISSOM-based orientation map (without ON/OFF channels) with homeostatic synaptic plasticity

"""
__version__='$Revision$'

import RandomArray
import fixedpoint
import copy

from math import pi, sqrt
from fixedpoint import FixedPoint
from Numeric import sum,ones,exp
import Numeric

import topo.patterns.basic
import topo.patterns.random

from topo.sheets.lissom import LISSOM
from topo.sheets.generatorsheet import GeneratorSheet
from topo.projections.basic import CFProjection
from topo.responsefns.optimized import CFPRF_DotProduct_opt
from topo.base.parameterclasses import DynamicNumber, Number
from topo.base.cf import CFSheet, CFPOF_Plugin
from topo.base.boundingregion import BoundingBox
from topo.learningfns.optimized import CFPLF_Hebbian_opt
from topo.outputfns.optimized import CFPOF_DivisiveNormalizeL1_opt
from topo.outputfns.basic import PiecewiseLinear, DivisiveNormalizeL1
from topo.misc.numbergenerators import UniformRandom
from topo.base.functionfamilies import OutputFn
from topo.base.arrayutils import clip_in_place
from topo.patterns.basic import Disk
from topo.outputfns.homeostatic import PiecewiseLinear_debug

from topo.base.cf import CFPLearningFn,LearningFnParameter
from topo.base.cf import CFPLF_Identity,CFPLF_Plugin
from topo.learningfns.basic import Hebbian
from topo.base.functionfamilies import LearningFn

topo.sim.name = "lissom_or_homeoscale"

input_pattern = topo.patterns.basic.Gaussian(
          scale=1.0, size=2*0.0468, aspect_ratio=4.0,
          x=DynamicNumber(UniformRandom(lbound=-0.6,ubound=0.6,seed=12)),
          y=DynamicNumber(UniformRandom(lbound=-0.6,ubound=0.6,seed=34)),
          orientation=DynamicNumber(UniformRandom(lbound=-pi,ubound=pi,seed=56)))

#input_pattern = Disk(scale=1.0,size = 1.0, aspect_ratio=1.0,
#    x=DynamicNumber(UniformRandom(lbound=-0.5,ubound=0.5,seed=20)),
#    y=DynamicNumber(UniformRandom(lbound=-0.5,ubound=0.5,seed=54)),
#    orientation=DynamicNumber(UniformRandom(lbound=-pi,ubound=pi,seed=56)))
                                

# Homeostatic Synaptic Scaling - Sullivan & de sa
class HomeoSynaptic(CFPLearningFn):
    """
    Implementation of Homeostatic Synaptic Scaling
    Sullivan & de Sa, "Homeostatic Synaptic Scaling in Self-Organizing Maps"

    Does not requires some form of output_fn normalization for stability.
    """
    single_cf_fn = LearningFnParameter(default=Hebbian(), doc="Learning Fn that will be applied to each CF individually")
    beta_n = Number(default=0.01,bounds=(0,None),doc="homeostatic learning rate")
    beta_c = Number(default=0.005,bounds=(0,None),doc="time window over which the neuron's firing rate is averaged")
    activity_target = Number(default=0.03,bounds=(0,None),doc="Target average activity") 
    
    def __init__(self,**params):
        super(HomeoSynaptic,self).__init__(**params)
	self.temp_hist = []
   
    def __call__(self, cfs, input_activity, output_activity, learning_rate, **params):
	"""
        Update the value of the given weights matrix based on the
        input_activity matrix (of the same size as the weights matrix)
        and the response of this unit (the unit_activity), governed by
        a per-connection learning rate.
	"""
        
        if not hasattr(self,'averages'):
            #self.averages = ones(output_activity.shape,Float) * 0.05
	    self.averages = topo.sim['V1'].output_fn.x_avg
	    print self.averages[23][23], ' ', self.averages[11][11]

	    #print cfs[23][23].weights

	    # normalize initial weights to 1.0
            rows,cols = output_activity.shape
            for r in xrange(rows):
                for c in xrange(cols):
                    cf = cfs[r][c]

	            current_norm_value = 1.0*Numeric.sum(abs(cf.weights.flat))
		    if current_norm_value != 0:
            	    	factor = (1.0/current_norm_value)
            	    	cf.weights *= factor

	    #print "--", cfs[23][23].weights


        # compute recent average of output activity
        self.averages = self.beta_c * output_activity + (1.0-self.beta_c) * self.averages
        activity_norm = 1.0 + self.beta_n * ((self.averages - self.activity_target)/self.activity_target)

        rows,cols = output_activity.shape
	single_connection_learning_rate = self.constant_sum_connection_rate(cfs,learning_rate)
	
       
        # avoid evaluating these references each time in the loop
        single_cf_fn = self.single_cf_fn
	for r in xrange(rows):
            for c in xrange(cols):
                cf = cfs[r][c]

                single_cf_fn(cf.get_input_matrix(input_activity),
                             output_activity[r,c], cf.weights, single_connection_learning_rate)

		# homeostatic normalization
                cf.weights /= activity_norm[r][c]

                # CEBHACKALERT: see ConnectionField.__init__()
                cf.weights *= cf.mask

	print self.averages[23][23], ':', activity_norm[23][23], '   ', self.averages[11][11], ':', activity_norm[11][11]
	print Numeric.sum(abs(cfs[23][23].weights.flat)), '  ', Numeric.sum(abs(cfs[11][11].weights.flat))
	
	# debug only
	self.temp_hist.append (Numeric.sum(abs(cfs[23][23].weights.flat)))



class InitFn(CFPLearningFn):
    
    def __init__(self,**params):
        super(InitFn,self).__init__(**params)
	self.FirstCall = True
   
    def __call__(self, cfs, input_activity, output_activity, learning_rate, **params):
        
        if self.FirstCall:
	    self.FirstCall = False
	    # normalize initial weights to 1.0
            rows,cols = output_activity.shape
            for r in xrange(rows):
                for c in xrange(cols):
                    cf = cfs[r][c]

	            current_norm_value = 1.0*Numeric.sum(abs(cf.weights.flat))
		    if current_norm_value != 0:
            	    	factor = (1.0/current_norm_value)
            	    	cf.weights *= factor

	

# Specify weight initialization, response function, and learning function

RandomArray.seed(500,500)
CFProjection.weights_generator=topo.patterns.random.UniformRandom()
CFProjection.weights_shape=topo.patterns.basic.Disk(smoothing=0.0)
CFProjection.response_fn=CFPRF_DotProduct_opt()
#CFProjection.learning_fn=CFPLF_Hebbian_opt()
#CFProjection.weights_output_fn=CFPOF_DivisiveNormalizeL1_opt()
#CFProjection.learning_fn=HomeoSynaptic()

###########################################
# build simulation

topo.sim['Retina']=GeneratorSheet(nominal_density=24.0,
                                  input_generator=input_pattern,
                                  period=1.0, phase=0.05,
                                  nominal_bounds=BoundingBox(radius=0.5+0.275))


topo.sim['V1'] = LISSOM(nominal_density=locals().get('default_density',48.0),
                        nominal_bounds=BoundingBox(radius=0.5), output_fn=PiecewiseLinear_debug())
#, output_fn=HomeostaticMaxEnt())

topo.sim['V1'].output_fn.lower_bound=0.1
topo.sim['V1'].output_fn.upper_bound=0.65

topo.sim.connect('Retina','V1',delay=FixedPoint("0.10"),
                  connection_type=CFProjection,strength=1.0,name='Afferent',
                  nominal_bounds_template=BoundingBox(radius=0.275),learning_rate=0,
                  learning_fn=InitFn())
#                  learning_fn=CFPLF_Hebbian_opt(),
#		  weights_output_fn=CFPOF_Plugin(single_cf_fn=DivisiveNormalizeL1()))

topo.sim.connect('V1','V1',delay=FixedPoint("0.05"),name='LateralExcitatory',
                  connection_type=CFProjection,strength=0.9,
                  nominal_bounds_template=BoundingBox(radius=0.10),learning_rate=0,
                 learning_fn=CFPLF_Hebbian_opt(), weights_output_fn=CFPOF_DivisiveNormalizeL1_opt()) 
            
topo.sim.connect('V1','V1',delay=FixedPoint("0.05"),name='LateralInhibitory',
                  connection_type=CFProjection,strength=-0.9,
                  nominal_bounds_template=BoundingBox(radius=0.23),learning_rate=0,
                 learning_fn=CFPLF_Hebbian_opt(), weights_output_fn=CFPOF_DivisiveNormalizeL1_opt())  


wait = 500
topo.sim.schedule_command(wait,'topo.sim["V1"].projections()["Afferent"].learning_rate=0.9590; topo.sim["V1"].projections()["Afferent"].learning_fn=HomeoSynaptic()')
topo.sim.schedule_command(wait,'topo.sim["V1"].projections()["LateralExcitatory"].learning_rate=3.2018')
topo.sim.schedule_command(wait,'topo.sim["V1"].projections()["LateralInhibitory"].learning_rate=1.9626')


### Actions scheduled to occur as the simulation proceeds.#


topo.sim.startup_commands.append("from topo.base.boundingregion import BoundingBox")

### Lateral excitatory bounds changes
topo.sim.schedule_command(200+wait,'topo.sim["V1"].projections()["LateralExcitatory"].change_bounds(BoundingBox(radius=0.06))')
topo.sim.schedule_command(500+wait,'topo.sim["V1"].projections()["LateralExcitatory"].change_bounds(BoundingBox(radius=0.042))')
topo.sim.schedule_command(1000+wait,'topo.sim["V1"].projections()["LateralExcitatory"].change_bounds(BoundingBox(radius=0.0336))')
topo.sim.schedule_command(2000+wait,'topo.sim["V1"].projections()["LateralExcitatory"].change_bounds(BoundingBox(radius=0.02688))')
topo.sim.schedule_command(3000+wait,'topo.sim["V1"].projections()["LateralExcitatory"].change_bounds(BoundingBox(radius=0.02150))')
topo.sim.schedule_command(4000+wait,'topo.sim["V1"].projections()["LateralExcitatory"].change_bounds(BoundingBox(radius=0.01290))')
topo.sim.schedule_command(5000+wait,'topo.sim["V1"].projections()["LateralExcitatory"].change_bounds(BoundingBox(radius=0.00774))')
topo.sim.schedule_command(6500+wait,'topo.sim["V1"].projections()["LateralExcitatory"].change_bounds(BoundingBox(radius=0.00464))')
topo.sim.schedule_command(8000+wait,'topo.sim["V1"].projections()["LateralExcitatory"].change_bounds(BoundingBox(radius=0.00279))')
topo.sim.schedule_command(20000+wait,'topo.sim["V1"].projections()["LateralExcitatory"].change_bounds(BoundingBox(radius=0.00167))')


### Lateral excitatory learning rate changes
topo.sim.schedule_command(200+wait,'topo.sim["V1"].projections()["LateralExcitatory"].learning_rate=1.2213')
topo.sim.schedule_command(500+wait,'topo.sim["V1"].projections()["LateralExcitatory"].learning_rate=0.3466')


### Afferent learning rate changes
topo.sim.schedule_command(  500+wait,'topo.sim["V1"].projections()["Afferent"].learning_rate=0.6850;topo.sim["V1"].projections()["Afferent"].learning_rate=0.6850')
topo.sim.schedule_command( 2000+wait,'topo.sim["V1"].projections()["Afferent"].learning_rate=0.5480;topo.sim["V1"].projections()["Afferent"].learning_rate=0.5480')
topo.sim.schedule_command( 4000+wait,'topo.sim["V1"].projections()["Afferent"].learning_rate=0.4110;topo.sim["V1"].projections()["Afferent"].learning_rate=0.4110')
topo.sim.schedule_command(20000+wait,'topo.sim["V1"].projections()["Afferent"].learning_rate=0.2055;topo.sim["V1"].projections()["Afferent"].learning_rate=0.2055')

'''
topo.sim.schedule_command(1000+wait,'topo.sim["V1"].projections()["Afferent"].learning_fn.activity_target=0.025')
topo.sim.schedule_command(2000+wait,'topo.sim["V1"].projections()["Afferent"].learning_fn.activity_target=0.02')
topo.sim.schedule_command(4000+wait,'topo.sim["V1"].projections()["Afferent"].learning_fn.activity_target=0.015')
topo.sim.schedule_command(8000+wait,'topo.sim["V1"].projections()["Afferent"].learning_fn.activity_target=0.01')

topo.sim.schedule_command(500,'topo.sim["V1"].projections()["Afferent"].learning_fn.beta_n=0.00198')
topo.sim.schedule_command(500,'topo.sim["V1"].projections()["Afferent"].learning_fn.beta_c=0.000198')
topo.sim.schedule_command(2000,'topo.sim["V1"].projections()["Afferent"].learning_fn.beta_n=0.00159')
topo.sim.schedule_command(2000,'topo.sim["V1"].projections()["Afferent"].learning_fn.beta_c=0.000159')
topo.sim.schedule_command(4000,'topo.sim["V1"].projections()["Afferent"].learning_fn.beta_n=0.00119')
topo.sim.schedule_command(4000,'topo.sim["V1"].projections()["Afferent"].learning_fn.beta_c=0.000119')
topo.sim.schedule_command(20000,'topo.sim["V1"].projections()["Afferent"].learning_fn.beta_n=0.000596')
topo.sim.schedule_command(20000,'topo.sim["V1"].projections()["Afferent"].learning_fn.beta_c=0.0000596')
'''

'''
topo.sim.schedule_command(2000+wait,'topo.sim["V1"].projections()["Afferent"].learning_fn.activity_target=0.025')
topo.sim.schedule_command(4000+wait,'topo.sim["V1"].projections()["Afferent"].learning_fn.activity_target=0.020')
topo.sim.schedule_command(8000+wait,'topo.sim["V1"].projections()["Afferent"].learning_fn.activity_target=0.015')
topo.sim.schedule_command(10000+wait,'topo.sim["V1"].projections()["Afferent"].learning_fn.activity_target=0.010')
'''

'''
topo.sim.schedule_command(500+wait,'topo.sim["V1"].projections()["Afferent"].learning_fn.beta_n=0.0075')
topo.sim.schedule_command(500+wait,'topo.sim["V1"].projections()["Afferent"].learning_fn.beta_c=0.0075')
topo.sim.schedule_command(2000+wait,'topo.sim["V1"].projections()["Afferent"].learning_fn.beta_n=0.0065')
topo.sim.schedule_command(2000+wait,'topo.sim["V1"].projections()["Afferent"].learning_fn.beta_c=0.0065')
topo.sim.schedule_command(4000+wait,'topo.sim["V1"].projections()["Afferent"].learning_fn.beta_n=0.0050')
topo.sim.schedule_command(4000+wait,'topo.sim["V1"].projections()["Afferent"].learning_fn.beta_c=0.0050')
topo.sim.schedule_command(20000+wait,'topo.sim["V1"].projections()["Afferent"].learning_fn.beta_n=0.0030')
topo.sim.schedule_command(20000+wait,'topo.sim["V1"].projections()["Afferent"].learning_fn.beta_c=0.0030')
'''

### Schedule LISSOM output function threshold changes
#

topo.sim.schedule_command(  200+wait, 'topo.sim["V1"].output_fn.lower_bound=0.11; topo.sim["V1"].output_fn.upper_bound=0.66')
topo.sim.schedule_command(  500+wait, 'topo.sim["V1"].output_fn.lower_bound=0.12; topo.sim["V1"].output_fn.upper_bound=0.67')
topo.sim.schedule_command( 1000+wait, 'topo.sim["V1"].output_fn.lower_bound=0.15; topo.sim["V1"].output_fn.upper_bound=0.68')
topo.sim.schedule_command( 2000+wait, 'topo.sim["V1"].output_fn.lower_bound=0.18; topo.sim["V1"].output_fn.upper_bound=0.70')
topo.sim.schedule_command( 3000+wait, 'topo.sim["V1"].output_fn.lower_bound=0.20; topo.sim["V1"].output_fn.upper_bound=0.73')
topo.sim.schedule_command( 4000+wait, 'topo.sim["V1"].output_fn.lower_bound=0.20; topo.sim["V1"].output_fn.upper_bound=0.76')
topo.sim.schedule_command( 5000+wait, 'topo.sim["V1"].output_fn.lower_bound=0.21; topo.sim["V1"].output_fn.upper_bound=0.79')
topo.sim.schedule_command( 6500+wait, 'topo.sim["V1"].output_fn.lower_bound=0.22; topo.sim["V1"].output_fn.upper_bound=0.82')
topo.sim.schedule_command( 8000+wait, 'topo.sim["V1"].output_fn.lower_bound=0.23; topo.sim["V1"].output_fn.upper_bound=0.85')
topo.sim.schedule_command(20000+wait, 'topo.sim["V1"].output_fn.lower_bound=0.24; topo.sim["V1"].output_fn.upper_bound=0.88')


topo.sim.run(0)


# Uncomment to allow profiling
## import hotshot,hotshot.stats
## prof = hotshot.Profile("abc")
## prof.runctx('topo.sim.run(199)',globals(),locals())
## prof.close()
## p = hotshot.stats.load("abc")
## p.strip_dirs().sort_stats('cumulative','time').print_stats()
