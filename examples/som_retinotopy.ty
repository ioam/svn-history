"""
Basic example of a fully connected SOM retinotopic map with ConnectionFields.

Contains a Retina (2D Gaussian generator) fully connected to a V1
(CFSOM) sheet, with no initial ordering for topography.

Constructed to match the retinotopic simulation from page 53-59 of
Miikkulainen, Bednar, Choe, and Sirosh (2005), Computational Maps in
the Visual Cortex, Springer.

$Id$
"""
__version__='$Revision$'

import random
import RandomArray
from math import exp, sqrt

import topo.patterns.random
import topo.patterns.basic

from topo.sheets.generatorsheet import GeneratorSheet
from topo.base.boundingregion import BoundingBox
from topo.base.connectionfield import CFProjection
from topo.base.parameterclasses import DynamicNumber,Number
from topo.sheets.cfsom import CFSOM
from topo.responsefns.optimized import CFDotProduct, CFEuclideanDistance
from topo.responsefns.basic import CFEuclideanDistance_Py, CFDotProduct_Py
from topo.base.simulator import Simulator
from topo.learningfns.basic import HebbianSOMLF
from topo.outputfns.basic import DivisiveSumNormalize
from topo.patterns import PatternGeneratorParameter


class RetinotopicSOM(CFSOM):
    """A variant of CFSOM that uses exponential decay functions for alpha and radius."""

    # Minimum radius to allow
    radius_min=Number(0)

    def __init__(self,**params):
        super(RetinotopicSOM,self).__init__(**params)
        self.radius_min=0.5/40

    def alpha(self):
       """Exponential decay."""
       return self.alpha_0*exp(-6.0*(float(self.simulator.time())/self.learning_length))
    
    def radius(self):
       """Exponential decay, but with a minimum value enforced."""
       decayed_radius = self.radius_0*exp(-5.0*(float(self.simulator.time())/self.learning_length))
       return max(decayed_radius,self.radius_min)



###########################################
# Set parameters

# input patterns
GeneratorSheet.period = 1.0
GeneratorSheet.density = 10

# CEBHACKALERT: will go to wherever DynamicValue is
class UniformRandomValue(object):
    """
    When called, return the next value from random.uniform within the
    designated bounds.
    """
    def __init__(self,bounds=(0.0,1.0)):
        self.bounds=bounds
                 
    def __call__(self):
        return random.uniform(self.bounds[0],self.bounds[1])


random.seed(1234)
input_pattern = topo.patterns.basic.Gaussian(scale=1.0,size = 2*sqrt(2.0*0.1*24.0)/24.0,aspect_ratio=1.0,
                                    x=DynamicNumber(UniformRandomValue((-0.5,0.5))),
                                    y=DynamicNumber(UniformRandomValue((-0.5,0.5))),
                                    orientation=DynamicNumber(UniformRandomValue((-pi,pi))))

# cortical sheet
RetinotopicSOM.density = 10
RetinotopicSOM.learning_length = 40000

RetinotopicSOM.radius_0 = 13.3/40
RetinotopicSOM.alpha_0  = 0.42

RandomArray.seed(500,500)
CFProjection.weights_generator = topo.patterns.random.UniformRandom() 

CFProjection.weights_bounds=BoundingBox(radius=1.0) # fully connected network.
CFProjection.response_fn = CFEuclideanDistance()
CFProjection.learning_fn = HebbianSOMLF()


###########################################
# build simulation

s = Simulator()

Retina = GeneratorSheet(input_generator=input_pattern,name='Retina')
V1 = RetinotopicSOM(name='V1')
RtoV1=s.connect(Retina,V1,delay=0.5,connection_type=CFProjection,name='RtoV1')

s.run(0)
#s.run(10000)
