"""
Basic example of a fully connected SOM retinotopic map with ConnectionFields.

Contains a Retina (2D Gaussian generator) fully connected to a V1
(CFSOM) sheet, with no initial ordering for topography.

Constructed to match the retinotopic simulation from page 53-59 of
Miikkulainen, Bednar, Choe, and Sirosh (2005), Computational Maps in
the Visual Cortex, Springer.

$Id$
"""
__version__='$Revision$'

import random
import RandomArray
from math import exp, sqrt

import topo.patterns.random
import topo.patterns.basic

from topo.base.parameter import Number
from topo.sheets.generatorsheet import GeneratorSheet
from topo.base.boundingregion import BoundingBox
from topo.base.connectionfield import CFProjection
from topo.base.parameter import DynamicNumber
from topo.sheets.cfsom import CFSOM
from topo.responsefns.optimized import CFDotProduct, CFEuclideanDistance
from topo.responsefns.basic import CFEuclideanDistance_Py, CFDotProduct_Py
from topo.base.simulator import Simulator
from topo.learningfns.basic import HebbianSOMLF
from topo.outputfns.basic import DivisiveSumNormalize
from topo.patterns import PatternGeneratorParameter

### JCALERT! For the moment, I use a super-class of CFSOM in order to
### override the decay (and alpha) function. It would be good to make
### them Parameters in CFSOM, so that we can delete that here and in
### obermayer, yet still override the decay and alpha function.
class RetinotopicSOM(CFSOM):
    """A variant of CFSOM that uses exponential decay functions for alpha and radius."""

    # Minimum radius to allow
    radius_min=Number(0)

    def __init__(self,**params):
        super(RetinotopicSOM,self).__init__(**params)
        self.radius_min=0.5/40

    def alpha(self):
       """Exponential decay."""
       return self.alpha_0*exp(-6.0*(float(self.simulator.time())/self.learning_length))
    
    def radius(self):
       """Exponential decay, but with a minimum value enforced."""
       decayed_radius = self.radius_0*exp(-5.0*(float(self.simulator.time())/self.learning_length))
       return max(decayed_radius,self.radius_min)



###########################################
# Set parameters

# input patterns
GeneratorSheet.period = 1.0
GeneratorSheet.density = 24

random.seed(1234)
topo.patterns.basic.Gaussian.x = DynamicNumber(lambda : random.uniform(-0.5,0.5),softbounds=(-1.0,1.0))
topo.patterns.basic.Gaussian.y = DynamicNumber(lambda : random.uniform(-0.5,0.5),softbounds=(-1.0,1.0))
topo.patterns.basic.Gaussian.orientation = DynamicNumber(lambda :random.uniform(-pi,pi),softbounds=(0,2*pi))

topo.patterns.basic.Gaussian.size = 2*sqrt(2.0*0.1*24.0)/24.0
topo.patterns.basic.Gaussian.aspect_ratio = 1.0

# cortical sheet
RetinotopicSOM.density = 40
RetinotopicSOM.learning_length = 40000

RetinotopicSOM.radius_0 = 13.3/40 # *1.5 works for RetinotopicSOM.density = 10
RetinotopicSOM.alpha_0  = 0.42

RandomArray.seed(500,500)
CFProjection.weights_generator = topo.patterns.random.UniformRandom() 

CFProjection.weights_bounds=BoundingBox(points=((-1.0,-1.0),(1.0,1.0))) # fully connected network.
CFProjection.response_fn = CFEuclideanDistance() 
CFProjection.learning_fn = HebbianSOMLF()


###########################################
# build simulation

s = Simulator()

Retina = GeneratorSheet(input_generator=topo.patterns.basic.Gaussian(),name='Retina')
V1 = RetinotopicSOM(name='V1')
s.connect(Retina,V1,delay=0.5,connection_type=CFProjection,connection_params=dict(name = 'RtoV1'))

s.run(0)
#s.run(10000)

# import profile,pstats
#
# p = profile.Profile()
# p.runctx('s.run(10)',locals(),globals())
