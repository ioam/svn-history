"""
LISSOM-based V1 map for orientation and disparity preferences.

From Tikesh Ramtohul, "A self-organizing model of disparity maps in
the primary visual cortex", MSc Thesis, School of Informatics,
University of Edinburgh, 2006
(http://www.inf.ed.ac.uk/publications/thesis/online/IM060400.pdf).

The four Gaussian-based simulation scripts in that thesis can be
reproduced using this one script as follows:

lissom_oo_disparity_gauss_2_pixel.ty:
  ../topographica lissom_oo_or_dy.ty

lissom_oo_disparity_gauss_0.ty:
  ../topographica -c "max_disparity=0" lissom_oo_or_dy.ty
  
lissom_oo_disparity_plus_minus_2_pixel.ty:
  ../topographica -c "plusminus=True" lissom_oo_or_dy.ty

lissom_oo_disparity_plus_minus_0.ty:
  ../topographica -c "plusminus=True" -c "max_disparity=0" lissom_oo_or_dy.ty

Note that this file is not regularly maintained, and does not contain
any of the improvements that are e.g. in lissom_oo_or.ty.  Thus
lissom_oo_or.ty is usually a better starting point, unless you are
specifically trying to replicate the results from the above thesis.

$Id$
"""
__version__='$Revision$'


import numpy

from math import pi, sqrt
import copy

from topo import param

import topo.pattern.basic
import topo.pattern.random


from topo.sheet.lissom import LISSOM
from topo.sheet.generator import GeneratorSheet
from topo.projection.basic import CFProjection, SharedWeightCFProjection
from topo.responsefn.optimized import CFPRF_DotProduct_opt
from topo.base.cf import CFSheet
from topo.base.boundingregion import BoundingBox
from topo.learningfn.optimized import CFPLF_Hebbian_opt
from topo.outputfn.optimized import CFPOF_DivisiveNormalizeL1_opt
from topo.outputfn.basic import PiecewiseLinear, DivisiveNormalizeL1
from topo.misc.numbergenerators import UniformRandom

plusminus = locals().get('plusminus',False)

if plusminus:
   lgn_strength=2.33*2.0
else:
   lgn_strength=2.33

# By default uses a maximum disparity of 2 pixels 
# (assuming a retina of 54 units), but can be called as
#   ./topographica -c "max_disparity=xxx" ...
# to use a maximum disparity of xxx pixels instead.
#
# Calculation based on:
# 
#   retina width in sheet coordinates: 2*(0.5+0.25+0.375) = 2.25
#   retina width in pixels: 54
#   sheet coordinate length of one pixel: 2.25/54 = approximately .041665
#   
# Since left_x = input_x - disp and right_x = input_x + disp,
# to get disp of 1 pixel, we need disp to be between -.041665/2 <--> .041665/2
# 
   
max_disparity = locals().get('max_disparity',2.0)

# This trivial difference is for historical reasons only, to match the MSc results
if plusminus: 
   disparity_bound = max_disparity*0.0416665/2.0
   topo.sim.name = "lissom_oo_or_dy_plusminus_" + repr(max_disparity) + "_pixel"
else:
   disparity_bound = max_disparity*0.041665/2.0
   topo.sim.name = "lissom_oo_or_dy_" + repr(max_disparity) + "_pixel"


# jbednar: not sure where these numbers came from, but presumably this
# helps keep the patterns from being off the retina too often
if max_disparity == 0:
   position_bound = 0.75
else:
   # This trivial difference is for historical reasons only, to match the MSc results
   if plusminus: 
      position_bound = 0.7083333 
   else:
      position_bound = 0.70833

### Present input patterns that are at non-corresponding locations on each retina

# Note that this script must be run before unpickling will work.
class NumericOffset(param.Parameterized):
   """
   Returns a numeric value plus a specified offset, to facilitate
   setting a group of parameters to values that are linked except
   for an additive term.  

   The offset can be scaled arbitrarily, e.g. to allow one value
   to be lower than the base value, and another to be higher.

   This class exists primarily to allow this type of code to be
   pickled; otherwise it would be in a lambda function and not
   picklable.
   """
   base         = param.Number(default=0.0,doc="Value to which to add an offset.")
   offset       = param.Number(default=0.0,doc="Amount of offset, before scaling.")
   offset_scale = param.Number(default=1.0,doc="Scaling value for the offset.")
   
   def __call__(self,**params):
       base=params.get('base',self.base)
       offset=params.get('offset',self.offset)
       offset_scale=params.get('offset_scale',self.offset_scale)
       return base + offset_scale*offset

left_x=NumericOffset(offset_scale=-1.0,
   base=UniformRandom(lbound=-position_bound,ubound=position_bound,seed=12),
   offset=UniformRandom(lbound=-disparity_bound,ubound=disparity_bound,seed=150))

right_x=NumericOffset(offset_scale=1.0,
   base=UniformRandom(lbound=-position_bound,ubound=position_bound,seed=12),
   offset=UniformRandom(lbound=-disparity_bound,ubound=disparity_bound,seed=150))


if plusminus:
   from topo.misc.numbergenerators import Choice
   scale_value = Choice(choices=[-0.5,0.5])
   scale_value_copy=copy.deepcopy(scale_value)
   left_scale=scale_value
   right_scale=scale_value_copy
   input_offset=0.5
else:
   left_scale=1.0
   right_scale=1.0
   input_offset=0.0

left_input_pattern = topo.pattern.basic.Gaussian(
          size=2*0.0468, aspect_ratio=4.0, offset=input_offset,
          scale=left_scale,
          x=left_x,
          y=UniformRandom(lbound=-0.75,ubound=0.75,seed=34),
          orientation=UniformRandom(lbound=-pi,ubound=pi,seed=56))

right_input_pattern = topo.pattern.basic.Gaussian(
          size=2*0.0468, aspect_ratio=4.0,offset=input_offset,
          scale=right_scale,
          x=right_x,
          y=UniformRandom(lbound=-0.75,ubound=0.75,seed=34),
          orientation=UniformRandom(lbound=-pi,ubound=pi,seed=56))


# Specify weight initialization, response function, and learning function
CFProjection.weights_generator=topo.pattern.basic.Constant()
CFProjection.cf_shape=topo.pattern.basic.Disk(smoothing=0.0)
CFProjection.response_fn=CFPRF_DotProduct_opt()
CFProjection.learning_fn=CFPLF_Hebbian_opt()
CFProjection.weights_output_fn=CFPOF_DivisiveNormalizeL1_opt()
SharedWeightCFProjection.response_fn=CFPRF_DotProduct_opt()

SharedWeightCFProjection.weights_output_fn.single_cf_fn=DivisiveNormalizeL1()

###########################################
# build simulation



topo.sim['LeftRetina']=GeneratorSheet(nominal_density=24.0,
                                  input_generator=left_input_pattern,
                                  period=1.0, phase=0.05,
                                  nominal_bounds=BoundingBox(radius=0.5+0.25+0.375))

topo.sim['RightRetina']=GeneratorSheet(nominal_density=24.0,
                                  input_generator=right_input_pattern,
                                  period=1.0, phase=0.05,
                                  nominal_bounds=BoundingBox(radius=0.5+0.25+0.375))

topo.sim['LGNOnLeft']=CFSheet(nominal_density=24.0,
                          nominal_bounds=BoundingBox(radius=0.5+0.25),
                          output_fn=PiecewiseLinear(lower_bound=0.0,upper_bound=1.0),
                          measure_maps=False)

topo.sim['LGNOffLeft']=CFSheet(nominal_density=24.0,
                           nominal_bounds=BoundingBox(radius=0.5+0.25),
                           output_fn=PiecewiseLinear(lower_bound=0.0,upper_bound=1.0),
                           measure_maps=False)

topo.sim['LGNOnRight']=CFSheet(nominal_density=24.0,
                          nominal_bounds=BoundingBox(radius=0.5+0.25),
                          output_fn=PiecewiseLinear(lower_bound=0.0,upper_bound=1.0),
                          measure_maps=False)

topo.sim['LGNOffRight']=CFSheet(nominal_density=24.0,
                           nominal_bounds=BoundingBox(radius=0.5+0.25),
                           output_fn=PiecewiseLinear(lower_bound=0.0,upper_bound=1.0),
                           measure_maps=False)

topo.sim['V1'] = LISSOM(nominal_density=locals().get('default_density',48.0),
                        nominal_bounds=BoundingBox(radius=0.5))

topo.sim['V1'].output_fn.lower_bound=0.083
topo.sim['V1'].output_fn.upper_bound=0.633



# LGN ON channel
topo.sim.connect('LeftRetina','LGNOnLeft',delay=0.05,
                  connection_type=SharedWeightCFProjection,strength=lgn_strength,
                  nominal_bounds_template=BoundingBox(radius=0.375),name='LCenterOn',
                  weights_generator=topo.pattern.basic.Gaussian(size=0.0417,
                                                                 aspect_ratio=1))

topo.sim.connect('LeftRetina','LGNOnLeft',delay=0.05,
                  connection_type=SharedWeightCFProjection,strength=-lgn_strength,
                  name='LSurroundOn',nominal_bounds_template=BoundingBox(radius=0.375),
                  weights_generator=topo.pattern.basic.Gaussian(size=0.1667,
                                                                 aspect_ratio=1))

topo.sim.connect('RightRetina','LGNOnRight',delay=0.05,
                  connection_type=SharedWeightCFProjection,strength=lgn_strength,
                  nominal_bounds_template=BoundingBox(radius=0.375),name='RCenterOn',
                  weights_generator=topo.pattern.basic.Gaussian(size=0.0417,
                                                                 aspect_ratio=1))

topo.sim.connect('RightRetina','LGNOnRight',delay=0.05,
                  connection_type=SharedWeightCFProjection,strength=-lgn_strength,
                  name='RSurroundOn',nominal_bounds_template=BoundingBox(radius=0.375),
                  weights_generator=topo.pattern.basic.Gaussian(size=0.1667,
                                                                 aspect_ratio=1))


# LGN OFF channel
topo.sim.connect('LeftRetina','LGNOffLeft',delay=0.05,
                  connection_type=SharedWeightCFProjection,strength=-lgn_strength,
                  name='LCenterOff',nominal_bounds_template=BoundingBox(radius=0.375),
                  weights_generator=topo.pattern.basic.Gaussian(size=0.0417,
                                                                 aspect_ratio=1))

topo.sim.connect('LeftRetina','LGNOffLeft',delay=0.05,
                  connection_type=SharedWeightCFProjection,strength=lgn_strength,
                  name='LSurroundOff',nominal_bounds_template=BoundingBox(radius=0.375),
                  weights_generator=topo.pattern.basic.Gaussian(size=0.1667,
                                                                 aspect_ratio=1))

topo.sim.connect('RightRetina','LGNOffRight',delay=0.05,
                  connection_type=SharedWeightCFProjection,strength=-lgn_strength,
                  name='RCenterOff',nominal_bounds_template=BoundingBox(radius=0.375),
                  weights_generator=topo.pattern.basic.Gaussian(size=0.0417,
                                                                 aspect_ratio=1))

topo.sim.connect('RightRetina','LGNOffRight',delay=0.05,
                  connection_type=SharedWeightCFProjection,strength=lgn_strength,
                  name='RSurroundOff',nominal_bounds_template=BoundingBox(radius=0.375),
                  weights_generator=topo.pattern.basic.Gaussian(size=0.1667,
                                                                 aspect_ratio=1))

# Connections from LGNs to V1

topo.sim.connect('LGNOnLeft','V1',delay=0.05,#dest_port=('Activity','JointNormalize', 'Afferent'),
                  connection_type=CFProjection,strength=0.25,name='LGNOnLeftAfferent',
                  nominal_bounds_template=BoundingBox(radius=0.25),learning_rate=0.9590)

topo.sim.connect('LGNOffLeft','V1',delay=0.05,#dest_port=('Activity','JointNormalize', 'Afferent'),
                  connection_type=CFProjection,strength=0.25,name='LGNOffLeftAfferent',
                  nominal_bounds_template=BoundingBox(radius=0.25),learning_rate=0.9590)

topo.sim.connect('LGNOnRight','V1',delay=0.05,#dest_port=('Activity','JointNormalize', 'Afferent'),
                  connection_type=CFProjection,strength=0.25,name='LGNOnRightAfferent',
                  nominal_bounds_template=BoundingBox(radius=0.25),learning_rate=0.9590)

topo.sim.connect('LGNOffRight','V1',delay=0.05,#dest_port=('Activity','JointNormalize', 'Afferent'),
                  connection_type=CFProjection,strength=0.25,name='LGNOffRightAfferent',
                  nominal_bounds_template=BoundingBox(radius=0.25),learning_rate=0.9590)


# Lateral Connections

topo.sim.connect('V1','V1',delay=0.05,name='LateralExcitatory',
                  connection_type=CFProjection,strength=0.9,
                  nominal_bounds_template=BoundingBox(radius=0.10),learning_rate=3.2018) 
            
topo.sim.connect('V1','V1',delay=0.05,name='LateralInhibitory',
                  connection_type=CFProjection,strength=-0.9,
                  nominal_bounds_template=BoundingBox(radius=0.23),learning_rate=1.9626)  



### Actions scheduled to occur as the simulation proceeds.

topo.sim.startup_commands.append("from topo.base.boundingregion import BoundingBox")

### Lateral excitatory bounds changes
topo.sim.schedule_command(200,'topo.sim["V1"].projections()["LateralExcitatory"].change_bounds(BoundingBox(radius=0.06))')
topo.sim.schedule_command(500,'topo.sim["V1"].projections()["LateralExcitatory"].change_bounds(BoundingBox(radius=0.042))')
topo.sim.schedule_command(1000,'topo.sim["V1"].projections()["LateralExcitatory"].change_bounds(BoundingBox(radius=0.0336))')
topo.sim.schedule_command(2000,'topo.sim["V1"].projections()["LateralExcitatory"].change_bounds(BoundingBox(radius=0.02688))')
topo.sim.schedule_command(3000,'topo.sim["V1"].projections()["LateralExcitatory"].change_bounds(BoundingBox(radius=0.02150))')
topo.sim.schedule_command(4000,'topo.sim["V1"].projections()["LateralExcitatory"].change_bounds(BoundingBox(radius=0.01290))')
topo.sim.schedule_command(5000,'topo.sim["V1"].projections()["LateralExcitatory"].change_bounds(BoundingBox(radius=0.00774))')
topo.sim.schedule_command(6500,'topo.sim["V1"].projections()["LateralExcitatory"].change_bounds(BoundingBox(radius=0.00464))')
topo.sim.schedule_command(8000,'topo.sim["V1"].projections()["LateralExcitatory"].change_bounds(BoundingBox(radius=0.00279))')
topo.sim.schedule_command(20000,'topo.sim["V1"].projections()["LateralExcitatory"].change_bounds(BoundingBox(radius=0.00167))')


### Lateral excitatory learning rate changes
topo.sim.schedule_command(200,'topo.sim["V1"].projections()["LateralExcitatory"].learning_rate=1.2213')
topo.sim.schedule_command(500,'topo.sim["V1"].projections()["LateralExcitatory"].learning_rate=0.3466')


### Afferent learning rate changes
topo.sim.schedule_command(  500,'topo.sim["V1"].projections()["LGNOnLeftAfferent"].learning_rate=0.6850;topo.sim["V1"].projections()["LGNOffLeftAfferent"].learning_rate=0.6850')
topo.sim.schedule_command( 2000,'topo.sim["V1"].projections()["LGNOnLeftAfferent"].learning_rate=0.5480;topo.sim["V1"].projections()["LGNOffLeftAfferent"].learning_rate=0.5480')
topo.sim.schedule_command( 4000,'topo.sim["V1"].projections()["LGNOnLeftAfferent"].learning_rate=0.4110;topo.sim["V1"].projections()["LGNOffLeftAfferent"].learning_rate=0.4110')
topo.sim.schedule_command(20000,'topo.sim["V1"].projections()["LGNOnLeftAfferent"].learning_rate=0.2055;topo.sim["V1"].projections()["LGNOffLeftAfferent"].learning_rate=0.2055')

topo.sim.schedule_command(  500,'topo.sim["V1"].projections()["LGNOnRightAfferent"].learning_rate=0.6850;topo.sim["V1"].projections()["LGNOffRightAfferent"].learning_rate=0.6850')
topo.sim.schedule_command( 2000,'topo.sim["V1"].projections()["LGNOnRightAfferent"].learning_rate=0.5480;topo.sim["V1"].projections()["LGNOffRightAfferent"].learning_rate=0.5480')
topo.sim.schedule_command( 4000,'topo.sim["V1"].projections()["LGNOnRightAfferent"].learning_rate=0.4110;topo.sim["V1"].projections()["LGNOffRightAfferent"].learning_rate=0.4110')
topo.sim.schedule_command(20000,'topo.sim["V1"].projections()["LGNOnRightAfferent"].learning_rate=0.2055;topo.sim["V1"].projections()["LGNOffRightAfferent"].learning_rate=0.2055')


### LISSOM output function bounds changes
topo.sim.schedule_command(  200,'topo.sim["V1"].output_fn.lower_bound=0.093;topo.sim["V1"].output_fn.upper_bound=0.643')
topo.sim.schedule_command(  500,'topo.sim["V1"].output_fn.lower_bound=0.103;topo.sim["V1"].output_fn.upper_bound=0.653')
topo.sim.schedule_command( 1000,'topo.sim["V1"].output_fn.lower_bound=0.133;topo.sim["V1"].output_fn.upper_bound=0.663')
topo.sim.schedule_command( 2000,'topo.sim["V1"].output_fn.lower_bound=0.163;topo.sim["V1"].output_fn.upper_bound=0.683')
topo.sim.schedule_command( 3000,'topo.sim["V1"].output_fn.lower_bound=0.183;topo.sim["V1"].output_fn.upper_bound=0.713')
topo.sim.schedule_command( 4000,'topo.sim["V1"].output_fn.lower_bound=0.183;topo.sim["V1"].output_fn.upper_bound=0.743')
topo.sim.schedule_command( 5000,'topo.sim["V1"].output_fn.lower_bound=0.193;topo.sim["V1"].output_fn.upper_bound=0.773')
topo.sim.schedule_command( 6500,'topo.sim["V1"].output_fn.lower_bound=0.203;topo.sim["V1"].output_fn.upper_bound=0.803')
topo.sim.schedule_command( 8000,'topo.sim["V1"].output_fn.lower_bound=0.213;topo.sim["V1"].output_fn.upper_bound=0.833')
topo.sim.schedule_command(20000,'topo.sim["V1"].output_fn.lower_bound=0.223;topo.sim["V1"].output_fn.upper_bound=0.863')



# default locations for model editor

topo.sim['V1'         ].layout_location=( 600,225)
topo.sim['LGNOnLeft'  ].layout_location=( 200,445)
topo.sim['LGNOffLeft' ].layout_location=( 482,445)
topo.sim['LeftRetina' ].layout_location=( 279,700)

topo.sim['LGNOnRight' ].layout_location=( 750,445)
topo.sim['LGNOffRight'].layout_location=(1030,445)
topo.sim['RightRetina'].layout_location=( 879,700)



