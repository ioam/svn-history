"""
Whisker barrel simulation from Stuart Wilson, using inputs calculated
in Matlab attached to a LISSOM cortical sheet.

Not yet finished or tested.

$Id$
"""
__version__='$Revision$'


###############################################################################
# Input generation code; may eventually move to topo/patterns

from mlabwrap import mlab
mlab.addpath('examples/whiskers')

from topo.base.parameterclasses import Integer, Number
from topo.base.patterngenerator import PatternGenerator
import topo

class WhiskerArray(PatternGenerator):
    """
    Simulates a 2D array of whiskers using external Matlab programs.
    """

    # JABALERT: The parameter definitions here are quite arbitrary, e.g.
    # differing over whether they are a square number or a square root.
    # Should be generalized to handle a full range of reasonable values.
    num_whiskers = Integer(default=5,bounds=(1,None),softbounds=(0.0,10.0),
        precedence=0.31,doc="""
        Square root of the number of whiskers to use.  E.g. 3 gives a 3x3 array.""")

    # JABALERT: Change to be 9 by default and to be a square root.
    num_ganglion_cells = Integer(default=81,doc="""
        Number of ganglion cells to use per whisker; must be a square integer.""")

    # JABALERT: Apparently only supports a quantized set of directions, but that needs fixing.
    direction = Number(default=pi/4,softbounds=(0.0,2*pi),doc="""
        Direction of whisker array motion, in radians, assuming a stationary surface.""")

    def __init__(self,**params):
        super(WhiskerArray,self).__init__(**params)
        # Should probably specify a fixed seed for the random numbers
        # so that the positions won't change on each run
        self.ganglion_cell_positions=mlab.shuffle(self.num_whiskers,self.num_ganglion_cells)
        
    def function(self,**params):
        direction = params.get('direction',self.direction)
        
        return mlab.generate_barrelettes(
            mlab.stim_whiskers_time(self.num_whiskers,
                                    self.num_ganglion_cells,
                                    int(direction/pi*180),
                                    # Next two parameters may be best stored in matlab,
                                    # because they depend on the input pattern type:
                                    5,   # Stimulus length
                                    0.4, # Stimulus height
                                    0,   # Rectify?
                                    int(topo.sim.time()+1)), # Time step; 1-based
            self.ganglion_cell_positions)

# Examples:
#x=WhiskerArray()
#from topo.commands.pylabplots import matrixplot
#matrixplot(x())
#topo.sim.run(2)
#matrixplot(x())

###############################################################################


import fixedpoint
import numpy
import copy

from math import pi, sqrt
from fixedpoint import FixedPoint

import topo.patterns.basic
import topo.patterns.random

from topo.patterns.basic import Gaussian,Sweeper
from topo.sheets.lissom import LISSOM
from topo.sheets.generatorsheet import GeneratorSheet
from topo.projections.basic import CFProjection
from topo.responsefns.optimized import CFPRF_DotProduct_opt
from topo.base.parameterclasses import DynamicNumber
from topo.base.cf import CFSheet
from topo.base.boundingregion import BoundingBox
from topo.learningfns.optimized import CFPLF_Hebbian_opt
from topo.outputfns.optimized import CFPOF_DivisiveNormalizeL1_opt
from topo.outputfns.basic import PiecewiseLinear, DivisiveNormalizeL1
from topo.misc.numbergenerators import UniformRandom

topo.sim.name = "lissom_whisker_barrels"

num_inputs=1
input_type=Gaussian
inputs=[input_type(x=DynamicNumber(UniformRandom(lbound=-0.75,ubound=0.75,seed=12+i)),
                   y=DynamicNumber(UniformRandom(lbound=-0.75,ubound=0.75,seed=34+i)),
                   orientation=0,
                   size=0.088388, aspect_ratio=4.66667, scale=1.0,
                   bounds=BoundingBox(radius=0.8))
        for i in xrange(num_inputs)]
sub_inputs = topo.patterns.basic.SeparatedComposite(min_separation=2.2*0.27083,generators=inputs)

                                 
# Default for tutorial
topo.patterns.basic.Line.scale=0.9
topo.patterns.basic.Gaussian.size=0.08333
topo.patterns.basic.Gaussian.aspect_ratio=4.0

# Specify weight initialization, response function, and learning function
numpy.random.seed((500,500))

CFProjection.weights_shape = topo.patterns.basic.Disk(smoothing=0.0)
CFProjection.weights_generator = topo.patterns.basic.Constant()
CFProjection.response_fn=CFPRF_DotProduct_opt()
CFProjection.learning_fn=CFPLF_Hebbian_opt()
CFProjection.weights_output_fn=CFPOF_DivisiveNormalizeL1_opt()


###########################################
# build simulation

# Number of separate delay lines from the input surface
num_lags=4
for i in xrange(num_lags):
    topo.sim['Ganglia'+str(i)]=GeneratorSheet(nominal_density=24.0,
                                             input_generator=Sweeper(generator=copy.deepcopy(sub_inputs),step=i,speed=1/24.0,
                                                                     orientation=DynamicNumber(UniformRandom(lbound=-pi,ubound=pi,seed=88))),
                                             period=1.0, phase=0.05,
                                             nominal_bounds=BoundingBox(radius=0.5))

topo.sim['S1'] = LISSOM(nominal_density=locals().get('default_density',48.0),tsettle=9,
                        nominal_bounds=BoundingBox(radius=0.5))

topo.sim['S1'].output_fn.lower_bound=0.083
topo.sim['S1'].output_fn.upper_bound=0.633


for i in xrange(num_lags):

    topo.sim.connect('Ganglia'+str(i),'S1',delay=FixedPoint("0.05"),dest_port=('Activity','JointNormalize', 'Afferent'),
                     connection_type=CFProjection,strength=1.0,name='Afferent'+str(i),
                     weights_generator=topo.patterns.basic.Composite(operator=numpy.multiply, 
                                                                     generators=[Gaussian(aspect_ratio=1.0, size=2*0.27083),
                                                                                 topo.patterns.random.UniformRandom()]),
                     nominal_bounds_template=BoundingBox(radius=0.27083),learning_rate=0.9590)


topo.sim.connect('S1','S1',delay=FixedPoint("0.05"),name='LateralExcitatory',
                 connection_type=CFProjection,strength=0.9,
                 weights_generator=topo.patterns.basic.Composite(operator=numpy.multiply, 
                                                                 generators=[Gaussian(aspect_ratio=1.0, size=2*0.10417),
                                                                             topo.patterns.random.UniformRandom()]),
                 nominal_bounds_template=BoundingBox(radius=0.10417),learning_rate=2.55528) 
            
topo.sim.connect('S1','S1',delay=FixedPoint("0.05"),name='LateralInhibitory',
                 connection_type=CFProjection,strength=-0.9,
                 weights_generator=topo.patterns.basic.Composite(operator=numpy.multiply, 
                                                                 generators=[Gaussian(aspect_ratio=1.0, size=2*0.22917),
                                                                             topo.patterns.random.UniformRandom()]),
                 nominal_bounds_template=BoundingBox(radius=0.22917),learning_rate=1.80873)  



### Actions scheduled to occur as the simulation proceeds.#
topo.sim.startup_commands.append("from topo.base.boundingregion import BoundingBox")

# Convenience variable: timescale
st=1.0/num_inputs

### Lateral excitatory bounds changes
LE='topo.sim["S1"].projections()["LateralExcitatory"]'

topo.sim.schedule_command(  200*st,LE+'.change_bounds(BoundingBox(radius=0.06250))')
topo.sim.schedule_command(  500*st,LE+'.change_bounds(BoundingBox(radius=0.04375))')
topo.sim.schedule_command( 1000*st,LE+'.change_bounds(BoundingBox(radius=0.03500))')
topo.sim.schedule_command( 2000*st,LE+'.change_bounds(BoundingBox(radius=0.02800))')
topo.sim.schedule_command( 3000*st,LE+'.change_bounds(BoundingBox(radius=0.02240))')
topo.sim.schedule_command( 4000*st,LE+'.change_bounds(BoundingBox(radius=0.01344))')
topo.sim.schedule_command( 5000*st,LE+'.change_bounds(BoundingBox(radius=0.00806))')
topo.sim.schedule_command( 6500*st,LE+'.change_bounds(BoundingBox(radius=0.00484))')
topo.sim.schedule_command( 8000*st,LE+'.change_bounds(BoundingBox(radius=0.00290))')
topo.sim.schedule_command(20000*st,LE+'.change_bounds(BoundingBox(radius=0.00174))')

### Lateral excitatory learning rate changes
topo.sim.schedule_command(  200*st,LE+'.learning_rate=0.12168*'+LE+'.n_units()')
topo.sim.schedule_command(  500*st,LE+'.learning_rate=0.06084*'+LE+'.n_units()')
topo.sim.schedule_command( 1000*st,LE+'.learning_rate=0.06084*'+LE+'.n_units()')
topo.sim.schedule_command( 2000*st,LE+'.learning_rate=0.06084*'+LE+'.n_units()')
topo.sim.schedule_command( 3000*st,LE+'.learning_rate=0.06084*'+LE+'.n_units()')
topo.sim.schedule_command( 4000*st,LE+'.learning_rate=0.06084*'+LE+'.n_units()')
topo.sim.schedule_command( 5000*st,LE+'.learning_rate=0.06084*'+LE+'.n_units()')
topo.sim.schedule_command( 6500*st,LE+'.learning_rate=0.06084*'+LE+'.n_units()')
topo.sim.schedule_command( 8000*st,LE+'.learning_rate=0.06084*'+LE+'.n_units()')
topo.sim.schedule_command(20000*st,LE+'.learning_rate=0.06084*'+LE+'.n_units()')

### Afferent learning rate changes
for i in xrange(num_lags):
    AFF ='topo.sim["S1"].projections()["Afferent'+str(i)+'"]'
    topo.sim.schedule_command(  500*st,AFF+'.learning_rate=0.6850')
    topo.sim.schedule_command( 2000*st,AFF+'.learning_rate=0.5480')
    topo.sim.schedule_command( 4000*st,AFF+'.learning_rate=0.4110')
    topo.sim.schedule_command(20000*st,AFF+'.learning_rate=0.2055')

### Activation function threshold changes
OF='topo.sim["S1"].output_fn'

topo.sim.schedule_command(  200*st,OF+'.lower_bound=0.093;'+OF+'.upper_bound=0.643')
topo.sim.schedule_command(  500*st,OF+'.lower_bound=0.103;'+OF+'.upper_bound=0.643')
topo.sim.schedule_command( 1000*st,OF+'.lower_bound=0.133;'+OF+'.upper_bound=0.663')
topo.sim.schedule_command( 2000*st,OF+'.lower_bound=0.163;'+OF+'.upper_bound=0.683')
topo.sim.schedule_command( 3000*st,OF+'.lower_bound=0.183;'+OF+'.upper_bound=0.713')
topo.sim.schedule_command( 4000*st,OF+'.lower_bound=0.183;'+OF+'.upper_bound=0.743')
topo.sim.schedule_command( 5000*st,OF+'.lower_bound=0.193;'+OF+'.upper_bound=0.773')
topo.sim.schedule_command( 6500*st,OF+'.lower_bound=0.203;'+OF+'.upper_bound=0.803')
topo.sim.schedule_command( 8000*st,OF+'.lower_bound=0.213;'+OF+'.upper_bound=0.833')
topo.sim.schedule_command(20000*st,OF+'.lower_bound=0.223;'+OF+'.upper_bound=0.863')


### Settling steps changes
topo.sim.schedule_command( 2000*st,'topo.sim["S1"].tsettle=10')
topo.sim.schedule_command( 5000*st,'topo.sim["S1"].tsettle=11')
topo.sim.schedule_command( 6500*st,'topo.sim["S1"].tsettle=12')
topo.sim.schedule_command( 8000*st,'topo.sim["S1"].tsettle=13')

# default locations for model editor
topo.sim.grid_layout([[None, 'S1'],
                      [('Ganglia'+str(i)) for i in xrange(num_lags)]],
                     xstart=150, xstep=150)
