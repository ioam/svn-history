"""
Whisker barrel simulation from Stuart Wilson's 2007 University of
Edinburgh MSc thesis, using inputs calculated in Matlab attached to a
LISSOM cortical sheet.

Requires Matlab (tested with 7.2 and 7.4) and mlabwrap to be installed; see
http://topographica.org/Reference_Manual/index.html#mlabwrap.  

$Id$
"""
__version__='$Revision$'


# Before loading this script, run something like this code in your
# shell so that mlabwrap can find matlab:
# export LD_LIBRARY_PATH=${LD_LIBRARY_PATH}:/opt/matlab-7.4/bin/glnx86

from mlabwrap import mlab

# Location of the Matlab code
mlab.addpath('examples/whiskers')

from topo import param

from topo.base.patterngenerator import PatternGenerator
from topo.command.analysis import PatternPresenter, Subplotting
from topo.base.functionfamilies import CoordinateMapperFn
from topo.coordmapper.basic import Grid

import topo


# Number of separate delay lines from the input surface, i.e. how
# many ganglia sheets to use.  By default, uses only one, but if
# called as:
#
# ./topographica -c num_lags=4 lissom_whisker_barrels.ty -g
#
# the spatiotemporal version can be used, with four input sheets.
num_lags=locals().get('num_lags',1)



###############################################################################

class WhiskerArray(PatternGenerator):
    """
    Simulates a 2D array of whiskers using external Matlab programs. 
    """

    # Because of quantisation issues, num_whiskers should be an odd number 
    num_whiskers = param.Integer(default=3,bounds=(1,None),softbounds=(0.0,10.0),
        precedence=0.31,doc="""
        Square root of the number of whiskers to use.  E.g. 3 gives a 3x3 array.""")

    randomise_ganglion = bool(True)
  
    num_ganglion_cells = param.Integer(default=8,doc="""
        Square root of the number of ganglion cells per whisker.""")

    deflection = param.Number(default=pi/4,softbounds=(0.0,2*pi),doc="""
        Whisker deflection angle, in radians""")

    # This is useful for the lagged model; in the simple case step = 1
    step = param.Number(default=0,doc="""
        Number of steps at the given speed to move in the sweep direction.
        The distance moved is speed*step.""")

    speed = param.Number(default=0.09,bounds=(0.0,None),doc="""
        Sweep speed, i.e. distance moved in one time step.  Also scales the deflection.""")

    rectify = param.Boolean(default=True,doc="""
        Whether or not to suppress firing in depressed ganglion. 1 means to rectify, 0 to not.""")

    whisker = param.Integer(default=(0), doc="""
        Which whiskers are to receive inputs; use (0) for all.""")

    ## SWALERT: This needs to be figured out.
    step_size = param.Number(default = 0.75,doc="""
        Scaling of the distance; must be fine tuned to give good results.""")

    pipe_size = param.Integer(default=100,doc="""
        Square root of the number of elements to define the pipe.
        A larger size means a more smoothly defined Gaussian drop off.""")

    pipe_sigma=param.Integer(default=20, doc="""
        Sigma of the pipe falloff.""")

    pipe_sigma_on=param.Number(default=0.1, doc="""
        Falloff for the RA ON response.""")

    pipe_sigma_off=param.Number(default=0.9, doc="""
        Falloff for the RA OFF response.""")

    pipe_off_strength= param.Number(default=0, doc="""
        Height of the RA OFF response.""") 
    
    random_seed = param.Number(default = 310) # was 5489 for all sims in thesis
    

    def __init__(self,**params):
        super(WhiskerArray,self).__init__(**params)
        self.ganglion_cell_positions=mlab.shuffle(self.num_whiskers,self.num_ganglion_cells,self.random_seed)
        self.whisking_pipe=mlab.pipe(self.pipe_size,
                                               self.pipe_sigma_on,
                                               self.pipe_sigma_off,
                                               self.pipe_off_strength,
                                               self.num_whiskers)
        
    def function(self,params):
        deflection = params.get('deflection',self.deflection)
        
        # JABALERT: Should probably make the function "mlab.sweep" be a parameter,
        # to make it simpler to choose between these models.
	#
        # For the various simulations reported in the thesis, use:
        #  mlab.sweep for correlated model
        #  mlab.sweep_uncor for uncorrelated model
        #  mlab.sweep_random for the random model
        #  mlab.sweep_anticor for anticorrelated model
        #
        # These models haven't yet been tried for the case of num_lags>1,
        # which might inappropriately randomise for each lagged sheet
        #
	self.firing_rates = mlab.sweep(
                                    self.num_whiskers,
				    self.num_ganglion_cells,
				    self.whisking_pipe,
                                    self.step_size,
				    self.rectify*1, 
				    self.speed, 
				    360*self.deflection/2.0/pi,
				    self.step+1,
                                    self.whisker)
	if self.randomise_ganglion ==True:
            inputs = mlab.generate_barrelettes(self.firing_rates, self.ganglion_cell_positions)
        else:
            inputs =  mlab.generate_barrelettes(self.firing_rates, 0)
        
        return inputs

    
###############################################################################

# JABALERT: This class should share a parent class with WhiskerArray, instead
# of hard-coding references to parameter values of WhiskerArray.  The
# results will all be entirely mixed up if any of the defaults in
# WhiskerArray are changed after this class has been created.
#
class TestWhiskerArray(PatternGenerator):
    """
    A second WhiskerArray Class for testing the map.
    """

    num_whiskers = WhiskerArray.num_whiskers

    randomise_ganglion = WhiskerArray.randomise_ganglion
  
    num_ganglion_cells = WhiskerArray.num_ganglion_cells

    deflection = param.Number(default=pi/4,softbounds=(0.0,2*pi),doc="""
        Deflection of whisker array motion, in radians from 0 to 2*pi, assuming a stationary surface.""")
   
    speed = param.Number(1)
    
    rectify = param.Boolean(default=True,doc="""
        Whether or not to suppress firing in depressed ganglion. 1 means to rectify, 0 to not.""")
    
    whisker = param.Integer(default=0, doc="""
        Which whiskers are to receive inputs; use 0 for all.""")
	

    def __init__(self,**params):
        super(TestWhiskerArray,self).__init__(**params)
        self.ganglion_cell_positions=mlab.shuffle(self.num_whiskers,self.num_ganglion_cells,WhiskerArray.random_seed)
        

    def function(self,params):
        deflection = params.get('deflection',self.deflection)
            
        self.firing_rates = mlab.test_deflections(
                                    WhiskerArray.num_whiskers,
				    WhiskerArray.num_ganglion_cells,
				    WhiskerArray.rectify*1, 
				    1,
				    360*self.deflection/2.0/pi,
                                    self.whisker)
        
        if self.randomise_ganglion ==True:
            inputs = mlab.generate_barrelettes(self.firing_rates, self.ganglion_cell_positions)
        else:
            inputs =  mlab.generate_barrelettes(self.firing_rates, 0)
        
        return inputs


###############################################################################

# JABALERT: See JABALERT for the TestWhiskerArray class above.
class WhiskerBotData(PatternGenerator):
    """
    A third class for plugging WhiskerBot data into the map. Some
    original WhiskerBot sims are left in to give the idea of how this
    works.
    """

    num_whiskers = WhiskerArray.num_whiskers

    randomise_ganglion = WhiskerArray.randomise_ganglion 
	
    whiskerBot_gain = param.Number(default=3.14,bounds=(0.0,20.0),doc="""
        Scale the WhiskerBot strain data""")
    
    rectify = param.Boolean(default=True,doc="""
        Whether or not to supress firing in depressed ganglion cell. 1 is to rectify, 0 is to not""")

    time_step = param.Integer(default = 1,bounds=(1,50),doc="""
        Numbered frame from the WhiskerBot simulation.""")

    whiskerBot_data = param.Integer(default = 1,doc="""
        Choose WhiskerBot data to present. Data are stored in examples/whiskers/wbot_object_data:
        1:Concave surface, 2:Ball, 3:Chequerboard, 4:vertical ridges.""") 
	
    plot_vectors = param.Boolean(default = True,doc="""
        Display vector plots from Matlab.""")
    

    def __init__(self,**params):
        super(WhiskerBotData,self).__init__(**params)
        # Should probably specify a fixed seed for the random numbers
        # so that the positions won't change on each run
        self.ganglion_cell_positions=mlab.shuffle(WhiskerArray.num_whiskers,WhiskerArray.num_ganglion_cells,WhiskerArray.random_seed)
	self.wbot_data=mlab.load("wbot_data_new")

	
    def function(self,params):
	if self.whiskerBot_data==1:
		self.wbot_x=self.wbot_data.back_new_x
		self.wbot_y=self.wbot_data.back_new_y
	elif self.whiskerBot_data==2:
		self.wbot_x=self.wbot_data.diagonal_back_x
		self.wbot_y=self.wbot_data.diagonal_back_y
	elif self.whiskerBot_data==3:
		self.wbot_x=self.wbot_data.vertical_new_x
		self.wbot_y=self.wbot_data.vertical_new_y
	elif self.whiskerBot_data==4:
		self.wbot_d=mlab.load("cheque_data")
		self.wbot_x=self.wbot_d.cheque_final_x
		self.wbot_y=self.wbot_d.cheque_final_y

        self.firing_rates = mlab.whiskerbot_frame(self.wbot_x,
						  self.wbot_y,
						  self.whiskerBot_gain,
						  WhiskerArray.rectify*1,
						  WhiskerArray.num_ganglion_cells,
						  self.time_step,
						  self.plot_vectors*1)
        if self.randomise_ganglion ==True:
            inputs = mlab.generate_barrelettes(self.firing_rates, self.ganglion_cell_positions)
        else:
            inputs =  mlab.generate_barrelettes(self.firing_rates, 0)
        
        return inputs


###############################################################################
from topo.base.sheetview import SheetView

def specify_whisker_deflections():
   """
   Ask Matlab for the deflection preference for each input pixel,
   and create a SheetView with that information to be used for
   colorizing plots.
   """
   from mlabwrap import mlab
    
   for sheet in topo.sim.objects(GeneratorSheet).values():
        # Get data from matlab, with deflection pref as a number between 0 and 2*pi
        ganglion_preferences = mlab.ganglion_labels(sheet.input_generator.ganglion_cell_positions,
                                                    WhiskerArray.num_ganglion_cells,
                                                    WhiskerArray.num_whiskers)
        new_view = SheetView((ganglion_preferences,sheet.bounds), sheet.name,sheet.precedence)
        sheet.sheet_views['DeflectionPreference']=new_view



###############################################################################
# Deflection preference map plotting, based on measure_or_pref in analysis.py

from topo.plotting.plotgroup import create_plotgroup
pg= create_plotgroup(name='Deflection Preference',category="Preference Maps",
                     doc='Measure preference for direction stimulus for a lagged model.',
                     update_command='measure_deflection_pref()')
pg.add_plot('Deflection Preference',[('Hue','DeflectionPreference')])
pg.add_plot('Deflection Preference&Selectivity',[('Hue','DeflectionPreference'),
						   ('Confidence','DeflectionSelectivity')])
pg.add_plot('Deflection Selectivity',[('Strength','DeflectionSelectivity')])
pg.add_plot('Whisker Preference',[('Strength','WhiskerPreference')])
pg.add_plot('Whisker Selectivity',[('Strength','WhiskerSelectivity')])
pg.add_static_image('Color Key','examples/whiskers/dfl_key_white_vert.png')

def measure_deflection_pref(num_deflection=12,
                    scale=0.3,offset=0.0,display=False,weighted_average=False,
                    pattern_presenter=PatternPresenter(pattern_generator=TestWhiskerArray(),apply_output_fn=False,duration=0.175)):
    
    """  
    Measure deflection maps, by collating the responses to a set of
    whisker deflections in different directions.
    """
    if num_deflection <= 0:
        raise ValueError("num_deflection must be greater than 0")

    else:
	 step_deflection=pi/num_deflection
        
    step_whiskers = WhiskerArray.num_whiskers

    feature_values = [Feature(name="whisker",range=(1, WhiskerArray.num_whiskers*WhiskerArray.num_whiskers
),step=1,cyclic=False), Feature(name="deflection",range=(0.0,2*pi),step=step_deflection,cyclic=True)]
        
    param_dict = {"scale":scale,"offset":offset}
    x=FeatureMaps(feature_values)
    x.collect_feature_responses(pattern_presenter,param_dict,display,weighted_average)

    Subplotting.set_subplots("Deflection",force=False)


###############################################################################


import numpy
import copy

from math import pi, sqrt, fmod


import topo.pattern.basic
import topo.pattern.random

from topo.pattern.basic import Gaussian,Sweeper
from topo.sheet.lissom import LISSOM
from topo.sheet.generator import GeneratorSheet
from topo.projection.basic import CFProjection
from topo.responsefn.optimized import CFPRF_DotProduct_opt
from topo.base.cf import CFSheet
from topo.base.boundingregion import BoundingBox
from topo.learningfn.optimized import CFPLF_Hebbian_opt
from topo.outputfn.optimized import CFPOF_DivisiveNormalizeL1_opt
from topo.outputfn.basic import PiecewiseLinear, DivisiveNormalizeL1
from topo.misc.numbergenerators import UniformRandom


num_inputs=WhiskerArray.num_whiskers 
                                 
# Specify weight initialization, response function, and learning function
#CFProjection.cf_shape = topo.pattern.basic.Disk(smoothing=0.0)
CFProjection.cf_shape = topo.pattern.basic.Constant()
CFProjection.weights_generator = topo.pattern.basic.Constant()
CFProjection.response_fn=CFPRF_DotProduct_opt()
CFProjection.learning_fn=CFPLF_Hebbian_opt()
CFProjection.weights_output_fn=CFPOF_DivisiveNormalizeL1_opt()



###############################################################################
# build simulation

num_whiskers=WhiskerArray.num_whiskers
num_ganglion_cells=WhiskerArray.num_ganglion_cells

# For the single-lag case, use an intermediate step
if num_lags==1:
    step_offset=1
else:
    step_offset=0

for i in xrange(num_lags):
    topo.sim['Ganglia'+str(i)]=GeneratorSheet(nominal_density=num_whiskers*num_ganglion_cells,
                                             input_generator=WhiskerArray(num_whiskers=num_whiskers,num_ganglion_cells=num_ganglion_cells,step=i+step_offset,
                                                                          deflection=UniformRandom(lbound=0,ubound=2*pi,seed=23)),
                                             period=1.0, phase=0.05,
                                             nominal_bounds=BoundingBox(radius=0.5))
specify_whisker_deflections()


topo.sim['S1'] = LISSOM(nominal_density=locals().get('default_density',16*WhiskerArray.num_whiskers),tsettle=9,
                        nominal_bounds=BoundingBox(radius=0.5))


topo.sim['S1'].output_fn.lower_bound=0.083
topo.sim['S1'].output_fn.upper_bound=0.633


# The Grid coord_mapper divides the cortical sheet into barrel fields, 1 for each whisker. 
for i in xrange(num_lags):
    topo.sim.connect('Ganglia'+str(i),'S1',delay=0.05,dest_port=('Activity','JointNormalize', 'Afferent'),
                     connection_type=CFProjection,strength=1.0,name='Afferent'+str(i),
                     weights_generator=topo.pattern.basic.Composite(generators=[Gaussian(aspect_ratio=1.0, size=2*0.27083),
                                                                                 topo.pattern.random.UniformRandom()]), nominal_bounds_template=BoundingBox(radius=0.53/WhiskerArray.num_whiskers),learning_rate=0.85, coord_mapper=Grid(xdensity=WhiskerArray.num_whiskers,ydensity=WhiskerArray.num_whiskers))
                   


topo.sim.connect('S1','S1',delay=0.05,name='LateralExcitatory',
                 connection_type=CFProjection,strength=0.9,
                 weights_generator=topo.pattern.basic.Composite(operator=numpy.multiply, 
                                                                 generators=[Gaussian(aspect_ratio=1.0, size=2*0.10417),
                                                                             topo.pattern.random.UniformRandom()]),
                 nominal_bounds_template=BoundingBox(radius=0.10417),learning_rate=2.55528) 
                 
            
topo.sim.connect('S1','S1',delay=0.05,name='LateralInhibitory',
                 connection_type=CFProjection,strength=-0.9,
                 weights_generator=topo.pattern.basic.Composite(operator=numpy.multiply, 
                                                                 generators=[Gaussian(aspect_ratio=1.0, size=2*0.22917),
                                                                             topo.pattern.random.UniformRandom()]),
                 nominal_bounds_template=BoundingBox(radius=0.22917),learning_rate=1.80873) 


### Actions scheduled to occur as the simulation proceeds.

topo.sim.startup_commands.append("from topo.base.boundingregion import BoundingBox")

# Convenience variable: timescale
st=1.0/num_inputs

### Lateral excitatory bounds changes
LE='topo.sim["S1"].projections()["LateralExcitatory"]'

topo.sim.schedule_command(  200*st,LE+'.change_bounds(BoundingBox(radius=0.06250))')
topo.sim.schedule_command(  500*st,LE+'.change_bounds(BoundingBox(radius=0.04375))')
topo.sim.schedule_command( 1000*st,LE+'.change_bounds(BoundingBox(radius=0.03500))')
topo.sim.schedule_command( 2000*st,LE+'.change_bounds(BoundingBox(radius=0.02800))')
topo.sim.schedule_command( 3000*st,LE+'.change_bounds(BoundingBox(radius=0.02240))')
topo.sim.schedule_command( 4000*st,LE+'.change_bounds(BoundingBox(radius=0.01344))')
topo.sim.schedule_command( 5000*st,LE+'.change_bounds(BoundingBox(radius=0.00806))')
topo.sim.schedule_command( 6500*st,LE+'.change_bounds(BoundingBox(radius=0.00484))')
topo.sim.schedule_command( 8000*st,LE+'.change_bounds(BoundingBox(radius=0.00290))')
topo.sim.schedule_command(20000*st,LE+'.change_bounds(BoundingBox(radius=0.00174))')

### Lateral excitatory learning rate changes
topo.sim.schedule_command(  200*st,LE+'.learning_rate=0.12168*'+LE+'.n_units()')
topo.sim.schedule_command(  500*st,LE+'.learning_rate=0.06084*'+LE+'.n_units()')
topo.sim.schedule_command( 1000*st,LE+'.learning_rate=0.06084*'+LE+'.n_units()')
topo.sim.schedule_command( 2000*st,LE+'.learning_rate=0.06084*'+LE+'.n_units()')
topo.sim.schedule_command( 3000*st,LE+'.learning_rate=0.06084*'+LE+'.n_units()')
topo.sim.schedule_command( 4000*st,LE+'.learning_rate=0.06084*'+LE+'.n_units()')
topo.sim.schedule_command( 5000*st,LE+'.learning_rate=0.06084*'+LE+'.n_units()')
topo.sim.schedule_command( 6500*st,LE+'.learning_rate=0.06084*'+LE+'.n_units()')
topo.sim.schedule_command( 8000*st,LE+'.learning_rate=0.06084*'+LE+'.n_units()')
topo.sim.schedule_command(20000*st,LE+'.learning_rate=0.06084*'+LE+'.n_units()')

### Afferent learning rate changes
for i in xrange(num_lags):
    AFF ='topo.sim["S1"].projections()["Afferent'+str(i)+'"]'
    topo.sim.schedule_command(  500*st,AFF+'.learning_rate=0.6850')
    topo.sim.schedule_command( 2000*st,AFF+'.learning_rate=0.5480')
    topo.sim.schedule_command( 4000*st,AFF+'.learning_rate=0.4110')
    topo.sim.schedule_command(20000*st,AFF+'.learning_rate=0.2055')

### Activation function threshold changes
OF='topo.sim["S1"].output_fn'

topo.sim.schedule_command(  200*st,OF+'.lower_bound=0.093;'+OF+'.upper_bound=0.643')
topo.sim.schedule_command(  500*st,OF+'.lower_bound=0.103;'+OF+'.upper_bound=0.643')
topo.sim.schedule_command( 1000*st,OF+'.lower_bound=0.133;'+OF+'.upper_bound=0.663')
topo.sim.schedule_command( 2000*st,OF+'.lower_bound=0.163;'+OF+'.upper_bound=0.683')
topo.sim.schedule_command( 3000*st,OF+'.lower_bound=0.183;'+OF+'.upper_bound=0.713')
topo.sim.schedule_command( 4000*st,OF+'.lower_bound=0.183;'+OF+'.upper_bound=0.743')
topo.sim.schedule_command( 5000*st,OF+'.lower_bound=0.193;'+OF+'.upper_bound=0.773')
topo.sim.schedule_command( 6500*st,OF+'.lower_bound=0.203;'+OF+'.upper_bound=0.803')
topo.sim.schedule_command( 8000*st,OF+'.lower_bound=0.213;'+OF+'.upper_bound=0.833')
topo.sim.schedule_command(20000*st,OF+'.lower_bound=0.223;'+OF+'.upper_bound=0.863')


### Settling steps changes
topo.sim.schedule_command( 2000*st,'topo.sim["S1"].tsettle=10')
topo.sim.schedule_command( 5000*st,'topo.sim["S1"].tsettle=11')
topo.sim.schedule_command( 6500*st,'topo.sim["S1"].tsettle=12')
topo.sim.schedule_command( 8000*st,'topo.sim["S1"].tsettle=13')

# default locations for model editor
topo.sim.grid_layout([[None, 'S1'],
                     [('Ganglia'+str(i)) for i in xrange(num_lags)]],
                     xstart=150, xstep=150)

Subplotting.set_subplots("Deflection",force=False)
