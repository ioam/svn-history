"""
Tiny example network useful for testing components.

$Id$
"""
__version__='$Revision$'

import RandomArray

from fixedpoint import FixedPoint

import topo.patterns.random
import topo.patterns.basic
 
from topo.base.parameterclasses import Number
from topo.base.boundingregion import BoundingBox
from topo.base.cf import CFSheet,CFProjection,CFPOF_Plugin
from topo.base.functionfamilies import LearningFn
from topo.base.parameterclasses import DynamicNumber
from topo.learningfns.projfns import CFPLF_Plugin
from topo.learningfns.basic import Hebbian
from topo.outputfns.basic import PiecewiseLinear
from topo.responsefns.optimized import CFPRF_DotProduct_opt
from topo.sheets.generatorsheet import GeneratorSheet
from topo.outputfns.basic import DivisiveNormalizeL1
from topo.misc.numbergenerators import UniformRandom

topo.sim.name = "tiny"


# Same as topo.base.connectionfield.Hebbian; copied here as a template
# for writing other LearningFns
class SampleHebbian(LearningFn):
    """
    Basic Hebbian rule; Dayan and Abbott, 2001, equation 8.3.

    Increases each weight in proportion to the product of this
    neuron's activity and the input activity.
    
    Requires some form of output_fn normalization for stability.
    """
    sample_param=Number(default=0.1,bounds=(0,None),doc="Example positive-valued numeric parameter")
    value_0=Number(default=0.8,bounds=(0,None),doc="Example initial value parameter.")

    def __init__(self,**params):
        super(SampleHebbian,self).__init__(**params)
        self.value=self.value_0
    
    def __call__(self,input_activity, unit_activity, weights, single_connection_learning_rate):
	"""
        Update the value of the given weights matrix based on the
        input_activity matrix (of the same size as the weights matrix)
        and the response of this unit (the unit_activity), governed by
        a per-connection learning rate.
	"""
        weights += single_connection_learning_rate * unit_activity * input_activity
        dummy_value = self.sample_param*self.value*unit_activity
        self.value = self.value*0.9

# Weight seed
RandomArray.seed(500,500)

# Input pattern
gaussian_generator = topo.patterns.basic.Gaussian(
    x=DynamicNumber(UniformRandom(lbound=-0.8,ubound=0.8,seed=12)),
    y=DynamicNumber(UniformRandom(lbound=-0.8,ubound=0.8,seed=34)),
    orientation=DynamicNumber(UniformRandom(lbound=-pi,ubound=pi,seed=56)),
    size = 2*0.3*1.5/7.0,
    aspect_ratio = 7.0/1.5,
    bounds = BoundingBox(radius=0.8))

# Sheets, connections, and their parameters
topo.sim['Retina'] = GeneratorSheet(input_generator=gaussian_generator,
                                    nominal_bounds=BoundingBox(radius=0.6),
                                    period=1.0,phase=0.25,nominal_density=24)

topo.sim['V1'] = CFSheet(nominal_density=5,nominal_bounds=BoundingBox(radius=0.5),
                         output_fn=PiecewiseLinear(lower_bound=0,upper_bound=1.0))

topo.sim.connect(
    'Retina','V1',name='RtoV1',delay=FixedPoint("0.25"),
    connection_type=CFProjection, 
    weights_generator=topo.patterns.random.UniformRandom(),
    nominal_bounds_template=BoundingBox(radius=0.2),
    response_fn=CFPRF_DotProduct_opt(),
    learning_fn=CFPLF_Plugin(single_cf_fn=SampleHebbian(sample_param=0.5)),
    weights_output_fn=CFPOF_Plugin(single_cf_fn=DivisiveNormalizeL1()),
    learning_rate=200.0)


    
    
