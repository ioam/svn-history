"""
Tiny example network useful for testing components.

$Id$
"""
__version__='$Revision$'

import RandomArray

from fixedpoint import FixedPoint

import topo.patterns.random
import topo.patterns.basic
 
from topo.base.parameterclasses import Number
from topo.base.boundingregion import BoundingBox
from topo.base.connectionfield import CFSheet,CFProjection,CFProjectionGenericOutputFn
from topo.base.connectionfield import LearningFn
from topo.base.parameterclasses import DynamicNumber
from topo.base.simulator import Simulator
from topo.learningfns.projfns import CFProjectionGenericLearningFn
from topo.learningfns.basic import Hebbian
from topo.outputfns.basic import PiecewiseLinear
from topo.patterns import PatternGeneratorParameter
from topo.responsefns.optimized import CFProjectionDotProduct_opt1
from topo.sheets.generatorsheet import GeneratorSheet
from topo.outputfns.basic import DivisiveL1Normalize
from topo.misc.numbergenerators import RandomWrapper


# Same as topo.base.connectionfield.Hebbian; copied here as a template
# for writing other LearningFns
class SampleHebbian(LearningFn):
    """
    Basic Hebbian rule; Dayan and Abbott, 2001, equation 8.3.

    Increases each weight in proportion to the product of this
    neuron's activity and the input activity.
    
    Requires some form of output_fn normalization for stability.
    """
    sample_param=Number(default=0.1,bounds=(0,None),doc="Example positive-valued numeric parameter")
    value_0=Number(default=0.8,bounds=(0,None),doc="Example initial value parameter.")

    def __init__(self,**params):
        super(SampleHebbian,self).__init__(**params)
        self.value=self.value_0
    
    def __call__(self,input_activity, unit_activity, weights, single_connection_learning_rate):
	"""
        Update the value of the given weights matrix based on the
        input_activity matrix (of the same size as the weights matrix)
        and the response of this unit (the unit_activity), governed by
        a per-connection learning rate.
	"""
        weights += single_connection_learning_rate * unit_activity * input_activity
        dummy_value = self.sample_param*self.value*unit_activity
        self.value = self.value*0.9

# Weight seed
RandomArray.seed(500,500)

# Input pattern
gaussian_generator = topo.patterns.basic.Gaussian(
    x = DynamicNumber(RandomWrapper("uniform",-0.8,0.8,seed=12)),
    y = DynamicNumber(RandomWrapper("uniform",-0.8,0.8,seed=34)),
    orientation = DynamicNumber(RandomWrapper("uniform",-pi,pi,seed=56)),
    size = 2*0.3*1.5/7.0,
    aspect_ratio = 7.0/1.5,
    bounds = BoundingBox(radius=0.8))

# Sheets, connections, and their parameters
topo.sim['Retina'] = GeneratorSheet(input_generator=gaussian_generator,
                                    bounds=BoundingBox(radius=0.6),
                                    period=1.0,density=24)

topo.sim['V1'] = CFSheet(density=5,bounds=BoundingBox(radius=0.5),
                         output_fn=PiecewiseLinear(lower_bound=0,upper_bound=1.0))

topo.sim.connect2(
    'Retina','V1',name='RtoV1',delay=FixedPoint("0.5"),
    connection_type=CFProjection, 
    weights_generator=topo.patterns.random.UniformRandom(),
    weights_bounds=BoundingBox(radius=0.2),
    response_fn=CFProjectionDotProduct_opt1(),
    learning_fn=CFProjectionGenericLearningFn(single_cf_fn=SampleHebbian(sample_param=0.5)),
    weights_output_fn=CFProjectionGenericOutputFn(single_cf_fn=DivisiveL1Normalize()),
    learning_rate=200.0)


    
    
