"""
Tiny example network useful for testing components.

$Id$
"""
__version__='$Revision$'


import numpy

from topo import param

import topo.pattern.random
import topo.pattern.basic
 
from topo.base.boundingregion import BoundingBox
from topo.base.cf import CFSheet,CFProjection,CFPOF_Plugin
from topo.base.functionfamily import LearningFn
from topo.learningfn.projfn import CFPLF_Plugin
from topo.learningfn.basic import Hebbian
from topo.outputfn.basic import PiecewiseLinear
from topo.responsefn.optimized import CFPRF_DotProduct_opt
from topo.sheet import GeneratorSheet
from topo.outputfn.basic import DivisiveNormalizeL1
from topo.misc.numbergenerator import UniformRandom

from topo.misc.commandline import global_params
global_params.add(
    default_retina_density=param.Number(default=24,doc="""
    Default nominal_density for the retina."""),

    default_density=param.Number(default=5,doc="""
    Default nominal_density for V1."""))


# Same as topo.base.connectionfield.Hebbian; copied here as a template
# for writing other LearningFns
class SampleHebbian(LearningFn):
    """
    Basic Hebbian rule; Dayan and Abbott, 2001, equation 8.3.

    Increases each weight in proportion to the product of this
    neuron's activity and the input activity.
    
    Requires some form of output_fn normalization for stability.
    """
    sample_param=param.Number(default=0.1,bounds=(0,None),doc="Example positive-valued numeric parameter")
    value_0=param.Number(default=0.8,bounds=(0,None),doc="Example initial value parameter.")

    def __init__(self,**params):
        super(SampleHebbian,self).__init__(**params)
        self.value=self.value_0
        
    def __call__(self,input_activity, unit_activity, weights, single_connection_learning_rate):
	"""
        Update the value of the given weights matrix based on the
        input_activity matrix (of the same size as the weights matrix)
        and the response of this unit (the unit_activity), governed by
        a per-connection learning rate.
	"""
        weights += single_connection_learning_rate * unit_activity * input_activity
        dummy_value = self.sample_param*self.value*unit_activity
        self.value = self.value*0.9

# Input pattern
gaussian_generator = topo.pattern.basic.Gaussian(
    x=UniformRandom(lbound=-0.8,ubound=0.8,seed=12),
    y=UniformRandom(lbound=-0.8,ubound=0.8,seed=34),
    orientation=UniformRandom(lbound=-pi,ubound=pi,seed=56),
    size = 2*0.3*1.5/7.0,
    aspect_ratio = 7.0/1.5,
    bounds = BoundingBox(radius=0.8))

# Sheets, connections, and their parameters
topo.sim['Retina'] = GeneratorSheet(input_generator=gaussian_generator,
                                    nominal_bounds=BoundingBox(radius=0.6),
                                    period=1.0,phase=0.05,
                                    nominal_density=global_params.default_retina_density)

topo.sim['V1'] = CFSheet(nominal_density=global_params.default_density,
                         nominal_bounds=BoundingBox(radius=0.5),
                         output_fn=PiecewiseLinear(lower_bound=0,upper_bound=1.0))

topo.sim.connect(
    'Retina','V1',name='Afferent',delay=0.05,
    connection_type=CFProjection, 
    weights_generator=topo.pattern.random.UniformRandom(),
    nominal_bounds_template=BoundingBox(radius=0.2),
    response_fn=CFPRF_DotProduct_opt(),
    learning_fn=CFPLF_Plugin(single_cf_fn=SampleHebbian(sample_param=0.5)),
    weights_output_fn=CFPOF_Plugin(single_cf_fn=DivisiveNormalizeL1()),
    learning_rate=200.0)
