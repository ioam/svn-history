"""
Example of a LISSOM simulation set up to match the C++ lissom
simulator as closely as possible.

$Id$
"""

import random
import fixedpoint
#import pdb # debugger

from math import pi
from itertools import chain
from fixedpoint import FixedPoint  # Should probably bring this into Simulator namespace

from topo.sheets.lissom import LISSOM
from topo.sheets.generatorsheet import GeneratorSheet
from topo.projections.kernelprojection import KernelProjection
from topo.patterns.basic import GaussianGenerator
from topo.base.sheet import BoundingBox
from topo.base.parameter import Dynamic
from topo.responsefns.basic import CFDotProduct


###########################################
# Set parameters

# Temporary variables designed to match the C++ version of lissom
BaseN=72.0
BaseRN=24.0
area_scale=1.0
num_eyes=1
rf_radius=BaseRN/4.0+0.5
inh_rad=max(2.0,(BaseN/4.0-1.5)+0.5)
exc_rad=max(2.0,(BaseN/10.0-0.5)+0.5)
default_afferent_size_scale=BaseN/BaseRN
gammaexc=0.9
gammainh=0.9
#min_exc_rad=max(1,BaseN/44+0.5)

rf_radius_scale=6.0/rf_radius
#retina_area_scale=(BaseRN*area_scale/24.0*rf_radius_scale)*(BaseRN*area_scale/24.0*rf_radius_scale)
#inputs_pereye=max(retina_area_scale,1)
#uncorrelation=0.0 
xsigma=6.0*rf_radius_scale
ysigma=1.5*rf_radius_scale

#scale_input=1.0
retina_edge_buffer=0*(rf_radius+(BaseRN*area_scale/2))
RN=BaseRN*area_scale+2*retina_edge_buffer

acs=6.5*6.5/rf_radius/rf_radius
ecs=19.5*19.5/exc_rad/exc_rad
ics=47.5*47.5/inh_rad/inh_rad

alpha_input=0.007*acs
alpha_exc=0.002*ecs
alpha_inh=0.00025*ics

# Number of decimal places for simulator time
fixedpoint.DEFAULT_PRECISION=3

# input generation params
GeneratorSheet.density = RN
GeneratorSheet.period = 1

GaussianGenerator.x = Dynamic(lambda : random.uniform(-0.5,0.5))
GaussianGenerator.y = Dynamic(lambda : random.uniform(-0.5,0.5))

GaussianGenerator.theta = Dynamic(lambda :random.uniform(-pi,pi))
GaussianGenerator.width = xsigma/RN
GaussianGenerator.height = ysigma/RN
GaussianGenerator.bounds = BoundingBox(points=((-0.5,-0.5),(0.5,0.5)))


# lissom parameters
LISSOM.density = BaseN

# Connection parameters
afferent_weight_bounds   = BoundingBox(points=((-rf_radius/RN,-rf_radius/RN),(rf_radius/RN,rf_radius/RN)))
excitatory_weight_bounds = BoundingBox(points=((-exc_rad/BaseN,-exc_rad/BaseN),(exc_rad/BaseN,exc_rad/BaseN)))
inhibitory_weight_bounds = BoundingBox(points=((-inh_rad/BaseN,-inh_rad/BaseN),(inh_rad/BaseN,inh_rad/BaseN)))


###########################################
# build simulation

s = topo.base.simulator.Simulator()

retina = GeneratorSheet(input_generator=GaussianGenerator(),name='Retina')
V1 = LISSOM(name='V1')

s.connect(retina,V1, delay = FixedPoint("0.05"),
          projection_type=KernelProjection,
          projection_params = dict(strength = 1.0, name='Afferent0',
                                   weights_bounds = afferent_weight_bounds, normalize = True, response_fn=CFDotProduct(),learning_rate=alpha_input))


s.connect(V1,V1, delay = FixedPoint("0.05"), dest_port="exc",
          projection_type=KernelProjection,
          projection_params = dict(strength = gammaexc, name='LateralExcitatory',
                                   weights_bounds = excitatory_weight_bounds, normalize = True, response_fn=CFDotProduct(),learning_rate=alpha_exc))

s.connect(V1,V1, delay = FixedPoint("0.05"), dest_port="inh",
          projection_type=KernelProjection,
          projection_params = dict(strength = -gammainh, name='LateralInhibitory',
                                   weights_bounds = inhibitory_weight_bounds, normalize = True, response_fn=CFDotProduct(),learning_rate=alpha_inh))
        

#################################################
# Schedule the changes of simulation parameters

s.schedule_action(200, V1.reduce_cfsize, "LateralExcitatory", BoundingBox(points=((-exc_rad*0.6/BaseN,-exc_rad*0.6/BaseN),(exc_rad*0.6/BaseN,exc_rad*0.6/BaseN))))

s.schedule_action(500, V1.reduce_cfsize, "LateralExcitatory", BoundingBox(points=((-exc_rad*0.42/BaseN,-exc_rad*0.42/BaseN),(exc_rad*0.42/BaseN,exc_rad*0.42/BaseN))))

s.schedule_action(1000, V1.reduce_cfsize, "LateralExcitatory", BoundingBox(points=((-exc_rad*0.336/BaseN,-exc_rad*0.336/BaseN),(exc_rad*0.336/BaseN,exc_rad*0.336/BaseN))))

s.schedule_action(2000, V1.reduce_cfsize, "LateralExcitatory", BoundingBox(points=((-2.0/BaseN,-2.0/BaseN),(2.0/BaseN,2.0/BaseN))))

s.schedule_action(500, V1.change_learning_rate, "Afferent0", 0.005*acs)
s.schedule_action(2000, V1.change_learning_rate, "Afferent0", 0.004*acs)
s.schedule_action(4000, V1.change_learning_rate, "Afferent0", 0.003*acs)
s.schedule_action(20000, V1.change_learning_rate, "Afferent0", 0.0015*acs)

s.schedule_action(500, V1.change_learning_rate, "LateralExcitatory", 0.001*ecs)


#function that set delta and beta for the threshold function
def set_deltabeta(x,y):
    V1.output_fn.lower_bound=x
    V1.output_fn.upper_bound=y

s.schedule_action(200,   set_deltabeta, 0.11, 0.66)
s.schedule_action(500,   set_deltabeta, 0.12, 0.67)
s.schedule_action(1000,  set_deltabeta, 0.15, 0.68)
s.schedule_action(2000,  set_deltabeta, 0.18, 0.70)
s.schedule_action(3000,  set_deltabeta, 0.20, 0.73)
s.schedule_action(4000,  set_deltabeta, 0.20, 0.76)
s.schedule_action(5000,  set_deltabeta, 0.21, 0.79)
s.schedule_action(6500,  set_deltabeta, 0.22, 0.82)
s.schedule_action(8000,  set_deltabeta, 0.23, 0.85)
s.schedule_action(20000, set_deltabeta, 0.24, 0.88)

# can either pass a number or FixedPoint object to s.run()
#s.run(10)
#s.run(FixedPoint(10))


# Set up performance profiling
#import hotshot,hotshot.stats
#prof = hotshot.Profile("abc")
#prof.runctx('s.run(50)',globals(),locals())
#prof.close()
#
#p = hotshot.stats.load("abc")
#p.strip_dirs().sort_stats('time').print_stats()
#
#import profile,pstats
#profile.runctx('s.run(2000)',globals(),locals(),"abc")
#p = pstats.Stats('abc')
#p.strip_dirs().sort_stats('cumulative').print_stats()
