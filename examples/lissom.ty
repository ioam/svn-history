#  
#

from math import pi
from itertools import chain
import random
import pdb #debugger


from topo import *
from topo.kernelfactory import *
from topo.inputsheet import *
from topo.image import ImageSaver
import topo.gui
import topo.cfsheet
from topo.params import *


from topo.utils import msum
"""
TODO:

x boundingregion.translate()
- composing kernel factories (operator overloading?)

x LISSOM learning rule (just mdot)
x xfer funcs  (piecewise linear sigmoid)

- port parameterization (in cfsheet? in sheet? in EventProcessor?)
"""



class LISSOM(topo.cfsheet.CFSheet):

    transfer_fn = Parameter(default=utils.PLTF)

# Temporarily disabled learning for comparison with C++ lissom implementation
#   learning_rate = Parameter(default=0.1) 
    learning_rate = Parameter(default=0.0)


    def input_event(self,src,src_port,dest_port,data):

        # On a new afferent input, clear the activation
        if dest_port == 'afferent':
            print "clear"
            self.activation *= 0.0
        super(LISSOM,self).input_event(src,src_port,dest_port,data)



    def learn(self):

        pass
#        rows,cols = self.activation.shape
#        for proj in chain(*self.projections.values()):
#            if proj.input_buffer:
#                for r in range(rows):
#                    for c in range(cols):
#                        cf = proj.cf(r,c)
#                        cf.weights += (self.learning_rate * self.activation[r,c]
#                                       * cf.get_input_matrix(proj.input_buffer))
#
#
#        
#        # normalize weights
#        lateral = self.lateral_projections()
#        afferent = self.afferent_projections()
#                                             
#        for r in range(rows):
#            for c in range(cols):
#                for group in (lateral,afferent):
#                    # Uncomment for normalization over whole group (lateral, afferent)
#                    # k = sum([sum(p.cf(r,c).weights.flat)
#                    #          for p in group])
#                    for p in group:
#                        # Uncomment for normalization per projection
#                        k = sum(p.cf(r,c).weights.flat)
#                        p.cf(r,c).weights /= k

    def lateral_projections(self):
        return [p for p in chain(*self.projections.values()) if p.src is self]
    def afferent_projections(self):
        return [p for p in chain(*self.projections.values()) if p.src is not self]


###########################################
# Set parameters



# Temporary variables designed to match the C++ version of lissom
BaseN=30.0
BaseRN=30.0
area_scale=1.0
num_eyes=1
rf_radius=BaseRN/4.0+0.5
inh_rad=max(2.0,(BaseN/4.0-1.5)+0.5)
exc_rad=max(2.0,(BaseN/10.0-0.5)+0.5)
default_afferent_size_scale=BaseN/BaseRN
gammaexc=0.9
gammainh=0.9
#delta=0
#beta=1
#min_exc_rad=max(1,BaseN/44+0.5)

rf_radius_scale=6.0/rf_radius
#retina_area_scale=(BaseRN*area_scale/24.0*rf_radius_scale)*(BaseRN*area_scale/24.0*rf_radius_scale)
#inputs_pereye=max(retina_area_scale,1)
#uncorrelation=0.0 
xsigma=6.0/rf_radius_scale
ysigma=1.5/rf_radius_scale

#scale_input=1.0
retina_edge_buffer=0*(rf_radius+(BaseRN*area_scale/2))
RN=BaseRN*area_scale+2*retina_edge_buffer

#acs=6.5*6.5/rf_radius/rf_radius
#ecs=19.5*19.5/exc_rad/exc_rad
#ics=47.5*47.5/inh_rad/inh_rad
#
#alpha_input=0.0
#alpha_exc=0.0
#alpha_inh=0.0
#
tsettle=8



print "Setting parameters..."


# input generation params
# jbednar050411: Doesn't seem to work with anything but 900 for both densities (!)
InputSheet.density = RN*RN
InputSheet.period = 1

GaussianFactory.x = Dynamic(lambda : random.uniform(-0.5,0.5))
GaussianFactory.y = Dynamic(lambda : random.uniform(-0.5,0.5))

GaussianFactory.theta = Dynamic(lambda :random.uniform(-pi,pi))
GaussianFactory.width = xsigma/RN
GaussianFactory.height = ysigma/RN
GaussianFactory.bounds = BoundingBox(points=((-0.5,-0.5),(0.5,0.5)))


# lissom parameters
LISSOM.density = BaseN*BaseN


# image saver parameters
ImageSaver.file_format='png'
ImageSaver.time_format='%0.4d'

# Connection parameters
afferent_weight_bounds   = BoundingBox(points=((-rf_radius/RN,-rf_radius/RN),(rf_radius/RN,rf_radius/RN)))
excitatory_weight_bounds = BoundingBox(points=((-exc_rad/BaseN,-exc_rad/BaseN),(exc_rad/BaseN,exc_rad/BaseN)))
inhibitory_weight_bounds = BoundingBox(points=((-inh_rad/BaseN,-inh_rad/BaseN),(inh_rad/BaseN,inh_rad/BaseN)))
###########################################
# build simulation


print "Creating simulation objects..."
s = topo.simulator.Simulator()


retina = InputSheet(input_generator=GaussianFactory(),name='Retina')
V1 = LISSOM(name='V1')
save  = ImageSaver(name='LISSOM')

s.connect(retina,V1, delay = 0.5/tsettle,
          projection_params = dict(strength = 1.0, name='Afferent0',
                                   weights_bounds = afferent_weight_bounds, normalize = 1))

s.connect(V1,V1, delay = 1.0/tsettle, dest_port="exc",
          projection_params = dict(strength = gammaexc, name='LateralExcitatory',
                                   weights_bounds = excitatory_weight_bounds, normalize = 1))

s.connect(V1,V1, delay = 1.0/tsettle, dest_port="inh",
          projection_params = dict(strength = -gammainh, name='LateralInhibitory',
                                   weights_bounds = inhibitory_weight_bounds, normalize = 1))
        

#cfsheet.CF.print_level = base.VERBOSE


# Uncomment the connections to the image saver, to save all the activation
# images to disk.
#s.connect(retina,save,dest_port='retina',delay=2)
#s.connect(V1,save,dest_port='V1',delay=1)

#s.run(100)

#V1.projections['Retina'][0].plot_cfs()

#import hotshot,hotshot.stats
#prof = hotshot.Profile("abc")
#prof.runctx('s.run(50)',globals(),locals())
#prof.close()
#
#p = hotshot.stats.load("abc")
#p.strip_dirs().sort_stats('time').print_stats()



#import profile,pstats
#profile.runctx('s.run(3)',globals(),locals(),"abc")
#p = pstats.Stats('abc')
#p.strip_dirs().sort_stats(-1).print_stats()
