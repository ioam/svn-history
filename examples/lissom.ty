#  
#

from math import pi
from itertools import chain
import random
import pdb #debugger


from topo import *
from topo.kernelfactory import *
from topo.inputsheet import *
from topo.image import ImageSaver
import topo.gui
import topo.cfsheet
from topo.params import *
import weave
import Numeric


from topo.utils import msum
"""
TODO:

x boundingregion.translate()
- composing kernel factories (operator overloading?)

x LISSOM learning rule (just mdot)
x xfer funcs  (piecewise linear sigmoid)

- port parameterization (in cfsheet? in sheet? in EventProcessor?)
"""



class LISSOM(topo.cfsheet.CFSheet):

    transfer_fn = Parameter(default=utils.PLTF)

# Temporarily disabled learning for comparison with C++ lissom implementation
    learning_rate = Parameter(default=0.1) 
#    learning_rate = Parameter(default=0.0)

    # modify weights after each activation?
    continuous_learning = Parameter(default=False)

    presleep_count = 0

    def input_event(self,src,src_port,dest_port,data):
        # On a new afferent input, clear the activation
        if src.name == 'Retina':
            self.activation *= 0.0
            for name in self.projections:
                for proj in self.projections[name]:
                    proj.temp_activation *= 0.0

        super(LISSOM,self).input_event(src,src_port,dest_port,data)

    def pre_sleep(self):
        """
        Pass the accumulated stimulation through self.transfer_fn and
        send it out on the default output port.
        """

        if self.new_input:
            self.new_input = False
            self.temp_activation *= 0.0
            for name in self.projections:
                for proj in self.projections[name]:
                    self.temp_activation += proj.temp_activation
            self.activation = self.transfer_fn(self.temp_activation)
            self.send_output(data=self.activation)

        if self._learning:
            if self.continuous_learning:
                self.learn()
            else:
                self.presleep_count += 1
                if self.presleep_count == tsettle+1:
                    self.presleep_count = 0
                    self.learn()
                    


    def learn(self):
        rows,cols = self.activation.shape
        alpha = self.learning_rate
        X = self.activation

        learn_code = """
            double *wi, *wj, *x, *inpi, *inpj;
            int *slice;
            int rr1, rr2, cc1, cc2, rc;
            int i, j, r, l;
            PyObject *cf, *cfsr;
            PyObject *sarray = PyString_FromString("slice_array");
            PyObject *weights = PyString_FromString("weights");
            double load, delta;
            double totald;

            x = X;
            for (r=0; r<rows; ++r) {
                cfsr = PyList_GetItem(cfs,r);
                for (l=0; l<cols; ++l) {
                    load = *x++;
                    if (load != 0) {
                        load *= alpha;

                        cf = PyList_GetItem(cfsr,l);
                        wi = (double *)(((PyArrayObject*)PyObject_GetAttr(cf,weights))->data);
                        wj = wi;
                        slice = (int *)(((PyArrayObject*)PyObject_GetAttr(cf,sarray))->data);
                        rr1 = *slice++;
                        rr2 = *slice++;
                        cc1 = *slice++;
                        cc2 = *slice;

                        totald = 0.0;

                        inpj = inp+len*rr1+cc1;
                        for (i=rr1; i<rr2; ++i) {
                            inpi = inpj;
                            for (j=cc1; j<cc2; ++j) {
                                delta = load * *inpi;
                                *wi += delta;
                                totald += delta;
                                ++wi;
                                ++inpi;
                            }
                            inpj += len;
                        }

                        if (normalize) {
                            totald += normalize; 
                            totald = 1.0/totald;
                            rc = (rr2-rr1)*(cc2-cc1);

                            for (i=0; i<rc; ++i) {
                                *wj *= totald;
                                ++wj;
                            }
                        }
                    }
                }
            }
        """

        for proj in chain(*self.projections.values()):
            if proj.input_buffer:
                if proj.src == self: #lateral connection
                    inp = self.activation
                else:
                    inp = proj.input_buffer
                cfs = proj.cfs
                len, len2 = inp.shape
                normalize = proj.normalize
                weave.inline(learn_code, ['rows', 'cols', 'cfs', 'alpha', 'inp', 'X', 'len', 'normalize'])


    # Python version of the learn function, the flow is a little different
    # from the C version
    def learn_py(self):
        rows,cols = self.activation.shape
        for proj in chain(*self.projections.values()):
            if proj.input_buffer:
                for r in range(rows):
                    for c in range(cols):
                        cf = proj.cf(r,c)
                        cf.weights += (self.learning_rate * self.activation[r,c]
                                       * cf.get_input_matrix(proj.input_buffer))


        
        # normalize weights
        lateral = self.lateral_projections()
        afferent = self.afferent_projections()
                                             
        for r in range(rows):
            for c in range(cols):
                for group in (lateral,afferent):
                    # Uncomment for normalization over whole group (lateral, afferent)
                    # k = sum([sum(p.cf(r,c).weights.flat)
                    #          for p in group])
                    for p in group:
                        # Uncomment for normalization per projection
                        k = sum(p.cf(r,c).weights.flat)
                        p.cf(r,c).weights /= k

    def lateral_projections(self):
        return [p for p in chain(*self.projections.values()) if p.src is self]
    def afferent_projections(self):
        return [p for p in chain(*self.projections.values()) if p.src is not self]


###########################################
# Set parameters



# Temporary variables designed to match the C++ version of lissom
BaseN=30.0
BaseRN=30.0
area_scale=1.0
num_eyes=1
rf_radius=BaseRN/4.0+0.5
inh_rad=max(2.0,(BaseN/4.0-1.5)+0.5)
exc_rad=max(2.0,(BaseN/10.0-0.5)+0.5)
default_afferent_size_scale=BaseN/BaseRN
gammaexc=0.9
gammainh=0.9
#delta=0
#beta=1
#min_exc_rad=max(1,BaseN/44+0.5)

rf_radius_scale=6.0/rf_radius
#retina_area_scale=(BaseRN*area_scale/24.0*rf_radius_scale)*(BaseRN*area_scale/24.0*rf_radius_scale)
#inputs_pereye=max(retina_area_scale,1)
#uncorrelation=0.0 
xsigma=6.0/rf_radius_scale
ysigma=1.5/rf_radius_scale

#scale_input=1.0
retina_edge_buffer=0*(rf_radius+(BaseRN*area_scale/2))
RN=BaseRN*area_scale+2*retina_edge_buffer

#acs=6.5*6.5/rf_radius/rf_radius
#ecs=19.5*19.5/exc_rad/exc_rad
#ics=47.5*47.5/inh_rad/inh_rad
#
#alpha_input=0.0
#alpha_exc=0.0
#alpha_inh=0.0
#
tsettle=8



print "Setting parameters..."


# input generation params
# jbednar050411: Doesn't seem to work with anything but 900 for both densities (!)
InputSheet.density = RN*RN
InputSheet.period = 1

GaussianFactory.x = Dynamic(lambda : random.uniform(-0.5,0.5))
GaussianFactory.y = Dynamic(lambda : random.uniform(-0.5,0.5))

GaussianFactory.theta = Dynamic(lambda :random.uniform(-pi,pi))
GaussianFactory.width = xsigma/RN
GaussianFactory.height = ysigma/RN
GaussianFactory.bounds = BoundingBox(points=((-0.5,-0.5),(0.5,0.5)))


# lissom parameters
LISSOM.density = BaseN*BaseN


# image saver parameters
ImageSaver.file_format='png'
ImageSaver.time_format='%0.4d'

# Connection parameters
afferent_weight_bounds   = BoundingBox(points=((-rf_radius/RN,-rf_radius/RN),(rf_radius/RN,rf_radius/RN)))
excitatory_weight_bounds = BoundingBox(points=((-exc_rad/BaseN,-exc_rad/BaseN),(exc_rad/BaseN,exc_rad/BaseN)))
inhibitory_weight_bounds = BoundingBox(points=((-inh_rad/BaseN,-inh_rad/BaseN),(inh_rad/BaseN,inh_rad/BaseN)))
###########################################
# build simulation


print "Creating simulation objects..."

s = topo.simulator.Simulator()

retina = InputSheet(input_generator=GaussianFactory(),name='Retina')
V1 = LISSOM(name='V1')
save  = ImageSaver(name='LISSOM')

s.connect(retina,V1, delay = 0.5/tsettle,
          projection_params = dict(strength = 1.0, name='Afferent0',
                                   weights_bounds = afferent_weight_bounds, normalize = 1))


s.connect(V1,V1, delay = 1.0/tsettle, dest_port="exc",
          projection_params = dict(strength = gammaexc, name='LateralExcitatory',
                                   weights_bounds = excitatory_weight_bounds, normalize = 1))

s.connect(V1,V1, delay = 1.0/tsettle, dest_port="inh",
          projection_params = dict(strength = -gammainh, name='LateralInhibitory',
                                   weights_bounds = inhibitory_weight_bounds, normalize = 1))
        

#cfsheet.CF.print_level = base.VERBOSE


# Uncomment the connections to the image saver, to save all the activation
# images to disk.
#s.connect(retina,save,dest_port='retina',delay=2)
#s.connect(V1,save,dest_port='V1',delay=1)

#s.run(200)

#V1.projections['Retina'][0].plot_cfs()

#import hotshot,hotshot.stats
#prof = hotshot.Profile("abc")
#prof.runctx('s.run(50)',globals(),locals())
#prof.close()
#
#p = hotshot.stats.load("abc")
#p.strip_dirs().sort_stats('time').print_stats()



#import profile,pstats
#profile.runctx('s.run(200)',globals(),locals(),"abc")
#p = pstats.Stats('abc')
#p.strip_dirs().sort_stats('cumulative').print_stats()
