from math import pi
from itertools import chain
import random
import pdb #debugger


from topo import *
from topo.kernelfactory import *
from topo.inputsheet import *
from topo.image import ImageSaver
import topo.gui
import topo.rfsheet
from topo.params import *


from topo.utils import msum
"""
TODO:

x boundingregion.translate()
- composing kernel factories (operator overloading?)

x LISSOM learning rule (just mdot)
x xfer funcs  (piecewise linear sigmoid)

- port parameterization (in rfsheet? in sheet? in EventProcessor?)
"""



class LISSOM(topo.rfsheet.RFSheet):

    transfer_fn = Parameter(default=utils.PLTF)
    learning_rate = Parameter(default=0.1)


    def input_event(self,src,src_port,dest_port,data):

        # On a new afferent input, clear the activation
        if dest_port == 'afferent':
            self.activation *= 0.0
        super(LISSOM,self).input_event(src,src_port,dest_port,data)



    def train(self):

        rows,cols = self.activation.shape
        for proj in chain(*self.projections.values()):
            if proj.input_buffer:
                for r in range(rows):
                    for c in range(cols):
                        rf = proj.rf(r,c)
                        rf.weights += (self.learning_rate * self.activation[r,c]
                                       * rf.get_input_matrix(proj.input_buffer))


        
        # normalize weights
        lateral = self.lateral_projections()
        afferent = self.afferent_projections()
                                             
        for r in range(rows):
            for c in range(cols):
                for group in (lateral,afferent):
                    # Uncomment for normalization over whole group (lateral, afferent)
                    # k = sum([sum(p.rf(r,c).weights.flat)
                    #          for p in group])
                    for p in group:
                        # Uncomment for normalization per projection
                        k = sum(p.rf(r,c).weights.flat)
                        p.rf(r,c).weights /= k

    def lateral_projections(self):
        return [p for p in chain(*self.projections.values()) if p.src is self]
    def afferent_projections(self):
        return [p for p in chain(*self.projections.values()) if p.src is not self]


###########################################
# Set parameters

print "Setting parameters..."


# input generation params
InputSheet.period = 1.0
InputSheet.density = 900
InputSheet.period = 10

FuzzyLineFactory.x = Dynamic(lambda : random.uniform(-0.5,0.5))
FuzzyLineFactory.y = Dynamic(lambda : random.uniform(-0.5,0.5))

FuzzyLineFactory.theta = Dynamic(lambda :random.uniform(-pi,pi))
FuzzyLineFactory.width = 0.02
FuzzyLineFactory.bounds = BoundingBox(points=((-0.8,-0.8),(0.8,0.8)))


# lissom parameters
LISSOM.density = 900


# image saver parameters
ImageSaver.file_format='png'
ImageSaver.time_format='%0.4d'

# lateral connection parameters
inhibitory_weight_bounds = BoundingBox(points=((-0.2,-0.2),(0.2,0.2)))
excitatory_weight_bounds = BoundingBox(points=((-0.1,-0.1),(0.1,0.1)))


###########################################
# build simulation


print "Creating simulation objects..."
s = topo.simulator.Simulator()


retina = InputSheet(input_generator=FuzzyLineFactory(),name='Retina')
V1 = LISSOM(name='V1')
save  = ImageSaver(name='RFSOM')

s.connect(retina,V1,delay=1)
s.connect(V1,V1, delay=1,
          projection_params = dict(strength = 0.9,
                                   weights_bounds = excitatory_weight_bounds))
s.connect(V1,V1, delay = 1,
          projection_params = dict(strength = -0.9,
                                   weights_bounds = inhibitory_weight_bounds))
        

#rfsheet.RF.print_level = base.VERBOSE


# Uncomment the connections to the image saver, to save all the activation
# images to disk.
#s.connect(retina,save,dest_port='retina',delay=2)
#s.connect(V1,save,dest_port='V1',delay=1)

#s.run(20)

#V1.projections['Retina'][0].plot_rfs()

# import profile,pstats
#
# p = profile.Profile()
# p.runctx('s.run(10)',locals(),globals())

                
