"""
GC-ALISSOM

Work in progress on an improved version of the LISSOM orientation map
simulation from figure 5.9 of Miikkulainen, Bednar, Choe, and Sirosh
(2005), Computational Maps in the Visual Cortex, Springer.  Important
differences include:

 - Using divisive normalization to the LGN to provide contrast gain control (GC)
   and contrast-invariant tuning
 - Using homeostatic adaptation (A) rather than manual threshold adjustment,
   to avoid the need for most parameter adjustment and to be more robust
 - Using a fixed lateral excitatory radius rather than shrinking it
   (now that homeostatic plasticity allows all neurons to develop robustly) 

$Id: lissom_oo_or.ty 9831 2009-01-25 16:34:35Z ceball $
"""
__version__='$Revision: 9831 $'


from math import pi, sqrt
import numpy

from topo import learningfn,numbergen,transferfn,param,pattern,projection,responsefn,sheet

import topo.learningfn.optimized
import topo.learningfn.projfn 
import topo.transferfn.optimized 
import topo.pattern.random
import topo.responsefn.optimized 
import topo.sheet.lissom
import topo.sheet.optimized

# ALERT: Need to eliminate these imports
from contrib.jacommands import SimpleHomeoLinearRelative, AddGC, ActivityHysteresis
from contrib.jsldefs import JointScaling_lronly, JointScaling_affonly, homeostatic_analysis_function

###############################################################
####Different input types which can be used for development###
dataset=locals().get('dataset',"Gaussian") #set the input type by choosing the dataset parameter 

if dataset=="Gaussian":
    input_type=pattern.Gaussian
    num_inputs=locals().get('num_inputs',2) #in the case where dataset=pattern.Gaussian, must also set the number of pattern.Gaussians per iteration, default is 2
    inputs=[input_type(x=numbergen.UniformRandom(lbound=-0.75,ubound=0.75,seed=12+i),
                       y=numbergen.UniformRandom(lbound=-0.75,ubound=0.75,seed=35+i),
                       orientation=numbergen.UniformRandom(lbound=-pi,ubound=pi,seed=21+i),
                       size=0.088388, aspect_ratio=4.66667, scale= locals().get('scale', 1.0), bounds=sheet.BoundingBox(radius=1.125))
            #Set the contrast of the gaussian patterns by setting the scale parameter.
            for i in xrange(num_inputs)]
    
    combined_inputs = pattern.SeparatedComposite(min_separation=0,generators=inputs)
    
elif dataset=="Natural":
    
    input_type=pattern.image.FileImage
    image_filenames=["images/shouval/combined%02d.png"%(i+1) for i in xrange(25)]
    inputs=[input_type(filename=f,
                       size=10.0,  #size_normalization='original',(size=10.0)
                       x=numbergen.UniformRandom(lbound=-0.75,ubound=0.75,seed=12),
                       y=numbergen.UniformRandom(lbound=-0.75,ubound=0.75,seed=36),
                       orientation=numbergen.UniformRandom(lbound=-pi,ubound=pi,seed=65))
        for f in image_filenames]

    combined_inputs =pattern.Selector(generators=inputs)

#Sheet coordinates of units to track for debugging
units=locals().get('units',[(0.0, 0.0), (0.25,0.25), (0.49,0.49)])
default_density = locals().get('cortex_density',48)
default_retinal_density = locals().get('retina_density',default_density/2)
  
#Smoothing value for exponential averaging
smoothing=locals().get('smoothing',0.999)
V1_smoothing=locals().get('V1_smoothing',0.999) # Allows different smoothing for averaging  V1 activity and averaging afferent activity.

#Output functions: Sheets
LGN_on_output_fn=transferfn.HalfRectify()
LGN_off_output_fn=transferfn.HalfRectify()

# The ratio between the input and ouptut of the V1 neurons
io_ratio=locals().get('io_ratio',3.6) 

V1_OF=HE=SimpleHomeoLinearRelative(smoothing=V1_smoothing,eta=locals().get('eta',0.001), input_output_ratio=io_ratio,t_init=0.15)

# Specify weight initialization, response function, and learning function
projection.CFProjection.cf_shape = pattern.Disk(smoothing=0.0)
projection.CFProjection.weights_generator = pattern.Constant()
projection.CFProjection.response_fn=responsefn.optimized.CFPRF_DotProduct_opt()
projection.CFProjection.learning_fn=learningfn.optimized.CFPLF_Hebbian_opt()
projection.CFProjection.weights_output_fn=transferfn.optimized.CFPOF_DivisiveNormalizeL1_opt()
projection.SharedWeightCFProjection.response_fn=responsefn.optimized.CFPRF_DotProduct_opt()


# DoG weights for the LGN
centerg   = pattern.Gaussian(size=0.07385,aspect_ratio=1.0,output_fn=transferfn.DivisiveNormalizeL1())
surroundg = pattern.Gaussian(size=0.29540,aspect_ratio=1.0,output_fn=transferfn.DivisiveNormalizeL1())
    
on_weights  = pattern.Composite(generators=[centerg,surroundg],operator=numpy.subtract)
off_weights = pattern.Composite(generators=[surroundg,centerg],operator=numpy.subtract)

#Function for generating Gaussian random initial weights
def gauss_rand(size):
    return pattern.Composite(operator=numpy.multiply, 
                             generators=[pattern.Gaussian(aspect_ratio=1.0, size=size),
                                         pattern.random.UniformRandom()])

#Whether or not to use divisive weights normalization
norm=locals().get('norm',True)
pi=None if norm==True else \
    transferfn.optimized.CFPOF_Plugin(single_cf_fn=transferfn.IdentityTF())


###########################################
# build simulation

topo.sim['Retina']=sheet.GeneratorSheet(nominal_density=default_retinal_density,
    input_generator=combined_inputs, period=1.0, phase=0.05,
    nominal_bounds=sheet.BoundingBox(radius=0.5+0.25+0.375+0.5))

topo.sim['LGNOn']=sheet.lissom.LISSOM(nominal_density=default_retinal_density,
    nominal_bounds=sheet.BoundingBox(radius=0.5+0.25+0.5),
    output_fn=LGN_on_output_fn, tsettle=0, measure_maps=False)

topo.sim['LGNOff']=sheet.lissom.LISSOM(nominal_density=default_retinal_density,
    nominal_bounds=sheet.BoundingBox(radius=0.5+0.25+0.5),
    output_fn=LGN_off_output_fn, tsettle=0, measure_maps=False)

# Add the lateral connectivity to LGN
AddGC()

AH = ActivityHysteresis(time_constant=0.5) 
topo.sim['V1'] = sheet.lissom.JointScaling(nominal_density=default_density,
    tsettle=16, plastic=True, apply_scaling=False, smoothing=smoothing,
    nominal_bounds=sheet.BoundingBox(radius=0.5),
    output_fn=transferfn.PipelineTF(output_fns=[AH,V1_OF]))

#make sure that activity is reset at the beginning of iteration
topo.sim['V1'].beginning_of_iteration.append(AH.reset)

topo.sim.connect('Retina','LGNOn',delay=0.05,
    connection_type=projection.SharedWeightCFProjection,strength=locals().get('ret_strength',2.33),
    nominal_bounds_template=sheet.BoundingBox(radius=0.375),name='Afferent',
    weights_generator=on_weights)

topo.sim.connect('Retina','LGNOff',delay = 0.05,
    connection_type=projection.SharedWeightCFProjection,strength=locals().get('ret_strength',2.33),
    nominal_bounds_template=sheet.BoundingBox(radius=0.375),name='Afferent',
    weights_generator=off_weights)

topo.sim.connect('LGNOn','V1',delay=0.05, dest_port=('Activity','JointNormalize', 'Afferent'),
    connection_type=projection.CFProjection,
    learning_fn=learningfn.optimized.CFPLF_Scaled_opt(),
    strength=locals().get('aff_str',25.0),name='LGNOnAfferent',
    weights_generator=gauss_rand(size=2*0.27083),
    nominal_bounds_template=sheet.BoundingBox(radius=locals().get('V1_aff_BB',0.27083)),
    learning_rate=locals().get('aff_lr',2))
                     
topo.sim.connect('LGNOff','V1',delay=0.05, dest_port=('Activity','JointNormalize', 'Afferent'),
    connection_type=projection.CFProjection,
    learning_fn=learningfn.optimized.CFPLF_Scaled_opt(),
    strength=locals().get('aff_str',25.0),name='LGNOffAfferent',
    weights_generator=gauss_rand(size=2*0.27083),
    nominal_bounds_template=sheet.BoundingBox(radius=locals().get('V1_aff_BB',0.27083)),
    learning_rate=locals().get('aff_lr',2))

topo.sim.connect('V1','V1',delay=0.05,name='LateralExcitatory',
    connection_type=projection.CFProjection,
    strength=1.0*locals().get('exc_strength',2.5),
    weights_generator=pattern.Gaussian(aspect_ratio=1.0, size=0.05),
    nominal_bounds_template=sheet.BoundingBox(radius=0.104),learning_rate=locals().get('lat_exc_lr',0.0)) 

topo.sim.connect('V1','V1',delay=0.05,name='LateralInhibitory',
    connection_type=projection.CFProjection,
    strength=-1.0*locals().get('inh_strength',2.5),
    weights_generator=gauss_rand(size=0.15),
    nominal_bounds_template=sheet.BoundingBox(radius=0.22917),learning_rate=locals().get('lat_inh_lr',0.5))


# default locations for model editor
topo.sim.grid_layout([[None,    'V1',     None],
                      ['LGNOn', None,     'LGNOff'],
                      [None,    'Retina', None]], xstart=150)

import topo.analysis.featureresponses
topo.analysis.featureresponses.FeatureCurveCommand.selectivity_multiplier=1.0
topo.analysis.featureresponses.FeatureCurveCommand.num_orientation=64
topo.analysis.featureresponses.SinusoidalMeasureResponseCommand.num_phase=8
topo.analysis.featureresponses.FeatureCurveCommand.apply_output_fn=True
topo.analysis.featureresponses.FeatureCurveCommand.curve_parameters=[{"contrast":1},{"contrast":5},{"contrast":10},{"contrast":20},{"contrast":40},{"contrast":80},{"contrast":100}]
