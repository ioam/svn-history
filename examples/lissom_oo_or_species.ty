"""
LISSOM-based simulations of species differences in orientation maps.

Based on lissom_oo_or.ty r8223, but modified to model mouse when
species='mouse', and cat/monkey otherwise).  Work in progress as of
April 2008.

$Id$
"""
__version__='$Revision: 8223 $'


import numpy

from math import pi, sqrt

import topo.patterns.basic
import topo.patterns.random

from topo.patterns.basic import Gaussian
from topo.sheets.lissom import LISSOM
from topo.sheets.generatorsheet import GeneratorSheet
from topo.projections.basic import CFProjection, SharedWeightCFProjection
from topo.responsefns.optimized import CFPRF_DotProduct_opt
from topo.base.cf import CFSheet
from topo.base.boundingregion import BoundingBox
from topo.learningfns.optimized import CFPLF_Hebbian_opt
from topo.outputfn.optimized import CFPOF_DivisiveNormalizeL1_opt
from topo.outputfn.basic import PiecewiseLinear, DivisiveNormalizeL1
from topo.misc.numbergenerators import UniformRandom
from topo.coordmapperfns.basic import Jitter

# Set up scaling for specific species
# Very rough and incomplete -- e.g. msa should probably apply
# only to the buffer regions of the subcortical areas, not all of it,
# and the li_strength changes may not be necessary.
species = locals().get('species','mouse')
if species=='mouse':
    ms=3.0           # Larger afferent connection fields
    msa=2.0          # Larger subcortical areas 
    jitter_scale=locals().get('jitter_scale',0.5) # Large jitter in CF centers
    li_strength=-2.0 # Stronger inhibition to still produce some retinotopy
    num_inputs=1     # Input patterns are huge; can only fit one at a time
    v1_density=locals().get('default_density',10.0)
else:
    # Default parameters to match lissom_oo_or.ty:
    ms=1.0
    msa=1.0
    jitter_scale=0.0
    li_strength=-0.9
    num_inputs=2
    v1_density=locals().get('default_density',48.0)



input_type=Gaussian
inputs=[input_type(x=UniformRandom(lbound=-0.75,ubound=0.75,seed=12+i),
                   y=UniformRandom(lbound=-0.75,ubound=0.75,seed=34+i),
                   orientation=UniformRandom(lbound=-pi,ubound=pi,seed=56+i),
                   size=0.088388*ms, aspect_ratio=4.66667, scale=1.0,
                   bounds=BoundingBox(radius=0.8)) # JABALERT: What does this bounds do?
        for i in xrange(num_inputs)]

combined_inputs = topo.patterns.basic.SeparatedComposite(min_separation=2.2*0.27083,generators=inputs)
                                 
# Default for tutorial
topo.patterns.basic.Line.scale=0.9
topo.patterns.basic.Gaussian.size=0.08333
topo.patterns.basic.Gaussian.aspect_ratio=4.0

# Specify weight initialization, response function, and learning function
CFProjection.cf_shape = topo.patterns.basic.Disk(smoothing=0.0)
CFProjection.weights_generator = topo.patterns.basic.Constant()
CFProjection.response_fn=CFPRF_DotProduct_opt()
CFProjection.learning_fn=CFPLF_Hebbian_opt()
CFProjection.weights_output_fn=CFPOF_DivisiveNormalizeL1_opt()
SharedWeightCFProjection.response_fn=CFPRF_DotProduct_opt()




###########################################
# build simulation


topo.sim['Retina']=GeneratorSheet(nominal_density=locals().get('default_retina_density',24.0),
                                  input_generator=combined_inputs,
                                  period=1.0, phase=0.05,
                                  nominal_bounds=BoundingBox(radius=(0.5+0.25+0.375)*msa))

topo.sim['LGNOn']=CFSheet(nominal_density=24.0/ms,
                          nominal_bounds=BoundingBox(radius=(0.5+0.25)*msa),
                          output_fn=PiecewiseLinear(lower_bound=0.0,upper_bound=1.0),
                          measure_maps=False)

topo.sim['LGNOff']=CFSheet(nominal_density=24.0/ms,
                           nominal_bounds=BoundingBox(radius=(0.5+0.25)*msa),
                           output_fn=PiecewiseLinear(lower_bound=0.0,upper_bound=1.0),
                           measure_maps=False)

topo.sim['V1'] = LISSOM(nominal_density=v1_density,tsettle=9,
                        nominal_bounds=BoundingBox(radius=0.5))

topo.sim['V1'].output_fn.lower_bound=0.083
topo.sim['V1'].output_fn.upper_bound=0.633

# DoG weights for the LGN
centerg   = Gaussian(size=0.07385*ms,aspect_ratio=1.0,output_fn=DivisiveNormalizeL1())
surroundg = Gaussian(size=0.29540*ms,aspect_ratio=1.0,output_fn=DivisiveNormalizeL1())

on_weights = topo.patterns.basic.Composite(
    generators=[centerg,surroundg],operator=numpy.subtract)

off_weights = topo.patterns.basic.Composite(
    generators=[surroundg,centerg],operator=numpy.subtract)

#jitterOn  = Jitter(gen=NormalRandom(seed=1023, sigma=50))
#jitterOff = Jitter(gen=NormalRandom(seed=513,  sigma=50))
jitterOn = Jitter(gen =UniformRandom(seed=1023), scale=jitter_scale)
jitterOff = Jitter(gen =UniformRandom(seed=513), scale=jitter_scale)


topo.sim.connect('Retina','LGNOn',delay=0.05,
                 connection_type=SharedWeightCFProjection,strength=2.33,
                 nominal_bounds_template=BoundingBox(radius=0.375*ms),name='Afferent',
                 weights_generator=on_weights)

topo.sim.connect('Retina','LGNOff',delay = 0.05,
                 connection_type=SharedWeightCFProjection,strength=2.33,
                 nominal_bounds_template=BoundingBox(radius=0.375*ms),name='Afferent',
                 weights_generator=off_weights)

topo.sim.connect('LGNOn','V1',delay=0.05, dest_port=('Activity','JointNormalize', 'Afferent'),
                 coord_mapper=jitterOn,
                 connection_type=CFProjection,strength=1.0,name='LGNOnAfferent',
                 # JABALERT: Should probably simplify this by making a function for it.
                 weights_generator=topo.patterns.basic.Composite(operator=numpy.multiply, 
                                                                 generators=[Gaussian(aspect_ratio=1.0, size=2*0.27083*ms),
                                                                             topo.patterns.random.UniformRandom()]),
                 nominal_bounds_template=BoundingBox(radius=0.27083*ms),learning_rate=0.9590/2)

topo.sim.connect('LGNOff','V1',delay=0.05, dest_port=('Activity','JointNormalize', 'Afferent'),
                 coord_mapper=jitterOff,
                 connection_type=CFProjection,strength=1.0,name='LGNOffAfferent',
                 weights_generator=topo.patterns.basic.Composite(operator=numpy.multiply, 
                                                                 generators=[Gaussian(aspect_ratio=1.0, size=2*0.27083*ms),
                                                                             topo.patterns.random.UniformRandom()]),
                 nominal_bounds_template=BoundingBox(radius=0.27083*ms),learning_rate=0.9590/2)

topo.sim.connect('V1','V1',delay=0.05,name='LateralExcitatory',
                 connection_type=CFProjection,strength=0.9,
                 weights_generator=topo.patterns.basic.Composite(operator=numpy.multiply, 
                                                                 generators=[Gaussian(aspect_ratio=1.0, size=2*0.10417),
                                                                             topo.patterns.random.UniformRandom()]),
                 nominal_bounds_template=BoundingBox(radius=0.10417),learning_rate=2.55528) 
            
topo.sim.connect('V1','V1',delay=0.05,name='LateralInhibitory',
                 connection_type=CFProjection,strength=li_strength,
                 weights_generator=topo.patterns.basic.Composite(operator=numpy.multiply, 
                                                                 generators=[Gaussian(aspect_ratio=1.0, size=2*0.22917),
                                                                             topo.patterns.random.UniformRandom()]),
                 nominal_bounds_template=BoundingBox(radius=0.22917),learning_rate=1.80873)  



### Actions scheduled to occur as the simulation proceeds.#
topo.sim.startup_commands.append("from topo.base.boundingregion import BoundingBox")

# Convenience variable: timescale
st=1.0/num_inputs

### Lateral excitatory bounds changes
LE='topo.sim["V1"].projections()["LateralExcitatory"]'

topo.sim.schedule_command(  200*st,LE+'.change_bounds(BoundingBox(radius=0.06250))')
topo.sim.schedule_command(  500*st,LE+'.change_bounds(BoundingBox(radius=0.04375))')
topo.sim.schedule_command( 1000*st,LE+'.change_bounds(BoundingBox(radius=0.03500))')
topo.sim.schedule_command( 2000*st,LE+'.change_bounds(BoundingBox(radius=0.02800))')
topo.sim.schedule_command( 3000*st,LE+'.change_bounds(BoundingBox(radius=0.02240))')
topo.sim.schedule_command( 4000*st,LE+'.change_bounds(BoundingBox(radius=0.01344))')
topo.sim.schedule_command( 5000*st,LE+'.change_bounds(BoundingBox(radius=0.00806))')
topo.sim.schedule_command( 6500*st,LE+'.change_bounds(BoundingBox(radius=0.00484))')
topo.sim.schedule_command( 8000*st,LE+'.change_bounds(BoundingBox(radius=0.00290))')
topo.sim.schedule_command(20000*st,LE+'.change_bounds(BoundingBox(radius=0.00174))')

### Lateral excitatory learning rate changes
topo.sim.schedule_command(  200*st,LE+'.learning_rate=0.12168*'+LE+'.n_units()')
topo.sim.schedule_command(  500*st,LE+'.learning_rate=0.06084*'+LE+'.n_units()')
topo.sim.schedule_command( 1000*st,LE+'.learning_rate=0.06084*'+LE+'.n_units()')
topo.sim.schedule_command( 2000*st,LE+'.learning_rate=0.06084*'+LE+'.n_units()')
topo.sim.schedule_command( 3000*st,LE+'.learning_rate=0.06084*'+LE+'.n_units()')
topo.sim.schedule_command( 4000*st,LE+'.learning_rate=0.06084*'+LE+'.n_units()')
topo.sim.schedule_command( 5000*st,LE+'.learning_rate=0.06084*'+LE+'.n_units()')
topo.sim.schedule_command( 6500*st,LE+'.learning_rate=0.06084*'+LE+'.n_units()')
topo.sim.schedule_command( 8000*st,LE+'.learning_rate=0.06084*'+LE+'.n_units()')
topo.sim.schedule_command(20000*st,LE+'.learning_rate=0.06084*'+LE+'.n_units()')

### Afferent learning rate changes
ON ='topo.sim["V1"].projections()["LGNOnAfferent"]'
OFF='topo.sim["V1"].projections()["LGNOffAfferent"]'

topo.sim.schedule_command(  500*st,ON+'.learning_rate=0.6850/2;'+OFF+'.learning_rate=0.6850/2')
topo.sim.schedule_command( 2000*st,ON+'.learning_rate=0.5480/2;'+OFF+'.learning_rate=0.5480/2')
topo.sim.schedule_command( 4000*st,ON+'.learning_rate=0.4110/2;'+OFF+'.learning_rate=0.4110/2')
topo.sim.schedule_command(20000*st,ON+'.learning_rate=0.2055/2;'+OFF+'.learning_rate=0.2055/2')

### Activation function threshold changes
OF='topo.sim["V1"].output_fn'

topo.sim.schedule_command(  200*st,OF+'.lower_bound=0.093;'+OF+'.upper_bound=0.643')
topo.sim.schedule_command(  500*st,OF+'.lower_bound=0.103;'+OF+'.upper_bound=0.643')
topo.sim.schedule_command( 1000*st,OF+'.lower_bound=0.133;'+OF+'.upper_bound=0.663')
topo.sim.schedule_command( 2000*st,OF+'.lower_bound=0.163;'+OF+'.upper_bound=0.683')
topo.sim.schedule_command( 3000*st,OF+'.lower_bound=0.183;'+OF+'.upper_bound=0.713')
topo.sim.schedule_command( 4000*st,OF+'.lower_bound=0.183;'+OF+'.upper_bound=0.743')
topo.sim.schedule_command( 5000*st,OF+'.lower_bound=0.193;'+OF+'.upper_bound=0.773')
topo.sim.schedule_command( 6500*st,OF+'.lower_bound=0.203;'+OF+'.upper_bound=0.803')
topo.sim.schedule_command( 8000*st,OF+'.lower_bound=0.213;'+OF+'.upper_bound=0.833')
topo.sim.schedule_command(20000*st,OF+'.lower_bound=0.223;'+OF+'.upper_bound=0.863')

### Just to get more progress reports
topo.sim.schedule_command(12000*st,'pass')
topo.sim.schedule_command(16000*st,'pass')

### Settling steps changes
topo.sim.schedule_command( 2000*st,'topo.sim["V1"].tsettle=10')
topo.sim.schedule_command( 5000*st,'topo.sim["V1"].tsettle=11')
topo.sim.schedule_command( 6500*st,'topo.sim["V1"].tsettle=12')
topo.sim.schedule_command( 8000*st,'topo.sim["V1"].tsettle=13')

# default locations for model editor
topo.sim.grid_layout([[None,    'V1',     None],
                      ['LGNOn', None,     'LGNOff'],
                      [None,    'Retina', None]], xstart=150)
