		 CODING CONVENTIONS FOR TOPOGRAPHICA

$Id$

This file specifies conventions to be used for code and documentation
for the Topographica simulator.  By default, all code is assumed to be
written in Python; special notes may be added for other languages such
as C++ as needed.


PYTHON CODING CONVENTIONS

By default, the project uses the standard set of Python coding
conventions written by Guido van Rossum, Python's author:

  http://www.python.org/peps/pep-0008.html

These need not be followed to the letter; they simply help resolve
differences between Topographica authors if there are disagreements.

One particular guideline of these that Jim does not always follow is
that he likes to use lines much longer than 80 characters, e.g. for a
string.  Other differences are listed elsewhere in this file, such as
in the REVISION INFO section.


REVISION CONTROL

Revision control is by CVS.  Please check in changes as soon as they
are stable, e.g. at least by the end of each significant workday.
Conversely, be sure to update your checked out code before doing any
new work.  The goal is to make sure that all developers are always
working with the latest code.

Every CVS commit must include an informative log message, summarizing
the items changed in easily understandable terms, and avoiding
pejorative language (i.e. comments like "Lord only knows what idiot
coded it that way!").  

If so many items were changed that any single log message would have
to be very general (e.g. "Misc changes to many files"), then please
check in smaller groups of files, each with a meaningful log message.
Using smaller, meaningful chunks makes debugging much easier later,
allowing the source of a new bug to be tracked down to a small,
understandable set of changes.  Conversely, if the same trivial
changes were made to a large group of files, please check in all of
those at once, with the same log message, so that it will be clear
that they go together.  

Similarly, when committing files, please do it in the appropriate
order and grouping so that the code works at every time in the CVS
repository history.  That is, if you change several files, adding a
function to one file and then calling it in another, please check in
the file with the new function *first*, and only then check in the
file that calls the function.  If you check them in in the opposite
order, then the repository temporarily will be in a state where it
cannot supply working code.  Even if you know no one else is working
at that time, such gaps make it much more difficult to debug using the
CVS revision history, because they make it impractical to roll back
history one file or change at a time to try to find the source of a
bug.

When making and checking in particularly extensive changes, please
keep refactoring completely separate from new features whenever
possible.  That is, if you have to change or clean up a lot of old
code in order to add a new feature, follow something like this
procedure:

  cvs commit .	  # Commit all outstanding edits
  runtests	  # Verify that things work when you start
  emacs		  # Refactor old code, not changing behavior at all
  runtests	  # Verify that nothing has been broken
  cvs diff        # Will have many widespread changes
  cvs commit -m    "No visible changes" .
  emacs		  # Add new feature and new test for it
  runtests	  # See if tests still work, fixing if necessary
  cvs diff	  # Short list: only the new code
  cvs commit -m    "Added feature Y" .
  
That way nearly all of the lines and files you changed can be tested
thoroughly using the existing test suite as-is, and any tests added
can be tested equally well on both the old and new code.  Then the few
lines implementing the new feature can be added and debugged on their
own, so that it will be very simple to see whether the new feature was
the source of a bug, or whether it was all those other changes that
"shouldn't" have changed anything.


REVISION INFO

Every readable file (i.e. text, source code, html, etc.) should
include an "Id" tag so that the CVS revision information will be
visible immediately, even in files outside of the CVS repository.

For text files, the Id tag should be placed near the top, surrounded
by dollar signs, on a line by itself.  Near the bottom is also
acceptable, but not preferred.  See the top of this file for an
example; CVS fills in all but the letters "Id" and the dollar signs.

For Python files, the Id tag should be placed at the end of the Python
doc string for that module, surrounded by dollar signs, on a line by
itself.  In addition, just after the doc string, the version number of
the file should be declared.  For example:

  """
  The module documentation...

  {dollar}Id{dollar}
  """
  __version__ = "{dollar}Revision{dollar}"

where {dollar} should be replaced with a dollar sign ($).


TEST SUITE

Every Python module should have a corresponding unit test in tests/.
The tests should be nearly exhaustive, in the sense that it should be
unlikely that a good-faith re-implementation of the module would pass
the tests but have significant bugs. Obviously, truly exhaustive tests
capable of detecting arbitrary (e.g. deliberate) errors would be
impractical.

The default set of unit tests that are run must complete very quickly,
with no extraneous output, no GUI windows popping up, etc., because
these tests are (and should be) run automatically many times each day
during active development.  All the output from such tests much be
checked automatically, with any output generated for the user
representing something the user really does have to do something
about.  

Additional more expensive tests, GUI tests, or those requiring user
input or user examination of the output are also encouraged, but all
these must be kept separate from the main automated regression tests.


NUMERICAL UNITS IN THE USER INTERFACE

All quantities visible to the user, such as GUI labels, parameters,
etc. must be in appropriate units that are independent of simulation
or implementation details.  For instance, all coordinates and
subregions of sheets must be in Sheet coordinates, not e.g. exposing
the row and column in the underlying matrix.  Similarly, unit
specifiers should be in Sheet coordinates, selecting the nearest
appropriate unit, not row and column.

Appropriate units for most parameters can be determined by considering
the continuous plane underlying the discrete units forming the model
sheet, and the continuous logical timeline behind the discrete
timesteps in the model. Some parameters should be expressed in terms
of lengths in that plane, some in terms of areas, and some in terms of
volumes, rather than numbers of units, etc.  Others are expressed in
terms of lengths of time, rather than number of time steps.  More
information is available in Bednar et al, Neuroinformatics, 2004.
There is usually only one correct answer for how to specify a
particular parameter, so please discuss it with all, or at least with
Jim, before picking a unit arbitrarily.


GUI

No part of Topographica should import GUI files, rely on the presence
of a particular GUI or any GUI at all, or assume that the data it
generates will be used only by a GUI unless it is absolutely
necessary, e.g. for the actual GUI implementation.  

Many components that would at first glance seem to be GUI-related are
in fact much more general, and should be written for the general case,
not in terms of the GUI (and not even with names or comments that
suggest they are in any way limited to being part of a GUI).

For instance, many of the analysis and plotting routines will be
commonly used in the context of a GUI.  However, the vast majority of
this code is not specific to a GUI, i.e. it does not require a user to
actually move a mouse or manipulate widgets.  E.g. a SheetView is a
bitmap representation of a Sheet; the resulting bitmap can of course
be displayed in a GUI window, but it could also be saved to a file,
and in batch mode or unit tests often *will* be saved directly to a
file, with no GUI window ever created.  Most of the important code for
plotting is independent of the output device, and any such code should
be written using general terminology like Plotting, not GUI.
Similarly for other analysis routines --- they should be implemented
and named in terms of some general module name like Analysis, not GUI.

Obviously, it's very helpful for plots, etc. to have interactive
widgets to set the scales, select subplots, etc.  But these can
generally be implemented in a way that can also be specified
textually, i.e. without a mouse, so that they can be used without a
GUI, or at least without any particular GUI.  Even for things that are
inherently mouse-based, like data exploration tools that change
viewpoints dynamically based on the mouse position, as much code as
possible should be extracted out, made general, and kept out of the
GUI code.

Search the web for Model-View-Controller for more information on this
approach.  Writing the code in this way helps ensure that the core of
the simulator is not dependent on any particular output device, which
is crucial because different output devices are appropriate in
different contexts, e.g. over the web, in non-interactive runs, in
batch testing, supporting different look-and-feel standards, etc.  The
approach also greatly eases maintenance, because GUI libraries often
vary significantly over time and across platforms.  To be able to
maintain our code over the long term, we need to minimize the amount
of our code that depends on such varying details.


REFACTORING/TESTING TIPS

This list of "soundbites" comes from Fowler 1999, Refactoring:
Improving the Design of Existing Code, p 417-418
(http://www.amazon.co.uk/exec/obidos/ASIN/0201485672/).  It seems to
apply reasonably well to this project, particularly the parts about
testing.

Page 7: When you find you have to add a feature to a program, and the
program's code is not structured in a convenient way to add the
feature, first refactor the program to make it easy to add the
feature, then add the feature.

Page 8: Before you start refactoring, check that you have a solid
suite of tests.  These tests must be self-checking.

Page 13: Refactoring changes the programs in small steps.  If you make
a mistake, it is easy to find the bug.

Page 15: Any fool can write code that a computer can understand. Good
programmers write code that humans can understand.

Page 53: Refactoring (noun): a change made to the internal structure of
software to make it easier to understand and cheaper to modify without
changing the observable behavior of the software.

Page 43: Refactor (verb): to restructure software by applying a series
of refactorings without changing the observable behavior of the
software.

Page 58: Three strikes and you refactor.

Page 65: Don't publish interfaces prematurely.  Modify your code
ownership policies to smooth refactoring.

Page 88: When you feel the need to write a comment, first try to
refactor the code so that any comment becomes superfluous.

Page 90: Make sure all tests are fully automatic and that they check
their own results.

Page 90: A suite of tests is a powerful bug detector that decapitates
the time it takes to find bugs.

Page 94: Run your tests frequently.  Localize tests whenever you
compile --- every test at least every day.

Page 97: When you get a bug report, start by writing a unit test that
exposes the bug.

Page 98: It is better to write and run incomplete tests than not to
run complete tests.

Page 99: Think of the boundary conditions under which things might go
wrong and concentrate your tests there.

Page 100: Don't forget to test that exceptions are raised when things
are expected to go wrong.

Page 101: Don't let the fear that testing can't catch all bugs stop
you from writing the tests that will catch most bugs.



