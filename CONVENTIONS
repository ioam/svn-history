		 CODING CONVENTIONS FOR TOPOGRAPHICA

$Id$

This file specifies conventions to be used for code and documentation
for the Topographica simulator.  By default, all code is assumed to be
written in Python; special notes may be added for other languages such
as C++ as needed.


CODING IN PYTHON

If you are familiar with other programming languages, but not Python,
the best place to start is to run the Python tutorial on the
www.python.org web site.  On the first pass, don't try to memorize
anything, just try to get a feel for the overall syntax and workings
of Python.  Then try looking at the Topographica code.  After working
with Topographica a while, it is then a good idea to revisit the
Python tutorial and go over it in more detail, trying to figure
everything out and remember it now that the basic concepts are there.

For those with experience with functional programming languages like
ML, Haskell, Scheme, or Lisp, you will be pleased to find features
such as map, apply, reduce, filter, zip, and list comprehensions.  For
those who aren't familiar with any of those, it is very important to
study the "Functional Programming Tools" and "List Comprehensions"
sections of the tutorial, because we often use those features to write
concise functions that may be hard to understand at first glance.
Lisp programmers should probably check out
http://www.norvig.com/python-lisp.html for details of differences.

For those with experience in Java or C++, a good (opinionated)
introduction is http://dirtsimple.org/2004/12/python-is-not-java.html,
and http://www.ferg.org/projects/python_java_side-by-side.html may
also be useful.



PYTHON CODING CONVENTIONS

By default, the project uses the standard set of Python coding
conventions written by Guido van Rossum, Python's author:

  http://www.python.org/peps/pep-0008.html

These need not be followed to the letter; they simply help resolve
differences between Topographica authors if there are disagreements.

One particular guideline of these that Jim does not always follow is
that he likes to use lines much longer than 80 characters, e.g. for a
string.  Other differences are listed elsewhere in this file, such as
in the REVISION INFO section.

To keep things simple and consistent, we should try to use what seems
to be the most common Python names for the following concepts (as
opposed to those from C++ or Java):

  method       (not 'member function' or 'virtual function')
  subclass     (although 'derived class' is also ok)
  superclass   (although 'base class' is also ok)



USER-LEVEL AND SIMULATOR CODE

By convention, we use a file extension of .py for the Python code
making up the simulator, in the topo/ subdirectory.  Models and other
user-level code such as scripts and examples should use an extension
of .ty, indicating that it is a file for use with Topographica.  (Many
of the .py files are general purpose, and could be used with any
Python program, but the .ty files typically require all or most of
Topographica.)  

All .ty files should use only the publically available classes and
functions in topo/, i.e. they should respect the
(as-yet-only-loosely-defined) Topographica API.

Typically, files will be named with the lowercase version of the main
class which they contain.  E.g. sheet.py contains class Sheet and some
associated functions.  Most files should contain one main class,
though often subclasses are also included (in which case the file
should be named after the parent class).


REVISION CONTROL

Revision control is by CVS.  Please check in changes as soon as they
are stable, e.g. at least by the end of each significant workday.
Conversely, be sure to update your checked out code before doing any
new work.  The goal is to make sure that all developers are always
working with the latest code.

Every CVS commit must include an informative log message, summarizing
the items changed in easily understandable terms, and avoiding
pejorative language (i.e. comments like "Lord only knows what idiot
coded it that way!").  

If so many items were changed that any single log message would have
to be very general (e.g. "Misc changes to many files"), then please
check in smaller groups of files, each with a meaningful log message.
Using smaller, meaningful chunks makes debugging much easier later,
allowing the source of a new bug to be tracked down to a small,
understandable set of changes.  Conversely, if the same trivial
changes were made to a large group of files, please check in all of
those at once, with the same log message, so that it will be clear
that they go together.  

Similarly, when committing files, please do it in the appropriate
order and grouping so that the code works at every time in the CVS
repository history.  That is, if you change several files, adding a
function to one file and then calling it in another, please check in
the file with the new function *first*, and only then check in the
file that calls the function.  If you check them in in the opposite
order, then the repository temporarily will be in a state where it
cannot supply working code.  Even if you know no one else is working
at that time, such gaps make it much more difficult to debug using the
CVS revision history, because they make it impractical to roll back
history one file or change at a time to try to find the source of a
bug.

When making and checking in particularly extensive changes, please
keep refactoring completely separate from new features whenever
possible.  That is, if you have to change or clean up a lot of old
code in order to add a new feature, follow something like this
procedure:

  cvs commit .	  # Commit all outstanding edits
  runtests	  # Verify that things work when you start
  emacs		  # Refactor old code, not changing behavior at all
  runtests	  # Verify that nothing has been broken
  cvs diff        # Will have many widespread changes
  cvs commit -m    "No visible changes" .
  emacs		  # Add new feature and new test for it
  runtests	  # See if tests still work, fixing if necessary
  cvs diff	  # Short list: only the new code
  cvs commit -m    "Added feature Y" .
  
That way nearly all of the lines and files you changed can be tested
thoroughly using the existing test suite as-is, and any tests added
can be tested equally well on both the old and new code.  Then the few
lines implementing the new feature can be added and debugged on their
own, so that it will be very simple to see whether the new feature was
the source of a bug, or whether it was all those other changes that
"shouldn't" have changed anything.


REVISION INFO

Every readable file (i.e. text, source code, html, etc.) should
include an "Id" tag so that the CVS revision information will be
visible immediately, even in files outside of the CVS repository.

For text files, the Id tag should be placed near the top, surrounded
by dollar signs, on a line by itself.  Near the bottom is also
acceptable, but not preferred.  See the top of this file for an
example; CVS fills in all but the letters "Id" and the dollar signs.

For Python files, the Id tag should be placed at the end of the Python
doc string for that module, surrounded by dollar signs, on a line by
itself.  In addition, just after the doc string, the version number of
the file should be declared.  For example:

  """
  The module documentation...

  {dollar}Id{dollar}
  """
  __version__ = "{dollar}Revision{dollar}"

where {dollar} should be replaced with a dollar sign ($).


TEST SUITE

Every Python module should have a corresponding unit test in tests/.
The tests should be nearly exhaustive, in the sense that it should be
unlikely that a good-faith re-implementation of the module would pass
the tests but have significant bugs. Obviously, truly exhaustive tests
capable of detecting arbitrary (e.g. deliberate) errors would be
impractical.

The default set of unit tests that are run must complete very quickly,
with no extraneous output, no GUI windows popping up, etc., because
these tests are (and should be) run automatically many times each day
during active development.  All the output from such tests must be
checked automatically, with any output generated for the user
representing something the user really does have to do something
about.  

Additional more expensive tests, GUI tests, or those requiring user
input or user examination of the output are also encouraged, but all
these must be kept separate from the main automated regression tests.


PARAMETERS AND BOUNDS

When writing user-visible classes, variables that are meant to be
user-modifiable should be of class Parameter, so that they will be
visible in the various user interfaces.

Parameters should have the narrowest type and tightest bounds that
would be meaningful.  For instance, a parameter that can be either
true or false should be of type BooleanParameter, while one that can
only have a value from 0 to 0.5 should be of type Number with a hard
bound of 0 to 0.5.  Using the right types and bounds greatly
simplifies life for the programmer, who can reason about the code
knowing the full allowable range of the parameter, and for the user,
who can tell what values make sense to use.

For Parameters that might show up in a GUI, soft bounds should also be
included wherever appropriate.  These bounds set the range of sliders,
etc., and are a suggested range for the Parameter.  If there are hard
bounds at both ends, soft bounds are not usually needed, but can be
useful if the reasonable range of the Parameter is much smaller than
the legal range.

Parameters should each be documented with an appropriate docstring
passed to the constructor.  The documentation should be written from
the user perspective, not the programmer's, because it will appear in 
various online and other forms of user documentation.


NUMERICAL UNITS IN THE USER INTERFACE

All quantities visible to the user, such as GUI labels, parameters,
etc. must be in appropriate units that are independent of simulation
or implementation details.  For instance, all coordinates and
subregions of sheets must be in Sheet coordinates, not e.g. exposing
the row and column in the underlying matrix.  Similarly, unit
specifiers should be in Sheet coordinates, selecting the nearest
appropriate unit, not row and column.

Appropriate units for most parameters can be determined by considering
the continuous plane underlying the discrete units forming the model
sheet, and the continuous logical timeline behind the discrete
timesteps in the model. Some parameters should be expressed in terms
of lengths in that plane, some in terms of areas, and some in terms of
volumes, rather than numbers of units, etc.  Others are expressed in
terms of lengths of time, rather than number of time steps.  More
information is available in Bednar et al, Neuroinformatics, 2004.
There is usually only one correct answer for how to specify a
particular parameter, so please discuss it with all, or at least with
Jim, before picking a unit arbitrarily.


OBJECT-ORIENTED DESIGN

The design of Topographica is in terms of hierarchical sets of
classes of objects (plus a few collections of unrelated but useful
tidbits).  Most new code will take the form of a new class within an
existing hierarchy, or a new method within an existing class.

When adding a new method, or changing the semantics of an old one, it
is absolutely crucial to think about where in the hierarchy the new
operation is appropriate.  Specifically, an operation should be added
as high in the class hierarchy as is valid (for generality), and no
higher (for correctness).

For instance, consider a hierarchy containing geometric objects for a
drawing program: ProgramObject, Shape, Rectangle.  If you realize when
working on Rectangle that it needs a resize() method, then please stop
and think before adding the operation directly to Rectangle.  In this
case, any Shape can be resized, so resize() should be a method of
Shape.  It may not actually be possible to implement resize() for all
shapes with the same program code, and in that case Shape.resize()
would be written as an abstract method (i.e., would simply return
NotImplementedError).  The resize() function would then be implemented
for each particular shape.  

Conversely, it is not appropriate to add resize() to all
ProgramObjects, because there are surely objects in the program that
are not possible to resize.  Thus it would not normally be appropriate
to have a ProgramObject.resize().  If such a method is required to
solve a particular design problem, it would have to be documented
heavily to ensure that the user only calls it on a Shape.  Such
complexity should be avoided whenever possible, and so be sure not to
add the code at a higher level than appropriate.

In any case, when deciding where to add the code, be sure to think
about the operation in the most general terms for which it makes
sense.  That is, when solving a problem, try interpret it broadly and
solve it at the highest level possible, so that it applies to the
largest appropriate class of objects.  For example, an operation
change_rectangle_width() is clearly not applicable to all Shapes, yet
if the idea is reinterpreted in appropriately general terms,
i.e. resize(), it is clear that the method belongs in the Shape
superclass.  The method then becomes a requirement for every subclass
of Shape -- henceforth every variety of Shape must be able to be
resize()d, and anything that cannot be resize()d cannot be a Shape, by
definition.

It is also extremely important to think about the appropriate name for
an operation or class, so that it is clear how generally or
specifically it can be applied.  Once the name is decided, all
comments and documentation must match that level of generality.  That
is, it would be quite inappropriate to use variable names like
"rect_width" in the arguments to Shape.resize(), or to have
Shape.__doc__="Change the length and width of the rectangle", because
only a few shapes are also Rectangles.  Of course, it is perfectly ok
to give an example in terms of a rectangle: "Change the size of the
given object.  For a Rectangle, this will adjust the length and
width."  But only in examples are such specific subclasses allowed to
be mentioned, because the operation itself applies to a much larger
class of objects.

One way to make sure that you are using appropriate language is to
look at the imports list at the top of the file.  If the imports list
does not include Rectangle, Circle, etc., it is inappropriate ever to
write documentation or comments or use a variable, method, or class
name that assumes that there is anything like a Rectangle or Circle in
the universe.  The fact that the file does not import those other
classes is a declaration that the code in the file may be used whether
or not such other classes exist.  Thus the contents of the file cannot
depend on such external code, even implicitly.  Even some of the
imported items may not be ok to use in names, comments, or
documentation for a particular class, if that particular class is more
widely applicable than the file as a whole.  We need to use every
means available to convey to the reader just how generally this code
can be used, and exactly the sorts of conditions for which it is
applicable.

Such naming and documentation issues may seem trivial, but please try
to imagine that you are another programmer or user reading the file.
If the documentation and variable names suggest that an operation is
limited to some specific case, only an extremely motivated and
perceptive reader will be able to deduce that the operation is
actually applicable to the specific problem that the reader is trying
to solve.  What the reader wants to do is undoubtedly different from
the specific case the programmer originally had in mind, and only if
everything is written at the appropriate level of generality will it
be clear whether the code covers the intended usage or not.

Note that there can be serious consequences for inappropriately
describing the level of generality.  If code is described in greater
generality than is appropriate, users and other programmers will
misuse the object, leading to bugs and other errors.  If code is
described with too little generality, the user will be needlessly
constrained in what he or she can do.  Often in the latter cases,
another programmer will write another function that does the same
thing as the existing one, but for another related case.  This happens
because it was not clear that the existing function was sufficient.
Such extra functions make everyones' life more difficult, because they
make the software much harder to maintain, understand, and use.

To summarize: when adding new code, think (and discuss!) where it
should go and what level of generality is appropriate.  Try to solve
the problem for all time, if it is clear how to do so; otherwise,
solve it for the largest class whose solution *is* clear.  Once the
level has been chosen, make sure all documentation, comments, and
names match that level, pretending that no lower levels exist except
as possible examples.


USING CONSISTENT NAMES

Where there are already classes defined, please use the existing
names when writing new code, documentation, variable names, user
messages, window names, and comments.  (Or else change all of the old
ones to match your new version!)  For instance, Topographica is based
on Sheets, so everything should call a Sheet a Sheet, not a Region,
Area, or Layer.

In particular, when writing user interface code, think about what you
are letting the user plot or manipulate, and ask whether that's one of 
the concepts for which we have (laboriously!) worked out a specific 
term. Examples of acceptable, well-defined terms:

  Sheet
  Unit
  ConnectionField
  Projection
  ProjectionSheet
  CFSheet
  GeneratorSheet
  SheetView
  UnitView
  Event
  EventProcessor
  Activity  

Examples of confusing, ambiguous terms to be avoided:

  region          (Sheets only sometimes correspond to neural regions like V1)
  area            (Same problem as Region)
  map             (Used in too many different senses)
  layer           (Biology and neural-network people use it very differently)
  activation      (Implies a specific stimulus, which is not always true)
  receptive field (Only valid if plotted with reference to the external world)

As discussed for object-oriented design above, such undefined terms
can be used in examples that bring in concepts from the world outside
of Topographica, but they are not appropriate for variable or class
names, documentation, or comments making up the Topographica simulator
itself.


COMMUNICATION: CODE, DOCUMENTATION, AND COMMENTS

Writing Python code is similar to writing anything else: to do it
well, you need to keep your intended audience in mind.  There are
three different audiences for the different types of material in a
Python source file, and thus the guidelines for each category are
different:

  1. Program code: Communicating with the computer and the human reader

     Program code tells the computer what to do, and needs to be
     written so that it is obvious to a human being what the computer
     is being told to do.  This means using class, variable, function,
     and function argument names that say exactly what they are, and
     favoring short, clear bits of code rather than long, convoluted
     logic.  For instance, any function longer than about a screenful
     should be broken up into more meaningful chunks that a human
     can understand.

  2. Docstrings: Communicating with the user
  
     Every file, class, function, and Parameter should have an
     appropriate docstring that says what that object does.  The first
     line of the docstring should be a brief summary that fits into 80
     columns.  If there are additional lines, there should be an
     intervening blank line, followed by this more detailed
     discussion.  For functions, the summary line should use the
     imperative voice, as in """"Return the sum of all arguments.""".
     Such documentation is collected automatically for the online help
     and for the Reference manual, and must be written from the user's
     perspective.  I.e., the docstring must say how someone calling
     this function, class, etc. can use it, rather than having details
     about how it was implemented or its implementation history.

  3. Comments: Communicating with the human reader

     Comments (lines starting with #) are not processed by the
     computer, and are not visible to the user.  Thus comments should
     consist of things that you want to be visible to someone reading
     the file to really understand how something is implemented.
     Usually such a person will either be (a) trying to fix a bug, or
     (b) trying to add a new feature.  Thus the comments should be
     focused on what is needed for such readers.

     Please do not add redundant comments that simply describe what
     each statement does; the code itself documents that already.
     Redundant comments add more work for the reader, because they are
     usually out of date, and not necessarily accurate.  Instead,
     please use comments for things that are not obvious, such as the
     reason a particular approach was chosen, descriptions of things
     that would be nice to add but haven't been done yet, high-level
     explanations of a long section of low-level code, etc.  Do not
     include things relevant to the user; such things go into docstrings.

To summarize, please use code, docstrings, and comments appropriately.
Any bit of information you add to a file should go into the correct
one of those three categories, and all files should be written for all
three of the different intended audiences.


GUI

When coding, the GUI should be considered an optional component.  No
part of Topographica should import GUI files, rely on the presence of
a particular GUI or any GUI at all, or assume that the data it
generates will be used only by a GUI unless it is absolutely
necessary, e.g. for the actual GUI implementation.  This is a special
case of the general principles of object-oriented design discussed
above.

Many components that would at first glance seem to be GUI-related are
in fact much more general, and should be written for the general case,
not in terms of the GUI (and not even with names or comments that
suggest they are in any way limited to being part of a GUI).

For instance, many of the analysis and plotting routines will commonly
be used in the context of a GUI.  However, the vast majority of this
code is not specific to a GUI, i.e. it does not require a user to
actually move a mouse or manipulate widgets.  E.g. a SheetView is a
bitmap representation of a Sheet; the resulting bitmap can of course
be displayed in a GUI window, but it could also be saved to a file,
and in batch mode or unit tests often *will* be saved directly to a
file, with no GUI window ever created.  Most of the important code for
plotting is independent of the output device, and any such code should
be written using general terminology like Plotting, not GUI.
Similarly for other analysis routines --- they should be implemented
and named in terms of some general module name like Analysis, not GUI.

Obviously, it's very helpful for plots, etc. to have interactive
widgets to set the scales, select subplots, etc.  But these can
generally be implemented in a way that can also be specified
textually, i.e. without a mouse, so that they can be used without a
GUI, or at least without any particular GUI.  Even for things that are
inherently mouse-based, like data exploration tools that change
viewpoints dynamically based on the mouse position, as much code as
possible should be extracted out, made general, and kept out of the
GUI code.

If you want more information on this approach, search the web for
Model-View-Controller.  Writing the code in this way helps ensure that
the core of the simulator is not dependent on any particular output
device, which is crucial because different output devices are
appropriate in different contexts, e.g. over the web, in
non-interactive runs, in batch testing, supporting different
look-and-feel standards, etc.  The approach also greatly eases
maintenance, because GUI libraries often vary significantly over time
and across platforms.  To be able to maintain our code over the long
term, we need to minimize the amount of our code that depends on such
varying details.  Finally, this approach ensures that scientific users
can ignore all of the GUI details, which are irrelevant to what
Topographica actually computes.  Allowing them to do so is absolutely
crucial for them to be able to understand and trust what they are
actually simulating.


IMPORTING EXTERNAL FILES AND FUNCTIONS

When at all possible, use a Python standard library function instead
of writing your own code or downloading a separate package.  The
standard library functions are available to all Python platforms
without any maintenance work from us, they will be more readable to
Python programmers (who might just recognize the name instead of
having to study the semantics), and those functions are much less
likely to contain bugs than our own code is because the library
functions have been tested by more people.

Non-standard external Python libraries should be used where
appropriate, i.e. for anything reasonably substantial like plotting or
matrix manipulation.  Including an external package adds an
approximately fixed cost of tracking future updates and changes to it,
handling its licensing issues, increasing the size of our download,
restricting the number of supported platforms, etc.  Including an
external package just for one or two small, simple functions probably
doesn't make sense, but including it for non-trivial items like plot
generation or matrix handling does make sense.  The key question to
answer for any external package is "would the code I'm using from the
external package be easier to maintain on its own, or is it easier to
just include the external package?".  If it's easier just to add those
couple of functions, just copy them; otherwise add the external
package.

When importing code, whether from standard libraries or external
functions, always import only the functions and classes that you are
actually using.  As an example that has already occurred, please do
NOT do anything like "from MLab import *", because of the huge
potential for name clashes resulting in strange, hard-to-track bugs.
For that particular example, python has a built-in function named
max(), but this function is replaced with a matrix-specific version by
"from MLab import *":

  $ bin/python
  >>> max(1.2,0)
  1.2
  >>> from MLab import *
  >>> max(1.2,0)
  Traceback (most recent call last):
    File "<stdin>", line 1, in ?
    File "/lib/python2.4/site-packages/Numeric/MLab.py", line 146, in max
      return maximum.reduce(m,axis)
  ValueError: dimension not in array
  >>> 

Please try to avoid such problems by importing only the specific
functions and classes you need, or (even better where practical) by
importing the package only and then using the fully qualified name
(e.g. "import MLab ; MLab.max()").

If you find that you need to change any file in an external package,
please *DO NOT* change that file, wrap it up into a .tar or .zip
archive, and put it back into the Topographica repository.  Doing so
is a very bad idea, because it prevents us from upgrading that package
in the future.  Instead, keep the original archive intact as
distributed, but then have the external/Makefile patch it
automatically to change the specific items that need editing.  When
the package is updated, the same patch can often be applied as-is to
the new package, and in any case it will be clear exactly where to 
look in the package to make the necessary change.


OPTIMIZATION

According to Knuth, "Premature optimization is the root of all evil".
Although the performance of Topographica is critically important, the
way to achieve high performance is by spending *all* of our
optimization efforts on the very small portion of the code that
accounts for nearly all of the run time, i.e., the bottlenecks.  The
overall architecture of Topographica is designed explicitly to
localize those bottlenecks into specific functions and objects that
can then be heavily optimized without affecting any of the rest of the
code.  Only in such small, local regions, behind well-defined modules
with clear semantics, is it possible to optimize effectively in a way
that can be maintained in the long run.  If it is precisely clear what
the module is supposed to do, then the implementation can be polished
to achieve that, while reasoning only about the behavior of that one
specific module.

Conversely, finding that good performance requires adding special
hacks in the largest-scale, general-purpose parts of the overall
Topographica architecture means that the architecture is flawed and
needs to be re-thought.  For instance, please do not add any special
checks scattered through the code testing for specific
PatternGenerator or Sheet objects, substituting a quicker version of
some operation but falling back to the general case for others.  Such
code is impossible to understand and maintain, because changes to the
specific object implementations will not have any effect.  Instead, we
can optimize the individual PatternGenerator or Sheet object heavily.
If some special hack needs to be done at a high level, e.g. at the
base Sheet class level, we can add a method there that then gets
overridden in the base class with the special purpose code.  That way
all optimization will be local (and thus maintainable).  If it's not
clear how to optimize something cleanly, first do it uncleanly to see
if it will have any effect, but don't check it in to CVS.  If it looks
like the optimization is worthwhile, brainstorm with other team
members to figure out a way to do it cleanly and check in the clean
version instead.



REFACTORING/TESTING TIPS

This list of "soundbites" comes from Fowler 1999, Refactoring:
Improving the Design of Existing Code, p 417-418
(http://www.amazon.co.uk/exec/obidos/ASIN/0201485672/).  It seems to
apply reasonably well to this project, particularly the parts about
testing.

Page 7: When you find you have to add a feature to a program, and the
program's code is not structured in a convenient way to add the
feature, first refactor the program to make it easy to add the
feature, then add the feature.

Page 8: Before you start refactoring, check that you have a solid
suite of tests.  These tests must be self-checking.

Page 13: Refactoring changes the programs in small steps.  If you make
a mistake, it is easy to find the bug.

Page 15: Any fool can write code that a computer can understand. Good
programmers write code that humans can understand.

Page 53: Refactoring (noun): a change made to the internal structure of
software to make it easier to understand and cheaper to modify without
changing the observable behavior of the software.

Page 43: Refactor (verb): to restructure software by applying a series
of refactorings without changing the observable behavior of the
software.

Page 58: Three strikes and you refactor.

Page 65: Don't publish interfaces prematurely.  Modify your code
ownership policies to smooth refactoring.

Page 88: When you feel the need to write a comment, first try to
refactor the code so that any comment becomes superfluous.

Page 90: Make sure all tests are fully automatic and that they check
their own results.

Page 90: A suite of tests is a powerful bug detector that decapitates
the time it takes to find bugs.

Page 94: Run your tests frequently.  Localize tests whenever you
compile --- every test at least every day.

Page 97: When you get a bug report, start by writing a unit test that
exposes the bug.

Page 98: It is better to write and run incomplete tests than not to
run complete tests.

Page 99: Think of the boundary conditions under which things might go
wrong and concentrate your tests there.

Page 100: Don't forget to test that exceptions are raised when things
are expected to go wrong.

Page 101: Don't let the fear that testing can't catch all bugs stop
you from writing the tests that will catch most bugs.



